{"version":3,"sources":["webpack:///./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/scanner.js","webpack:///./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/format.js","webpack:///./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/parser.js","webpack:///./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/main.js"],"names":["createScanner","text","ignoreTrivia","len","length","pos","value","tokenOffset","token","lineNumber","lineStartOffset","tokenLineStartOffset","prevTokenLineStartOffset","scanError","scanHexDigits","count","exact","digits","ch","charCodeAt","setPosition","newPosition","scanNumber","start","isDigit","substring","end","scanString","result","isLineBreak","ch2","ch3","String","fromCharCode","scanNext","code","isWhiteSpace","safeLength","commentClosed","isUnknownContentCharacter","scanNextNonTrivia","getPosition","scan","getToken","getTokenValue","getTokenOffset","getTokenLength","getTokenStartLine","getTokenStartCharacter","getTokenError","format","documentText","range","options","initialIndentLevel","formatText","formatTextStart","rangeStart","rangeEnd","offset","isEOL","endOffset","computeIndentLevel","indentValue","eol","getEOL","lineBreak","indentLevel","insertSpaces","repeat","tabSize","scanner","hasError","newLineAndIndent","editOperations","addEdit","startOffset","push","content","firstToken","firstTokenStart","initialIndent","firstTokenEnd","secondToken","replaceContent","commentTokenStart","secondTokenStart","s","i","nChars","charAt","Math","floor","indexOf","ParseOptions","parse","errors","DEFAULT","currentProperty","currentParent","previousParents","onValue","Array","isArray","visitor","onObjectBegin","object","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","array","onArrayEnd","onLiteralValue","onError","error","visit","getNodePath","node","parent","children","path","type","key","index","getNodeValue","map","obj","Object","create","_i","_a","prop","valueNode","contains","includeRightBound","findNodeAtOffset","item","_scanner","toNoArgVisit","visitFunction","toOneArgVisit","arg","onSeparator","onComment","disallowComments","allowTrailingComma","handleError","skipUntilAfter","skipUntil","parseString","isValue","parseLiteral","JSON","e","parseProperty","parseValue","parseObject","needsComma","parseArray","allowEmptyContent"],"mappings":"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","file":"js/chunk-2d216a22.6251f2f8.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var len = text.length;\n    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* Unknown */;\n        scanError = 0 /* None */;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* UnexpectedEndOfString */;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                var ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* EOF */;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = 1 /* OpenBraceToken */;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = 2 /* CloseBraceToken */;\n            case 91 /* openBracket */:\n                pos++;\n                return token = 3 /* OpenBracketToken */;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = 4 /* CloseBracketToken */;\n            case 58 /* colon */:\n                pos++;\n                return token = 6 /* ColonToken */;\n            case 44 /* comma */:\n                pos++;\n                return token = 5 /* CommaToken */;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* StringLiteral */;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var safeLength = len - 1; // For lookahead.\n                    var commentClosed = false;\n                    while (pos < safeLength) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = 11 /* NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* TrueKeyword */;\n                        case 'false': return token = 9 /* FalseKeyword */;\n                        case 'null': return token = 7 /* NullKeyword */;\n                    }\n                    return token = 16 /* Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n            case 47 /* slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenStartLine: function () { return lineStartOffset; },\n        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },\n        getTokenError: function () { return scanError; },\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner.js';\nexport function format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = createScanner(formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== 17 /* EOF */) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* EOF */) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* CloseBraceToken */) {\n            if (firstToken !== 1 /* OpenBraceToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === 4 /* CloseBracketToken */) {\n            if (firstToken !== 3 /* OpenBracketToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* OpenBracketToken */:\n                case 1 /* OpenBraceToken */:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 5 /* CommaToken */:\n                case 12 /* LineCommentTrivia */:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 13 /* BlockCommentTrivia */:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* ColonToken */:\n                    replaceContent = ' ';\n                    break;\n                case 10 /* StringLiteral */:\n                    if (secondToken === 6 /* ColonToken */) {\n                        replaceContent = '';\n                        break;\n                    }\n                // fall through\n                case 7 /* NullKeyword */:\n                case 8 /* TrueKeyword */:\n                case 9 /* FalseKeyword */:\n                case 11 /* NumericLiteral */:\n                case 2 /* CloseBraceToken */:\n                case 4 /* CloseBracketToken */:\n                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                        replaceContent = ' ';\n                    }\n                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                        hasError = true;\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nexport function isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner.js';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(2 /* InvalidNumberFormat */);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(2 /* InvalidNumberFormat */);\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format.js';\nimport * as edit from './impl/edit.js';\nimport * as scanner from './impl/scanner.js';\nimport * as parser from './impl/parser.js';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport var stripComments = parser.stripComments;\nexport function printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ValueExpected */: return 'ValueExpected';\n        case 5 /* ColonExpected */: return 'ColonExpected';\n        case 6 /* CommaExpected */: return 'CommaExpected';\n        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = edit.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n"],"sourceRoot":""}