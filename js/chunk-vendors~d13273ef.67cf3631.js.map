{"version":3,"sources":["webpack:///./node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js","webpack:///./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","webpack:///./node_modules/monaco-editor/esm/vs/editor/common/model/textModelEvents.js","webpack:///./node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack:///./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack:///./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js"],"names":["countEOL","text","eolCount","firstLineLength","lastLineStart","i","len","length","chr","charCodeAt","getDefaultMetadata","topLevelLanguageId","EMPTY_LINE_TOKENS","Uint32Array","buffer","MultilineTokensBuilder","this","tokens","prototype","add","lineNumber","lineTokens","last","lastLineNumber","startLineNumber","push","MultilineTokens","SparseEncodedTokens","_tokens","_tokenCount","getMaxDeltaLine","tokenCount","getTokenCount","getDeltaLine","tokenIndex","getStartCharacter","getEndCharacter","getMetadata","clear","acceptDeleteRange","horizontalShiftForFirstLineTokens","startDeltaLine","startCharacter","endDeltaLine","endCharacter","deletedLineCount","newTokenCount","hasDeletedTokens","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","Error","destOffset","acceptInsertText","deltaLine","character","lastLineLength","firstCharCode","isInsertingPreciselyOneWordCharacter","offset","tokenLength","LineTokens2","actual","startTokenIndex","endTokenIndex","_actual","_startTokenIndex","_endTokenIndex","getCount","MultilineTokens2","endLineNumber","_updateEndLineNumber","getLineTokens","findResult","_findTokensWithLine","low","high","mid","Math","floor","midDeltaLine","min","max","applyEdit","range","_a","acceptEdit","_acceptDeleteRange","_acceptInsertText","startColumn","endColumn","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","deletedBefore","position","lineIndex","column","toUint32Array","arr","TokensStore2","_pieces","flush","set","pieces","addSemanticTokens","aTokens","pieceIndex","_findFirstPieceWithLine","bTokens","aLen","bLen","aIndex","result","resultLen","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","getLineContent","_i","piece","TokensStore","_lineTokens","_len","getTokens","lineText","rawLineTokens","_massageTokens","lineTextLength","hasDifferentLanguageId","getLanguageId","tokens_1","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","setTokens","_deleteEnding","lastLineTokens","_deleteBeginning","_append","_delete","_insert","toChIndex","fromChIndex","tokensCount","dest","lastEnd","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta_1","delta","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","LIMIT_FIND_COUNT","SearchParams","searchString","isRegex","matchCase","wordSeparators","parseSearchRequest","multiline","isMultilineRegexSource","indexOf","regex","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","chCode","nextChCode","simpleSearch","createFindMatch","rawMatches","captureMatches","matches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","TextModelSearch","findMatches","model","searchParams","searchRange","limitResultCount","searchData","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","_getMultilineMatchRange","deltaOffset","lfCounter","matchIndex","match0","startOffset","endOffset","lineFeedCountBeforeMatch","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","startPosition","getPositionAt","endPosition","searcher","m","getOffsetAt","getStartPosition","getValueInRange","getEOL","counter","reset","next","index","text_1","substring","_findMatchesInLine","text_2","searchStringLen","lastMatchIndex","isValidMatch","findNextMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","lineCount","getLineCount","getLineMaxColumn","r","_findFirstMatchInLine","text_3","r_1","fromColumn","findPreviousMatch","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","text_4","r_2","bestResult","leftIsWordBounday","matchStartIndex","matchLength","charBefore","get","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","ModelRawFlush","changeType","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","containsEvent","type","change","merge","a","b","concat","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","other","_mergeChangeEvents","eol","isFlush","__extends","extendStatics","d","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","create","TokenizationStateStore","_beginState","_valid","_invalidLineStartIndex","_reset","initialState","_setBeginState","defineProperty","enumerable","configurable","_invalidateLine","_isValid","getBeginState","beginState","valid","arrays","_setValid","setEndState","linesLength","endState","previousEndState","equals","setFakeTokens","applyEdits","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","j","_super","TextModelTokenization","textModel","_this","call","_isDisposed","_textModel","_tokenizationStateStore","_tokenizationSupport","_register","onDidChange","e","languageIdentifier","getLanguageIdentifier","changedLanguages","language","_resetTokenizationState","clearTokens","onDidChangeRawContentFast","onDidChangeContentFast","_beginBackgroundTokenization","onDidChangeAttached","onDidChangeLanguage","dispose","initializeTokenization","tokenizationSupport","isAttachedToEditor","_hasLinesToTokenize","platform","_revalidateTokensNow","MAX_ALLOWED_TIME","builder","sw","elapsed","tokenizedLineNumber","_tokenizeOneInvalidLine","tokenizeViewport","_tokenizeViewport","forceTokenization","_updateTokensUntilLine","isCheapToTokenize","firstInvalidLineNumber","invalidLineStartIndex","getLineLength","endLineIndex","lineStartState","safeTokenize","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","getInitialState","state","isTooLargeForTokenization","tokenize2","clone","id","convertToEndOffset","createTextBufferBuilder","createTextBufferFactory","acceptChunk","finish","createTextBuffer","value","defaultEOL","factory","MODEL_ID","LONG_LINE_BOUNDARY","invalidFunc","TextModel","source","creationOptions","associatedResource","_onWillDispose","onWillDispose","event","_onDidChangeDecorations","onDidChangeDecorations","_onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","_eventEmitter","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","_buffer","_options","resolveOptions","bufferLineCount","bufferTextLength","getValueLengthInRange","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_isDisposing","_languageIdentifier","_languageRegistryListener","fire","_instanceId","strings","_lastDecorationId","_decorations","_decorationsTree","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_tokens2","_tokenization","createFromString","options","uri","DEFAULT_CREATION_OPTIONS","textBuffer","detectIndentation","guessedIndentation","tabSize","insertSpaces","indentSize","trimAutoWhitespace","listener","fastEvent","onDidChangeRawContent","slowEvent","onDidChangeContent","_assertNotDisposed","_emitContentChangedEvent","rawChange","setValue","setValueFromTextBuffer","_createContentChanged2","rangeOffset","rangeLength","getVersionId","oldFullModelRange","getFullModelRange","oldModelValueLength","_increaseVersionId","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","allDecorations","search","_ensureNodesHaveRanges","collectNodesPostOrder","node","cachedAbsoluteStart","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","undefined","onBeforeDetached","getAttachedEditorCount","isTooLargeForSyncing","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","getOptions","getFormattingOptions","updateOptions","_newOpts","newOpts","createChangeEvent","defaultInsertSpaces","defaultTabSize","_normalizeIndentationFromWhitespace","str","spacesCnt","charAt","tabsCnt","normalizeIndentation","firstNonWhitespaceIndex","mightContainRTL","mightContainNonBasicASCII","getAlternativeVersionId","rawPosition","_validatePosition","rawOffset","getLength","_overwriteAlternativeVersionId","newAlternativeVersionId","preserveBOM","fullModelRange","fullModelValue","getBOM","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLinesContent","getLineMinColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","isNaN","charCodeBefore","getLineCharCode","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","rawSearchScope","isIRange","rawSearchStart","ret","pushStackElement","pushEOL","currentEOL","beginDeferredEmit","endDeferredEmit","pushEditOperations","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","incomingEdits","map","op","editsAreNearCursors","sel","foundEditNearSel","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","pushEditOperation","rawOperations","_applyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","rawContentChanges","acceptReplace","forceMoveMarkers","changeLineCountDelta","editLineNumber","currentEditLineNumber","spliceStartLineNumber","spliceLineNumber","cnt","newLines","i_1","reverseEdits","_undo","undo","recordedVersionId","selections","canUndo","_redo","redo","canRedo","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","resolveNode","_getRangeAt","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","_getDecorationsInRange","getDecorationsInRange","validatedRange","getOverviewRulerDecorations","getAllDecorations","filterRange","filterOwnerId","intervalSearch","getRangeAt","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setLineTokens","ranges","element","_emitModelTokensChangedEvent","tokenizationSupportChanged","setSemanticTokens","resetTokenization","tokenizeIfCheap","_getLineTokens","syntacticTokens","getModeId","setMode","oldLanguage","newLanguage","getLanguageIdAtPosition","findTokenIndexAtOffset","getWordAtPosition","_position","lineContent","_findLanguageBoundaries","rbStartOffset","rbEndOffset","rightBiasedWord","getWordDefinition","_b","lbStartOffset","lbEndOffset","leftBiasedWord","languageId","getWordUntilPosition","wordAtPosition","word","substr","findMatchingBracketUp","_bracket","bracket","bracketsSupport","getBracketsSupport","data","textIsBracket","_findMatchingBracketUp","matchBracket","_matchBracket","currentModeBrackets","getStandardTokenType","searchStartOffset","maxBracketLength","searchEndOffset","foundBracket","findNextBracketInRange","forwardRegex","foundBracketText","_matchFoundBracket","textIsOpenBracket","prevTokenIndex","prevModeBrackets","tokenStartOffset","findPrevBracketInRange","reversedRegex","isOpen","matched","_findMatchingBracketDown","getEndPosition","reversedBracketRegex","count","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","findPrevBracket","modeBrackets","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","maxDuration","savedCounts","Map","counts","resetCounts","has","brackets","searchInRange","startTime","Date","now","elapsedTime","open","close","computeIndentLevel","line","indent","_computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","foldingRules","getFoldingRules","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent_1","indent_2","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","indent_3","indent_4","goUp","goDown","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","DecorationsTrees","_decorationsTree0","_decorationsTree1","r0","r1","overviewRulerOnly","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","Center","getColor","theme","_resolveColor","invalidateCachedColor","c","toString","ModelDecorationMinimapOptions","fromHex","ModelDecorationOptions","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","showIfCollapsed","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","marginClassName","inlineClassName","inlineClassNameAffectsLetterSpacing","beforeContentClassName","afterContentClassName","register","createDynamic","EMPTY","DidChangeDecorationsEmitter","_deferredCnt","_shouldFire","DidChangeContentEmitter","_fastEmitter","_slowEmitter","_deferredEvent","USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","USUAL_WORD_SEPARATORS_1","sep","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","flags","ignoreCase","getWordAtPosFast","textOffset","match","pos","lastIndexOf","getWordAtPosSlow","getWordAtText"],"mappings":"wHAAA,gQAQO,SAASA,EAASC,GAIrB,IAHA,IAAIC,EAAW,EACXC,EAAkB,EAClBC,EAAgB,EACXC,EAAI,EAAGC,EAAML,EAAKM,OAAQF,EAAIC,EAAKD,IAAK,CAC7C,IAAIG,EAAMP,EAAKQ,WAAWJ,GACd,KAARG,GACiB,IAAbN,IACAC,EAAkBE,GAEtBH,IACIG,EAAI,EAAIC,GAAkC,KAA3BL,EAAKQ,WAAWJ,EAAI,IAEnCA,IAKJD,EAAgBC,EAAI,GAEP,KAARG,IACY,IAAbN,IACAC,EAAkBE,GAEtBH,IACAE,EAAgBC,EAAI,GAM5B,OAHiB,IAAbH,IACAC,EAAkBF,EAAKM,QAEpB,CAACL,EAAUC,EAAiBF,EAAKM,OAASH,GAErD,SAASM,EAAmBC,GACxB,OACM,MADGA,GAAsB,EAIxB,GAA6B,MAAiC,EAEzE,IAAIC,EAAoB,IAAKC,YAAY,GAAIC,OACzCC,EAAwC,WACxC,SAASA,IACLC,KAAKC,OAAS,GAclB,OAZAF,EAAuBG,UAAUC,IAAM,SAAUC,EAAYC,GACzD,GAAIL,KAAKC,OAAOV,OAAS,EAAG,CACxB,IAAIe,EAAON,KAAKC,OAAOD,KAAKC,OAAOV,OAAS,GACxCgB,EAAiBD,EAAKE,gBAAkBF,EAAKL,OAAOV,OAAS,EACjE,GAAIgB,EAAiB,IAAMH,EAGvB,YADAE,EAAKL,OAAOQ,KAAKJ,GAIzBL,KAAKC,OAAOQ,KAAK,IAAIC,EAAgBN,EAAY,CAACC,MAE/CN,EAhBgC,GAmBvCY,EAAqC,WACrC,SAASA,EAAoBV,GACzBD,KAAKY,QAAUX,EACfD,KAAKa,YAAcZ,EAAOV,OAAS,EAmQvC,OAjQAoB,EAAoBT,UAAUY,gBAAkB,WAC5C,IAAIC,EAAaf,KAAKgB,gBACtB,OAAmB,IAAfD,GACQ,EAELf,KAAKiB,aAAaF,EAAa,IAE1CJ,EAAoBT,UAAUc,cAAgB,WAC1C,OAAOhB,KAAKa,aAEhBF,EAAoBT,UAAUe,aAAe,SAAUC,GACnD,OAAOlB,KAAKY,QAAQ,EAAIM,IAE5BP,EAAoBT,UAAUiB,kBAAoB,SAAUD,GACxD,OAAOlB,KAAKY,QAAQ,EAAIM,EAAa,IAEzCP,EAAoBT,UAAUkB,gBAAkB,SAAUF,GACtD,OAAOlB,KAAKY,QAAQ,EAAIM,EAAa,IAEzCP,EAAoBT,UAAUmB,YAAc,SAAUH,GAClD,OAAOlB,KAAKY,QAAQ,EAAIM,EAAa,IAEzCP,EAAoBT,UAAUoB,MAAQ,WAClCtB,KAAKa,YAAc,GAEvBF,EAAoBT,UAAUqB,kBAAoB,SAAUC,EAAmCC,EAAgBC,EAAgBC,EAAcC,GAgDzI,IALA,IAAI3B,EAASD,KAAKY,QACdG,EAAaf,KAAKa,YAClBgB,EAAoBF,EAAeF,EACnCK,EAAgB,EAChBC,GAAmB,EACd1C,EAAI,EAAGA,EAAI0B,EAAY1B,IAAK,CACjC,IAAI2C,EAAY,EAAI3C,EAChB4C,EAAiBhC,EAAO+B,GACxBE,EAAsBjC,EAAO+B,EAAY,GACzCG,EAAoBlC,EAAO+B,EAAY,GACvCI,EAAgBnC,EAAO+B,EAAY,GACvC,GAAIC,EAAiBR,GAAmBQ,IAAmBR,GAAkBU,GAAqBT,EAG9FI,QAHJ,CAMK,GAAIG,IAAmBR,GAAkBS,EAAsBR,EAG5DO,IAAmBN,GAAgBQ,EAAoBP,EAGvDO,GAAsBP,EAAeF,EAMrCS,EAAoBT,OAGvB,GAAIO,IAAmBR,GAAkBS,IAAwBR,EAAgB,CAElF,KAAIO,IAAmBN,GAAgBQ,EAAoBP,GAKtD,CAIDG,GAAmB,EACnB,SAPAI,GAAsBP,EAAeF,OAUxC,GAAIO,EAAiBN,GAAiBM,IAAmBN,GAAgBO,EAAsBN,EAAe,CAE/G,KAAIK,IAAmBN,GAAgBQ,EAAoBP,GAgBtD,CAIDG,GAAmB,EACnB,SAlBIE,IAAmBR,GAGnBS,EAAsBR,EACtBS,EAAoBD,GAAuBC,EAAoBP,KAK/DM,EAAsB,EACtBC,EAAoBD,GAAuBC,EAAoBP,SAWtE,GAAIK,EAAiBN,EAAc,CAEpC,GAAyB,IAArBE,IAA2BE,EAAkB,CAE7CD,EAAgBf,EAChB,MAEJkB,GAAkBJ,MAEjB,MAAII,IAAmBN,GAAgBO,GAAuBN,GAW/D,MAAM,IAAIS,MAAM,iBATZb,GAAwD,IAAnBS,IACrCC,GAAuBV,EACvBW,GAAqBX,GAEzBS,GAAkBJ,EAClBK,GAAwBN,EAAeF,EACvCS,GAAsBP,EAAeF,EAKzC,IAAIY,EAAa,EAAIR,EACrB7B,EAAOqC,GAAcL,EACrBhC,EAAOqC,EAAa,GAAKJ,EACzBjC,EAAOqC,EAAa,GAAKH,EACzBlC,EAAOqC,EAAa,GAAKF,EACzBN,KAEJ9B,KAAKa,YAAciB,GAEvBnB,EAAoBT,UAAUqC,iBAAmB,SAAUC,EAAWC,EAAWvD,EAAUC,EAAiBuD,EAAgBC,GAqBxH,IAPA,IAAIC,EAAqD,IAAb1D,GACjB,IAApBC,IACEwD,GAAiB,IAAmBA,GAAiB,IAClDA,GAAiB,IAAcA,GAAiB,IAChDA,GAAiB,IAAcA,GAAiB,KACxD1C,EAASD,KAAKY,QACdG,EAAaf,KAAKa,YACbxB,EAAI,EAAGA,EAAI0B,EAAY1B,IAAK,CACjC,IAAIwD,EAAS,EAAIxD,EACb4C,EAAiBhC,EAAO4C,GACxBX,EAAsBjC,EAAO4C,EAAS,GACtCV,EAAoBlC,EAAO4C,EAAS,GACxC,KAAIZ,EAAiBO,GAAcP,IAAmBO,GAAaL,EAAoBM,GAAvF,CAKK,GAAIR,IAAmBO,GAAaL,IAAsBM,EAAW,CAGtE,IAAIG,EAIA,SAHAT,GAAqB,OAMxB,GAAIF,IAAmBO,GAAaN,EAAsBO,GAAaA,EAAYN,EAEnE,IAAbjD,EAEAiD,GAAqBhD,EAIrBgD,EAAoBM,MAGvB,CAED,GAAIR,IAAmBO,GAAaN,IAAwBO,GAIpDG,EACA,SAIR,GAAIX,IAAmBO,EAGnB,GAFAP,GAAkB/C,EAED,IAAbA,EACAgD,GAAuB/C,EACvBgD,GAAqBhD,MAEpB,CACD,IAAI2D,EAAcX,EAAoBD,EACtCA,EAAsBQ,GAAkBR,EAAsBO,GAC9DN,EAAoBD,EAAsBY,OAI9Cb,GAAkB/C,EAG1Be,EAAO4C,GAAUZ,EACjBhC,EAAO4C,EAAS,GAAKX,EACrBjC,EAAO4C,EAAS,GAAKV,KAGtBxB,EAtQ6B,GAyQpCoC,EAA6B,WAC7B,SAASA,EAAYC,EAAQC,EAAiBC,GAC1ClD,KAAKmD,QAAUH,EACfhD,KAAKoD,iBAAmBH,EACxBjD,KAAKqD,eAAiBH,EAc1B,OAZAH,EAAY7C,UAAUoD,SAAW,WAC7B,OAAOtD,KAAKqD,eAAiBrD,KAAKoD,iBAAmB,GAEzDL,EAAY7C,UAAUiB,kBAAoB,SAAUD,GAChD,OAAOlB,KAAKmD,QAAQhC,kBAAkBnB,KAAKoD,iBAAmBlC,IAElE6B,EAAY7C,UAAUkB,gBAAkB,SAAUF,GAC9C,OAAOlB,KAAKmD,QAAQ/B,gBAAgBpB,KAAKoD,iBAAmBlC,IAEhE6B,EAAY7C,UAAUmB,YAAc,SAAUH,GAC1C,OAAOlB,KAAKmD,QAAQ9B,YAAYrB,KAAKoD,iBAAmBlC,IAErD6B,EAlBqB,GAqB5BQ,EAAkC,WAClC,SAASA,EAAiB/C,EAAiBP,GACvCD,KAAKQ,gBAAkBA,EACvBR,KAAKC,OAASA,EACdD,KAAKwD,cAAgBxD,KAAKQ,gBAAkBR,KAAKC,OAAOa,kBAwG5D,OAtGAyC,EAAiBrD,UAAUuD,qBAAuB,WAC9CzD,KAAKwD,cAAgBxD,KAAKQ,gBAAkBR,KAAKC,OAAOa,mBAE5DyC,EAAiBrD,UAAUwD,cAAgB,SAAUtD,GACjD,GAAIJ,KAAKQ,iBAAmBJ,GAAcA,GAAcJ,KAAKwD,cAAe,CACxE,IAAIG,EAAaJ,EAAiBK,oBAAoB5D,KAAKC,OAAQG,EAAaJ,KAAKQ,iBACrF,GAAImD,EAAY,CACZ,IAAIV,EAAkBU,EAAW,GAAIT,EAAgBS,EAAW,GAChE,OAAO,IAAIZ,EAAY/C,KAAKC,OAAQgD,EAAiBC,IAG7D,OAAO,MAEXK,EAAiBK,oBAAsB,SAAU3D,EAAQuC,GACrD,IAAIqB,EAAM,EACNC,EAAO7D,EAAOe,gBAAkB,EACpC,MAAO6C,EAAMC,EAAM,CACf,IAAIC,EAAMF,EAAMG,KAAKC,OAAOH,EAAOD,GAAO,GACtCK,EAAejE,EAAOgB,aAAa8C,GACvC,GAAIG,EAAe1B,EACfqB,EAAME,EAAM,MAEX,MAAIG,EAAe1B,GAGnB,CACD,IAAI2B,EAAMJ,EACV,MAAOI,EAAMN,GAAO5D,EAAOgB,aAAakD,EAAM,KAAO3B,EACjD2B,IAEJ,IAAIC,EAAML,EACV,MAAOK,EAAMN,GAAQ7D,EAAOgB,aAAamD,EAAM,KAAO5B,EAClD4B,IAEJ,MAAO,CAACD,EAAKC,GAXbN,EAAOC,EAAM,GAcrB,OAAI9D,EAAOgB,aAAa4C,KAASrB,EACtB,CAACqB,EAAKA,GAEV,MAEXN,EAAiBrD,UAAUmE,UAAY,SAAUC,EAAOrF,GACpD,IAAIsF,EAAKvF,EAASC,GAAOC,EAAWqF,EAAG,GAAIpF,EAAkBoF,EAAG,GAAI7B,EAAiB6B,EAAG,GACxFvE,KAAKwE,WAAWF,EAAOpF,EAAUC,EAAiBuD,EAAgBzD,EAAKM,OAAS,EAAIN,EAAKQ,WAAW,GAAK,IAE7G8D,EAAiBrD,UAAUsE,WAAa,SAAUF,EAAOpF,EAAUC,EAAiBuD,EAAgBC,GAChG3C,KAAKyE,mBAAmBH,GACxBtE,KAAK0E,kBAAkB,IAAI,OAASJ,EAAM9D,gBAAiB8D,EAAMK,aAAczF,EAAUC,EAAiBuD,EAAgBC,GAC1H3C,KAAKyD,wBAETF,EAAiBrD,UAAUuE,mBAAqB,SAAUH,GACtD,GAAIA,EAAM9D,kBAAoB8D,EAAMd,eAAiBc,EAAMK,cAAgBL,EAAMM,UAAjF,CAIA,IAAIC,EAAiBP,EAAM9D,gBAAkBR,KAAKQ,gBAC9CsE,EAAgBR,EAAMd,cAAgBxD,KAAKQ,gBAC/C,GAAIsE,EAAgB,EAApB,CAEI,IAAIC,EAAoBD,EAAgBD,EACxC7E,KAAKQ,iBAAmBuE,MAH5B,CAMA,IAAIC,EAAoBhF,KAAKC,OAAOa,kBACpC,KAAI+D,GAAkBG,EAAoB,GAA1C,CAIA,GAAIH,EAAiB,GAAKC,GAAiBE,EAAoB,EAI3D,OAFAhF,KAAKQ,gBAAkB,OACvBR,KAAKC,OAAOqB,QAGhB,GAAIuD,EAAiB,EAAG,CACpB,IAAII,GAAiBJ,EACrB7E,KAAKQ,iBAAmByE,EACxBjF,KAAKC,OAAOsB,kBAAkB+C,EAAMK,YAAc,EAAG,EAAG,EAAGG,EAAeR,EAAMM,UAAY,QAG5F5E,KAAKC,OAAOsB,kBAAkB,EAAGsD,EAAgBP,EAAMK,YAAc,EAAGG,EAAeR,EAAMM,UAAY,OAGjHrB,EAAiBrD,UAAUwE,kBAAoB,SAAUQ,EAAUhG,EAAUC,EAAiBuD,EAAgBC,GAC1G,GAAiB,IAAbzD,GAAsC,IAApBC,EAAtB,CAIA,IAAIgG,EAAYD,EAAS9E,WAAaJ,KAAKQ,gBAC3C,GAAI2E,EAAY,EAEZnF,KAAKQ,iBAAmBtB,MAF5B,CAKA,IAAI8F,EAAoBhF,KAAKC,OAAOa,kBAChCqE,GAAaH,EAAoB,GAIrChF,KAAKC,OAAOsC,iBAAiB4C,EAAWD,EAASE,OAAS,EAAGlG,EAAUC,EAAiBuD,EAAgBC,MAErGY,EA5G0B,GA+GjC7C,EAAiC,WACjC,SAASA,EAAgBF,EAAiBP,GACtCD,KAAKQ,gBAAkBA,EACvBR,KAAKC,OAASA,EAElB,OAAOS,EALyB,GAQpC,SAAS2E,EAAcC,GACnB,OAAIA,aAAezF,YACRyF,EAGA,IAAIzF,YAAYyF,GAG/B,IAAIC,EAA8B,WAC9B,SAASA,IACLvF,KAAKwF,QAAU,GAiGnB,OA/FAD,EAAarF,UAAUuF,MAAQ,WAC3BzF,KAAKwF,QAAU,IAEnBD,EAAarF,UAAUwF,IAAM,SAAUC,GACnC3F,KAAKwF,QAAUG,GAAU,IAE7BJ,EAAarF,UAAU0F,kBAAoB,SAAUxF,EAAYyF,GAC7D,IAAIF,EAAS3F,KAAKwF,QAClB,GAAsB,IAAlBG,EAAOpG,OACP,OAAOsG,EAEX,IAAIC,EAAaP,EAAaQ,wBAAwBJ,EAAQvF,GAC1D4F,EAAUhG,KAAKwF,QAAQM,GAAYpC,cAActD,GACrD,IAAK4F,EACD,OAAOH,EAMX,IAJA,IAAII,EAAOJ,EAAQvC,WACf4C,EAAOF,EAAQ1C,WACf6C,EAAS,EACTC,EAAS,GAAIC,EAAY,EACpBC,EAAS,EAAGA,EAASJ,EAAMI,IAAU,CAC1C,IAAIC,EAAkBP,EAAQ7E,kBAAkBmF,GAC5CE,EAAgBR,EAAQ5E,gBAAgBkF,GACxCG,EAAYT,EAAQ3E,YAAYiF,GAChCI,IAAuB,EAAZD,EAA2C,KAAyB,IAC/D,EAAZA,EAAyC,KAAuB,IACpD,EAAZA,EAA8C,KAA4B,IAC9D,EAAZA,EAA+C,QAAgC,IACnE,GAAZA,EAAgD,WAAmC,MAAQ,EAC/FE,GAAUD,IAAW,EAEzB,MAAOP,EAASF,GAAQJ,EAAQe,aAAaT,IAAWI,EACpDH,EAAOC,KAAeR,EAAQe,aAAaT,GAC3CC,EAAOC,KAAeR,EAAQxE,YAAY8E,GAC1CA,IAGAA,EAASF,GAAQJ,EAAQgB,eAAeV,GAAUI,IAClDH,EAAOC,KAAeE,EACtBH,EAAOC,KAAeR,EAAQxE,YAAY8E,IAG9C,MAAOA,EAASF,GAAQJ,EAAQe,aAAaT,GAAUK,EACnDJ,EAAOC,KAAeR,EAAQe,aAAaT,GAC3CC,EAAOC,KAAgBR,EAAQxE,YAAY8E,GAAUQ,EAAUF,EAAYC,EAC3EP,IAEJ,GAAIA,EAASF,GAAQJ,EAAQe,aAAaT,KAAYK,EAElDJ,EAAOC,KAAeR,EAAQe,aAAaT,GAC3CC,EAAOC,KAAgBR,EAAQxE,YAAY8E,GAAUQ,EAAUF,EAAYC,EAC3EP,QAEC,CACD,IAAIW,EAAc9C,KAAKG,IAAIH,KAAKI,IAAI,EAAG+B,EAAS,GAAIF,EAAO,GAE3DG,EAAOC,KAAeG,EACtBJ,EAAOC,KAAgBR,EAAQxE,YAAYyF,GAAeH,EAAUF,EAAYC,GAIxF,MAAOP,EAASF,EACZG,EAAOC,KAAeR,EAAQe,aAAaT,GAC3CC,EAAOC,KAAeR,EAAQxE,YAAY8E,GAC1CA,IAEJ,OAAO,IAAI,OAAW,IAAItG,YAAYuG,GAASP,EAAQkB,mBAE3DxB,EAAaQ,wBAA0B,SAAUJ,EAAQvF,GACrD,IAAIyD,EAAM,EACNC,EAAO6B,EAAOpG,OAAS,EAC3B,MAAOsE,EAAMC,EAAM,CACf,IAAIC,EAAMF,EAAMG,KAAKC,OAAOH,EAAOD,GAAO,GAC1C,GAAI8B,EAAO5B,GAAKP,cAAgBpD,EAC5ByD,EAAME,EAAM,MAEX,MAAI4B,EAAO5B,GAAKvD,gBAAkBJ,GAGlC,CACD,MAAO2D,EAAMF,GAAO8B,EAAO5B,EAAM,GAAGvD,iBAAmBJ,GAAcA,GAAcuF,EAAO5B,EAAM,GAAGP,cAC/FO,IAEJ,OAAOA,EANPD,EAAOC,EAAM,GASrB,OAAOF,GAGX0B,EAAarF,UAAUsE,WAAa,SAAUF,EAAOpF,EAAUC,EAAiBuD,EAAgBC,GAC5F,IAAK,IAAIqE,EAAK,EAAGzC,EAAKvE,KAAKwF,QAASwB,EAAKzC,EAAGhF,OAAQyH,IAAM,CACtD,IAAIC,EAAQ1C,EAAGyC,GACfC,EAAMzC,WAAWF,EAAOpF,EAAUC,EAAiBuD,EAAgBC,KAGpE4C,EAnGsB,GAsG7B2B,EAA6B,WAC7B,SAASA,IACLlH,KAAKmH,YAAc,GACnBnH,KAAKoH,KAAO,EAwOhB,OAtOAF,EAAYhH,UAAUuF,MAAQ,WAC1BzF,KAAKmH,YAAc,GACnBnH,KAAKoH,KAAO,GAEhBF,EAAYhH,UAAUmH,UAAY,SAAU1H,EAAoBwF,EAAWmC,GACvE,IAAIC,EAAgB,KAIpB,GAHIpC,EAAYnF,KAAKoH,OACjBG,EAAgBvH,KAAKmH,YAAYhC,IAEf,OAAlBoC,GAA0BA,IAAkB3H,EAC5C,OAAO,IAAI,OAAWyF,EAAckC,GAAgBD,GAExD,IAAIjH,EAAa,IAAIR,YAAY,GAGjC,OAFAQ,EAAW,GAAKiH,EAAS/H,OACzBc,EAAW,GAAKX,EAAmBC,GAC5B,IAAI,OAAWU,EAAYiH,IAEtCJ,EAAYM,eAAiB,SAAU7H,EAAoB8H,EAAgB7G,GACvE,IAAIX,EAASW,EAAUyE,EAAczE,GAAW,KAChD,GAAuB,IAAnB6G,EAAsB,CACtB,IAAIC,GAAyB,EAI7B,GAHIzH,GAAUA,EAAOV,OAAS,IAC1BmI,EAA0B,OAAcC,cAAc1H,EAAO,MAAQN,IAEpE+H,EACD,OAAO9H,EAGf,IAAKK,GAA4B,IAAlBA,EAAOV,OAAc,CAChC,IAAIqI,EAAW,IAAI/H,YAAY,GAG/B,OAFA+H,EAAS,GAAKH,EACdG,EAAS,GAAKlI,EAAmBC,GAC1BiI,EAAS9H,OAIpB,OADAG,EAAOA,EAAOV,OAAS,GAAKkI,EACF,IAAtBxH,EAAO4H,YAAoB5H,EAAO6H,aAAe7H,EAAOH,OAAOgI,WAExD7H,EAAOH,OAEXG,GAEXiH,EAAYhH,UAAU6H,YAAc,SAAU5C,GAC1C,MAAOA,GAAanF,KAAKoH,KACrBpH,KAAKmH,YAAYnH,KAAKoH,MAAQ,KAC9BpH,KAAKoH,QAGbF,EAAYhH,UAAU8H,aAAe,SAAUC,EAAOC,GAC9B,IAAhBA,IAGAD,EAAQC,EAAclI,KAAKoH,OAC3Bc,EAAclI,KAAKoH,KAAOa,GAE9BjI,KAAKmH,YAAYgB,OAAOF,EAAOC,GAC/BlI,KAAKoH,MAAQc,IAEjBhB,EAAYhH,UAAUkI,aAAe,SAAUC,EAAaC,GACxD,GAAoB,IAAhBA,EAAJ,CAIA,IADA,IAAIjI,EAAa,GACRhB,EAAI,EAAGA,EAAIiJ,EAAajJ,IAC7BgB,EAAWhB,GAAK,KAEpBW,KAAKmH,YAAc,OAAmBnH,KAAKmH,YAAakB,EAAahI,GACrEL,KAAKoH,MAAQkB,IAEjBpB,EAAYhH,UAAUqI,UAAY,SAAU5I,EAAoBwF,EAAWsC,EAAgB7G,GACvF,IAAIX,EAASiH,EAAYM,eAAe7H,EAAoB8H,EAAgB7G,GAC5EZ,KAAK+H,YAAY5C,GACjBnF,KAAKmH,YAAYhC,GAAalF,GAGlCiH,EAAYhH,UAAUsE,WAAa,SAAUF,EAAOpF,EAAUC,GAC1Da,KAAKyE,mBAAmBH,GACxBtE,KAAK0E,kBAAkB,IAAI,OAASJ,EAAM9D,gBAAiB8D,EAAMK,aAAczF,EAAUC,IAE7F+H,EAAYhH,UAAUuE,mBAAqB,SAAUH,GACjD,IAAIO,EAAiBP,EAAM9D,gBAAkB,EAC7C,KAAIqE,GAAkB7E,KAAKoH,MAG3B,GAAI9C,EAAM9D,kBAAoB8D,EAAMd,cAApC,CAQAxD,KAAKmH,YAAYtC,GAAkBqC,EAAYsB,cAAcxI,KAAKmH,YAAYtC,GAAiBP,EAAMK,YAAc,GACnH,IAAIG,EAAgBR,EAAMd,cAAgB,EACtCiF,EAAiB,KACjB3D,EAAgB9E,KAAKoH,OACrBqB,EAAiBvB,EAAYwB,iBAAiB1I,KAAKmH,YAAYrC,GAAgBR,EAAMM,UAAY,IAGrG5E,KAAKmH,YAAYtC,GAAkBqC,EAAYyB,QAAQ3I,KAAKmH,YAAYtC,GAAiB4D,GAEzFzI,KAAKgI,aAAa1D,EAAM9D,gBAAiB8D,EAAMd,cAAgBc,EAAM9D,qBAjBrE,CACI,GAAI8D,EAAMK,cAAgBL,EAAMM,UAE5B,OAEJ5E,KAAKmH,YAAYtC,GAAkBqC,EAAY0B,QAAQ5I,KAAKmH,YAAYtC,GAAiBP,EAAMK,YAAc,EAAGL,EAAMM,UAAY,KAc1IsC,EAAYhH,UAAUwE,kBAAoB,SAAUQ,EAAUhG,EAAUC,GACpE,GAAiB,IAAbD,GAAsC,IAApBC,EAAtB,CAIA,IAAIgG,EAAYD,EAAS9E,WAAa,EAClC+E,GAAanF,KAAKoH,OAGL,IAAblI,GAKJc,KAAKmH,YAAYhC,GAAa+B,EAAYsB,cAAcxI,KAAKmH,YAAYhC,GAAYD,EAASE,OAAS,GACvGpF,KAAKmH,YAAYhC,GAAa+B,EAAY2B,QAAQ7I,KAAKmH,YAAYhC,GAAYD,EAASE,OAAS,EAAGjG,GACpGa,KAAKoI,aAAalD,EAAS9E,WAAYlB,IALnCc,KAAKmH,YAAYhC,GAAa+B,EAAY2B,QAAQ7I,KAAKmH,YAAYhC,GAAYD,EAASE,OAAS,EAAGjG,MAO5G+H,EAAYwB,iBAAmB,SAAUrI,EAAYyI,GACjD,OAAmB,OAAfzI,GAAuBA,IAAeT,EAC/BS,EAEJ6G,EAAY0B,QAAQvI,EAAY,EAAGyI,IAE9C5B,EAAYsB,cAAgB,SAAUnI,EAAY0I,GAC9C,GAAmB,OAAf1I,GAAuBA,IAAeT,EACtC,OAAOS,EAEX,IAAIJ,EAASoF,EAAchF,GACvBoH,EAAiBxH,EAAOA,EAAOV,OAAS,GAC5C,OAAO2H,EAAY0B,QAAQvI,EAAY0I,EAAatB,IAExDP,EAAY0B,QAAU,SAAUvI,EAAY0I,EAAaD,GACrD,GAAmB,OAAfzI,GAAuBA,IAAeT,GAAqBmJ,IAAgBD,EAC3E,OAAOzI,EAEX,IAAIJ,EAASoF,EAAchF,GACvB2I,EAAe/I,EAAOV,SAAW,EAErC,GAAoB,IAAhBwJ,GAAqB9I,EAAOA,EAAOV,OAAS,KAAOuJ,EACnD,OAAOlJ,EAEX,IAWIqJ,EACAC,EAZAC,EAAiB,OAAWC,uBAAuBnJ,EAAQ8I,GAC3DM,EAAwBF,EAAiB,EAAIlJ,EAAQkJ,EAAiB,GAAM,GAAK,EACjFG,EAAqBrJ,EAAOkJ,GAAkB,GAClD,GAAIL,EAAYQ,EAAoB,CAGhC,IADA,IAAIC,EAAWT,EAAYC,EAClB1J,EAAI8J,EAAgB9J,EAAI2J,EAAa3J,IAC1CY,EAAOZ,GAAK,IAAMkK,EAEtB,OAAOlJ,EAIPgJ,IAAyBN,GACzB9I,EAAOkJ,GAAkB,GAAKJ,EAC9BE,EAASE,EAAiB,GAAM,EAChCD,EAAUH,IAGVE,EAAQE,GAAkB,EAC1BD,EAAUG,GAGd,IADA,IAAIG,EAASV,EAAYC,EAChB7H,EAAaiI,EAAiB,EAAGjI,EAAa8H,EAAa9H,IAAc,CAC9E,IAAIuI,EAAiBxJ,EAAOiB,GAAc,GAAKsI,EAC3CC,EAAiBP,IACjBjJ,EAAOgJ,KAAUQ,EACjBxJ,EAAOgJ,KAAUhJ,EAA2B,GAAnBiB,GAAc,IACvCgI,EAAUO,GAGlB,GAAIR,IAAShJ,EAAOV,OAEhB,OAAOc,EAEX,IAAIqJ,EAAM,IAAI7J,YAAYoJ,GAE1B,OADAS,EAAIhE,IAAIzF,EAAO0J,SAAS,EAAGV,GAAO,GAC3BS,EAAI5J,QAEfoH,EAAYyB,QAAU,SAAUtI,EAAYuJ,GACxC,GAAIA,IAAiBhK,EACjB,OAAOS,EAEX,GAAIA,IAAeT,EACf,OAAOgK,EAEX,GAAmB,OAAfvJ,EACA,OAAOA,EAEX,GAAqB,OAAjBuJ,EAEA,OAAO,KAEX,IAAIC,EAAWxE,EAAchF,GACzByJ,EAAczE,EAAcuE,GAC5BG,EAAoBD,EAAYvK,SAAW,EAC3C6G,EAAS,IAAIvG,YAAYgK,EAAStK,OAASuK,EAAYvK,QAC3D6G,EAAOV,IAAImE,EAAU,GAGrB,IAFA,IAAIZ,EAAOY,EAAStK,OAChBiK,EAAQK,EAASA,EAAStK,OAAS,GAC9BF,EAAI,EAAGA,EAAI0K,EAAkB1K,IAClC+G,EAAO6C,KAAUa,EAAazK,GAAK,GAAMmK,EACzCpD,EAAO6C,KAAUa,EAAuB,GAAVzK,GAAK,IAEvC,OAAO+G,EAAOtG,QAElBoH,EAAY2B,QAAU,SAAUxI,EAAY2J,EAASC,GACjD,GAAmB,OAAf5J,GAAuBA,IAAeT,EAEtC,OAAOS,EAEX,IAAIJ,EAASoF,EAAchF,GACvB2I,EAAe/I,EAAOV,SAAW,EACjC4J,EAAiB,OAAWC,uBAAuBnJ,EAAQ+J,GAC/D,GAAIb,EAAiB,EAAG,CACpB,IAAIE,EAAuBpJ,EAAQkJ,EAAiB,GAAM,GACtDE,IAAyBW,GACzBb,IAGR,IAAK,IAAIjI,EAAaiI,EAAgBjI,EAAa8H,EAAa9H,IAC5DjB,EAAOiB,GAAc,IAAM+I,EAE/B,OAAO5J,GAEJ6G,EA3OqB,I,oCCvkBhC,0OASIgD,EAAmB,IACnBC,EAA8B,WAC9B,SAASA,EAAaC,EAAcC,EAASC,EAAWC,GACpDvK,KAAKoK,aAAeA,EACpBpK,KAAKqK,QAAUA,EACfrK,KAAKsK,UAAYA,EACjBtK,KAAKuK,eAAiBA,EAqC1B,OAnCAJ,EAAajK,UAAUsK,mBAAqB,WACxC,GAA0B,KAAtBxK,KAAKoK,aACL,OAAO,KAGX,IAAIK,EAEAA,EADAzK,KAAKqK,QACOK,EAAuB1K,KAAKoK,cAG3BpK,KAAKoK,aAAaO,QAAQ,OAAS,EAEpD,IAAIC,EAAQ,KACZ,IACIA,EAAQ,OAAqB5K,KAAKoK,aAAcpK,KAAKqK,QAAS,CAC1DC,UAAWtK,KAAKsK,UAChBO,WAAW,EACXJ,UAAWA,EACXK,QAAQ,EACRC,SAAS,IAGjB,MAAOC,GACH,OAAO,KAEX,IAAKJ,EACD,OAAO,KAEX,IAAIK,GAAuBjL,KAAKqK,UAAYI,EAK5C,OAJIQ,GAAsBjL,KAAKoK,aAAac,gBAAkBlL,KAAKoK,aAAae,gBAE5EF,EAAqBjL,KAAKsK,WAEvB,IAAIc,EAAWR,EAAO5K,KAAKuK,eAAiB,eAAwBvK,KAAKuK,gBAAkB,KAAMU,EAAqBjL,KAAKoK,aAAe,OAE9ID,EA1CsB,GA6C1B,SAASO,EAAuBN,GACnC,IAAKA,GAAwC,IAAxBA,EAAa7K,OAC9B,OAAO,EAEX,IAAK,IAAIF,EAAI,EAAGC,EAAM8K,EAAa7K,OAAQF,EAAIC,EAAKD,IAAK,CACrD,IAAIgM,EAASjB,EAAa3K,WAAWJ,GACrC,GAAe,KAAXgM,EAA+B,CAG/B,GADAhM,IACIA,GAAKC,EAEL,MAEJ,IAAIgM,EAAalB,EAAa3K,WAAWJ,GACzC,GAAmB,MAAfiM,GAA6C,MAAfA,GAA6C,KAAfA,GAA4C,MAAfA,EACzF,OAAO,GAInB,OAAO,EAEX,IAAIF,EAA4B,WAC5B,SAASA,EAAWR,EAAOL,EAAgBgB,GACvCvL,KAAK4K,MAAQA,EACb5K,KAAKuK,eAAiBA,EACtBvK,KAAKuL,aAAeA,EAExB,OAAOH,EANoB,GASxB,SAASI,EAAgBlH,EAAOmH,EAAYC,GAC/C,IAAKA,EACD,OAAO,IAAI,OAAUpH,EAAO,MAGhC,IADA,IAAIqH,EAAU,GACLtM,EAAI,EAAGC,EAAMmM,EAAWlM,OAAQF,EAAIC,EAAKD,IAC9CsM,EAAQtM,GAAKoM,EAAWpM,GAE5B,OAAO,IAAI,OAAUiF,EAAOqH,GAEhC,IAAIC,EAAiC,WACjC,SAASA,EAAgB3M,GAGrB,IAFA,IAAI4M,EAAmB,GACnBC,EAAsB,EACjBzM,EAAI,EAAG0M,EAAU9M,EAAKM,OAAQF,EAAI0M,EAAS1M,IACrB,KAAvBJ,EAAKQ,WAAWJ,KAChBwM,EAAiBC,KAAyBzM,GAGlDW,KAAKgM,kBAAoBH,EAgC7B,OA9BAD,EAAgB1L,UAAU+L,8BAAgC,SAAUpJ,GAChE,IAAIgJ,EAAmB7L,KAAKgM,kBACxB7H,EAAM,EACNC,EAAMyH,EAAiBtM,OAAS,EACpC,IAAa,IAAT6E,EAEA,OAAO,EAEX,GAAIvB,GAAUgJ,EAAiB,GAE3B,OAAO,EAEX,MAAO1H,EAAMC,EAAK,CACd,IAAIL,EAAMI,IAAQC,EAAMD,GAAO,GAAK,GAChC0H,EAAiB9H,IAAQlB,EACzBuB,EAAML,EAAM,EAGR8H,EAAiB9H,EAAM,IAAMlB,GAE7BsB,EAAMJ,EACNK,EAAML,GAGNI,EAAMJ,EAAM,EAIxB,OAAOI,EAAM,GAEVyH,EAzCyB,GA2ChCM,EAAiC,WACjC,SAASA,KA+NT,OA7NAA,EAAgBC,YAAc,SAAUC,EAAOC,EAAcC,EAAaZ,EAAgBa,GACtF,IAAIC,EAAaH,EAAa7B,qBAC9B,OAAKgC,EAGDA,EAAW5B,MAAMH,UACVzK,KAAKyM,wBAAwBL,EAAOE,EAAa,IAAII,EAASF,EAAWjC,eAAgBiC,EAAW5B,OAAQc,EAAgBa,GAEhIvM,KAAK2M,yBAAyBP,EAAOE,EAAaE,EAAYd,EAAgBa,GAL1E,IAWfL,EAAgBU,wBAA0B,SAAUR,EAAOS,EAAa5N,EAAM6N,EAAWC,EAAYC,GACjG,IAAIC,EASAC,EARAC,EAA2B,EAS/B,GARIL,GACAK,EAA2BL,EAAUb,8BAA8Bc,GACnEE,EAAcJ,EAAcE,EAAaI,GAGzCF,EAAcJ,EAAcE,EAG5BD,EAAW,CACX,IAAIM,EAAgCN,EAAUb,8BAA8Bc,EAAaC,EAAOzN,QAC5F8N,EAAuBD,EAAgCD,EAC3DD,EAAYD,EAAcD,EAAOzN,OAAS8N,OAG1CH,EAAYD,EAAcD,EAAOzN,OAErC,IAAI+N,EAAgBlB,EAAMmB,cAAcN,GACpCO,EAAcpB,EAAMmB,cAAcL,GACtC,OAAO,IAAI,OAAMI,EAAclN,WAAYkN,EAAclI,OAAQoI,EAAYpN,WAAYoN,EAAYpI,SAEzG8G,EAAgBO,wBAA0B,SAAUL,EAAOE,EAAamB,EAAU/B,EAAgBa,GAC9F,IAQImB,EARAb,EAAcT,EAAMuB,YAAYrB,EAAYsB,oBAI5C3O,EAAOmN,EAAMyB,gBAAgBvB,EAAa,GAC1CQ,EAAgC,SAAnBV,EAAM0B,SAAsB,IAAIlC,EAAgB3M,GAAQ,KACrEmH,EAAS,GACT2H,EAAU,EAEdN,EAASO,MAAM,GACf,MAAQN,EAAID,EAASQ,KAAKhP,GAEtB,GADAmH,EAAO2H,KAAavC,EAAgBxL,KAAK4M,wBAAwBR,EAAOS,EAAa5N,EAAM6N,EAAWY,EAAEQ,MAAOR,EAAE,IAAKA,EAAGhC,GACrHqC,GAAWxB,EACX,OAAOnG,EAGf,OAAOA,GAEX8F,EAAgBS,yBAA2B,SAAUP,EAAOE,EAAaE,EAAYd,EAAgBa,GACjG,IAAInG,EAAS,GACTC,EAAY,EAEhB,GAAIiG,EAAY9L,kBAAoB8L,EAAY9I,cAAe,CAC3D,IAAI2K,EAAS/B,EAAMrF,eAAeuF,EAAY9L,iBAAiB4N,UAAU9B,EAAY3H,YAAc,EAAG2H,EAAY1H,UAAY,GAE9H,OADAyB,EAAYrG,KAAKqO,mBAAmB7B,EAAY2B,EAAQ7B,EAAY9L,gBAAiB8L,EAAY3H,YAAc,EAAG0B,EAAWD,EAAQsF,EAAgBa,GAC9InG,EAGX,IAAInH,EAAOmN,EAAMrF,eAAeuF,EAAY9L,iBAAiB4N,UAAU9B,EAAY3H,YAAc,GACjG0B,EAAYrG,KAAKqO,mBAAmB7B,EAAYvN,EAAMqN,EAAY9L,gBAAiB8L,EAAY3H,YAAc,EAAG0B,EAAWD,EAAQsF,EAAgBa,GAEnJ,IAAK,IAAInM,EAAakM,EAAY9L,gBAAkB,EAAGJ,EAAakM,EAAY9I,eAAiB6C,EAAYkG,EAAkBnM,IAC3HiG,EAAYrG,KAAKqO,mBAAmB7B,EAAYJ,EAAMrF,eAAe3G,GAAaA,EAAY,EAAGiG,EAAWD,EAAQsF,EAAgBa,GAGxI,GAAIlG,EAAYkG,EAAkB,CAC9B,IAAI+B,EAASlC,EAAMrF,eAAeuF,EAAY9I,eAAe4K,UAAU,EAAG9B,EAAY1H,UAAY,GAClGyB,EAAYrG,KAAKqO,mBAAmB7B,EAAY8B,EAAQhC,EAAY9I,cAAe,EAAG6C,EAAWD,EAAQsF,EAAgBa,GAE7H,OAAOnG,GAEX8F,EAAgBmC,mBAAqB,SAAU7B,EAAYvN,EAAMmB,EAAYyM,EAAaxG,EAAWD,EAAQsF,EAAgBa,GACzH,IAAIhC,EAAiBiC,EAAWjC,eAChC,IAAKmB,GAAkBc,EAAWjB,aAAc,CAC5C,IAAInB,EAAeoC,EAAWjB,aAC1BgD,EAAkBnE,EAAa7K,OAC/B0K,EAAahL,EAAKM,OAClBiP,GAAkBD,EACtB,OAA4F,KAApFC,EAAiBvP,EAAK0L,QAAQP,EAAcoE,EAAiBD,IACjE,KAAKhE,GAAkBkE,EAAalE,EAAgBtL,EAAMgL,EAAYuE,EAAgBD,MAClFnI,EAAOC,KAAe,IAAI,OAAU,IAAI,OAAMjG,EAAYoO,EAAiB,EAAI3B,EAAazM,EAAYoO,EAAiB,EAAID,EAAkB1B,GAAc,MACzJxG,GAAakG,GACb,OAAOlG,EAInB,OAAOA,EAEX,IACIqH,EADAD,EAAW,IAAIf,EAASF,EAAWjC,eAAgBiC,EAAW5B,OAGlE6C,EAASO,MAAM,GACf,GAEI,GADAN,EAAID,EAASQ,KAAKhP,GACdyO,IACAtH,EAAOC,KAAemF,EAAgB,IAAI,OAAMpL,EAAYsN,EAAEQ,MAAQ,EAAIrB,EAAazM,EAAYsN,EAAEQ,MAAQ,EAAIR,EAAE,GAAGnO,OAASsN,GAAca,EAAGhC,GAC5IrF,GAAakG,GACb,OAAOlG,QAGVqH,GACT,OAAOrH,GAEX6F,EAAgBwC,cAAgB,SAAUtC,EAAOC,EAAcsC,EAAajD,GACxE,IAAIc,EAAaH,EAAa7B,qBAC9B,IAAKgC,EACD,OAAO,KAEX,IAAIiB,EAAW,IAAIf,EAASF,EAAWjC,eAAgBiC,EAAW5B,OAClE,OAAI4B,EAAW5B,MAAMH,UACVzK,KAAK4O,0BAA0BxC,EAAOuC,EAAalB,EAAU/B,GAEjE1L,KAAK6O,2BAA2BzC,EAAOuC,EAAalB,EAAU/B,IAEzEQ,EAAgB0C,0BAA4B,SAAUxC,EAAOuC,EAAalB,EAAU/B,GAChF,IAAIoD,EAAkB,IAAI,OAASH,EAAYvO,WAAY,GACvDyM,EAAcT,EAAMuB,YAAYmB,GAChCC,EAAY3C,EAAM4C,eAIlB/P,EAAOmN,EAAMyB,gBAAgB,IAAI,OAAMiB,EAAgB1O,WAAY0O,EAAgB1J,OAAQ2J,EAAW3C,EAAM6C,iBAAiBF,IAAa,GAC1IjC,EAAgC,SAAnBV,EAAM0B,SAAsB,IAAIlC,EAAgB3M,GAAQ,KACzEwO,EAASO,MAAMW,EAAYvJ,OAAS,GACpC,IAAIsI,EAAID,EAASQ,KAAKhP,GACtB,OAAIyO,EACOlC,EAAgBxL,KAAK4M,wBAAwBR,EAAOS,EAAa5N,EAAM6N,EAAWY,EAAEQ,MAAOR,EAAE,IAAKA,EAAGhC,GAEjF,IAA3BiD,EAAYvO,YAA2C,IAAvBuO,EAAYvJ,OAErCpF,KAAK4O,0BAA0BxC,EAAO,IAAI,OAAS,EAAG,GAAIqB,EAAU/B,GAExE,MAEXQ,EAAgB2C,2BAA6B,SAAUzC,EAAOuC,EAAalB,EAAU/B,GACjF,IAAIqD,EAAY3C,EAAM4C,eAClBxO,EAAkBmO,EAAYvO,WAE9BnB,EAAOmN,EAAMrF,eAAevG,GAC5B0O,EAAIlP,KAAKmP,sBAAsB1B,EAAUxO,EAAMuB,EAAiBmO,EAAYvJ,OAAQsG,GACxF,GAAIwD,EACA,OAAOA,EAEX,IAAK,IAAI7P,EAAI,EAAGA,GAAK0P,EAAW1P,IAAK,CACjC,IAAI8F,GAAa3E,EAAkBnB,EAAI,GAAK0P,EACxCK,EAAShD,EAAMrF,eAAe5B,EAAY,GAC1CkK,EAAMrP,KAAKmP,sBAAsB1B,EAAU2B,EAAQjK,EAAY,EAAG,EAAGuG,GACzE,GAAI2D,EACA,OAAOA,EAGf,OAAO,MAEXnD,EAAgBiD,sBAAwB,SAAU1B,EAAUxO,EAAMmB,EAAYkP,EAAY5D,GAEtF+B,EAASO,MAAMsB,EAAa,GAC5B,IAAI5B,EAAID,EAASQ,KAAKhP,GACtB,OAAIyO,EACOlC,EAAgB,IAAI,OAAMpL,EAAYsN,EAAEQ,MAAQ,EAAG9N,EAAYsN,EAAEQ,MAAQ,EAAIR,EAAE,GAAGnO,QAASmO,EAAGhC,GAElG,MAEXQ,EAAgBqD,kBAAoB,SAAUnD,EAAOC,EAAcsC,EAAajD,GAC5E,IAAIc,EAAaH,EAAa7B,qBAC9B,IAAKgC,EACD,OAAO,KAEX,IAAIiB,EAAW,IAAIf,EAASF,EAAWjC,eAAgBiC,EAAW5B,OAClE,OAAI4B,EAAW5B,MAAMH,UACVzK,KAAKwP,8BAA8BpD,EAAOuC,EAAalB,EAAU/B,GAErE1L,KAAKyP,+BAA+BrD,EAAOuC,EAAalB,EAAU/B,IAE7EQ,EAAgBsD,8BAAgC,SAAUpD,EAAOuC,EAAalB,EAAU/B,GACpF,IAAIC,EAAU3L,KAAKyM,wBAAwBL,EAAO,IAAI,OAAM,EAAG,EAAGuC,EAAYvO,WAAYuO,EAAYvJ,QAASqI,EAAU/B,EAAgB,GAAKxB,GAC9I,GAAIyB,EAAQpM,OAAS,EACjB,OAAOoM,EAAQA,EAAQpM,OAAS,GAEpC,IAAIwP,EAAY3C,EAAM4C,eACtB,OAAIL,EAAYvO,aAAe2O,GAAaJ,EAAYvJ,SAAWgH,EAAM6C,iBAAiBF,GAE/E/O,KAAKwP,8BAA8BpD,EAAO,IAAI,OAAS2C,EAAW3C,EAAM6C,iBAAiBF,IAAatB,EAAU/B,GAEpH,MAEXQ,EAAgBuD,+BAAiC,SAAUrD,EAAOuC,EAAalB,EAAU/B,GACrF,IAAIqD,EAAY3C,EAAM4C,eAClBxO,EAAkBmO,EAAYvO,WAE9BnB,EAAOmN,EAAMrF,eAAevG,GAAiB4N,UAAU,EAAGO,EAAYvJ,OAAS,GAC/E8J,EAAIlP,KAAK0P,qBAAqBjC,EAAUxO,EAAMuB,EAAiBkL,GACnE,GAAIwD,EACA,OAAOA,EAEX,IAAK,IAAI7P,EAAI,EAAGA,GAAK0P,EAAW1P,IAAK,CACjC,IAAI8F,GAAa4J,EAAYvO,EAAkBnB,EAAI,GAAK0P,EACpDY,EAASvD,EAAMrF,eAAe5B,EAAY,GAC1CyK,EAAM5P,KAAK0P,qBAAqBjC,EAAUkC,EAAQxK,EAAY,EAAGuG,GACrE,GAAIkE,EACA,OAAOA,EAGf,OAAO,MAEX1D,EAAgBwD,qBAAuB,SAAUjC,EAAUxO,EAAMmB,EAAYsL,GACzE,IACIgC,EADAmC,EAAa,KAEjBpC,EAASO,MAAM,GACf,MAAQN,EAAID,EAASQ,KAAKhP,GACtB4Q,EAAarE,EAAgB,IAAI,OAAMpL,EAAYsN,EAAEQ,MAAQ,EAAG9N,EAAYsN,EAAEQ,MAAQ,EAAIR,EAAE,GAAGnO,QAASmO,EAAGhC,GAE/G,OAAOmE,GAEJ3D,EAhOyB,GAmOpC,SAAS4D,EAAkBvF,EAAgBtL,EAAMgL,EAAY8F,EAAiBC,GAC1E,GAAwB,IAApBD,EAEA,OAAO,EAEX,IAAIE,EAAahR,EAAKQ,WAAWsQ,EAAkB,GACnD,GAAuC,IAAnCxF,EAAe2F,IAAID,GAEnB,OAAO,EAEX,GAAmB,KAAfA,GAAyD,KAAfA,EAE1C,OAAO,EAEX,GAAID,EAAc,EAAG,CACjB,IAAIG,EAAmBlR,EAAKQ,WAAWsQ,GACvC,GAA6C,IAAzCxF,EAAe2F,IAAIC,GAEnB,OAAO,EAGf,OAAO,EAEX,SAASC,EAAmB7F,EAAgBtL,EAAMgL,EAAY8F,EAAiBC,GAC3E,GAAID,EAAkBC,IAAgB/F,EAElC,OAAO,EAEX,IAAIoG,EAAYpR,EAAKQ,WAAWsQ,EAAkBC,GAClD,GAAsC,IAAlCzF,EAAe2F,IAAIG,GAEnB,OAAO,EAEX,GAAkB,KAAdA,GAAuD,KAAdA,EAEzC,OAAO,EAEX,GAAIL,EAAc,EAAG,CACjB,IAAIM,EAAkBrR,EAAKQ,WAAWsQ,EAAkBC,EAAc,GACtE,GAA4C,IAAxCzF,EAAe2F,IAAII,GAEnB,OAAO,EAGf,OAAO,EAEJ,SAAS7B,EAAalE,EAAgBtL,EAAMgL,EAAY8F,EAAiBC,GAC5E,OAAQF,EAAkBvF,EAAgBtL,EAAMgL,EAAY8F,EAAiBC,IACtEI,EAAmB7F,EAAgBtL,EAAMgL,EAAY8F,EAAiBC,GAEjF,IAAItD,EAA0B,WAC1B,SAASA,EAASnC,EAAgBgG,GAC9BvQ,KAAKwQ,gBAAkBjG,EACvBvK,KAAKyQ,aAAeF,EACpBvQ,KAAK0Q,sBAAwB,EAC7B1Q,KAAK2Q,iBAAmB,EAuC5B,OArCAjE,EAASxM,UAAU8N,MAAQ,SAAU4C,GACjC5Q,KAAKyQ,aAAaG,UAAYA,EAC9B5Q,KAAK0Q,sBAAwB,EAC7B1Q,KAAK2Q,iBAAmB,GAE5BjE,EAASxM,UAAU+N,KAAO,SAAUhP,GAChC,IACIyO,EADAzD,EAAahL,EAAKM,OAEtB,EAAG,CACC,GAAIS,KAAK0Q,qBAAuB1Q,KAAK2Q,mBAAqB1G,EAEtD,OAAO,KAGX,GADAyD,EAAI1N,KAAKyQ,aAAaI,KAAK5R,IACtByO,EACD,OAAO,KAEX,IAAIqC,EAAkBrC,EAAEQ,MACpB8B,EAActC,EAAE,GAAGnO,OACvB,GAAIwQ,IAAoB/P,KAAK0Q,sBAAwBV,IAAgBhQ,KAAK2Q,iBAAkB,CACxF,GAAoB,IAAhBX,EAAmB,CAGnBhQ,KAAKyQ,aAAaG,WAAa,EAC/B,SAGJ,OAAO,KAIX,GAFA5Q,KAAK0Q,qBAAuBX,EAC5B/P,KAAK2Q,iBAAmBX,GACnBhQ,KAAKwQ,iBAAmB/B,EAAazO,KAAKwQ,gBAAiBvR,EAAMgL,EAAY8F,EAAiBC,GAC/F,OAAOtC,QAENA,GACT,OAAO,MAEJhB,EA5CkB,I,mRCvZzBoE,EAA+B,WAC/B,SAASA,IACL9Q,KAAK+Q,WAAa,EAEtB,OAAOD,EAJuB,GAW9BE,EAAqC,WACrC,SAASA,EAAoB5Q,EAAY6Q,GACrCjR,KAAK+Q,WAAa,EAClB/Q,KAAKI,WAAaA,EAClBJ,KAAKiR,OAASA,EAElB,OAAOD,EAN6B,GAapCE,EAAsC,WACtC,SAASA,EAAqBC,EAAgBC,GAC1CpR,KAAK+Q,WAAa,EAClB/Q,KAAKmR,eAAiBA,EACtBnR,KAAKoR,aAAeA,EAExB,OAAOF,EAN8B,GAarCG,EAAuC,WACvC,SAASA,EAAsBF,EAAgBC,EAAcH,GACzDjR,KAAK+Q,WAAa,EAClB/Q,KAAKmR,eAAiBA,EACtBnR,KAAKoR,aAAeA,EACpBpR,KAAKiR,OAASA,EAElB,OAAOI,EAP+B,GActCC,EAAoC,WACpC,SAASA,IACLtR,KAAK+Q,WAAa,EAEtB,OAAOO,EAJ4B,GAWnCC,EAA6C,WAC7C,SAASA,EAA4BC,EAASC,EAAWC,EAAWC,GAChE3R,KAAKwR,QAAUA,EACfxR,KAAKyR,UAAYA,EACjBzR,KAAK0R,UAAYA,EACjB1R,KAAK2R,UAAYA,EAkBrB,OAhBAJ,EAA4BrR,UAAU0R,cAAgB,SAAUC,GAC5D,IAAK,IAAIxS,EAAI,EAAGC,EAAMU,KAAKwR,QAAQjS,OAAQF,EAAIC,EAAKD,IAAK,CACrD,IAAIyS,EAAS9R,KAAKwR,QAAQnS,GAC1B,GAAIyS,EAAOf,aAAec,EACtB,OAAO,EAGf,OAAO,GAEXN,EAA4BQ,MAAQ,SAAUC,EAAGC,GAC7C,IAAIT,EAAU,GAAGU,OAAOF,EAAER,SAASU,OAAOD,EAAET,SACxCC,EAAYQ,EAAER,UACdC,EAAaM,EAAEN,WAAaO,EAAEP,UAC9BC,EAAaK,EAAEL,WAAaM,EAAEN,UAClC,OAAO,IAAIJ,EAA4BC,EAASC,EAAWC,EAAWC,IAEnEJ,EAvBqC,GA6B5CY,EAAiD,WACjD,SAASA,EAAgCC,EAAwBC,GAC7DrS,KAAKoS,uBAAyBA,EAC9BpS,KAAKqS,oBAAsBA,EAuB/B,OArBAF,EAAgCjS,UAAU6R,MAAQ,SAAUO,GACxD,IAAIF,EAAyBb,EAA4BQ,MAAM/R,KAAKoS,uBAAwBE,EAAMF,wBAC9FC,EAAsBF,EAAgCI,mBAAmBvS,KAAKqS,oBAAqBC,EAAMD,qBAC7G,OAAO,IAAIF,EAAgCC,EAAwBC,IAEvEF,EAAgCI,mBAAqB,SAAUP,EAAGC,GAC9D,IAAIT,EAAU,GAAGU,OAAOF,EAAER,SAASU,OAAOD,EAAET,SACxCgB,EAAMP,EAAEO,IACRf,EAAYQ,EAAER,UACdC,EAAaM,EAAEN,WAAaO,EAAEP,UAC9BC,EAAaK,EAAEL,WAAaM,EAAEN,UAC9Bc,EAAWT,EAAES,SAAWR,EAAEQ,QAC9B,MAAO,CACHjB,QAASA,EACTgB,IAAKA,EACLf,UAAWA,EACXC,UAAWA,EACXC,UAAWA,EACXc,QAASA,IAGVN,EA1ByC,G,gGC/FhDO,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGX,GAI7B,OAHAU,EAAgBE,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUJ,EAAGX,GAAKW,EAAEG,UAAYd,IACvE,SAAUW,EAAGX,GAAK,IAAK,IAAIgB,KAAKhB,EAAOA,EAAEiB,eAAeD,KAAIL,EAAEK,GAAKhB,EAAEgB,KAClEN,EAAcC,EAAGX,IAE5B,OAAO,SAAUW,EAAGX,GAEhB,SAASkB,IAAOnT,KAAKoT,YAAcR,EADnCD,EAAcC,EAAGX,GAEjBW,EAAE1S,UAAkB,OAAN+R,EAAaY,OAAOQ,OAAOpB,IAAMkB,EAAGjT,UAAY+R,EAAE/R,UAAW,IAAIiT,IAV3C,GAuBxC,EAAwC,WACxC,SAASG,IACLtT,KAAKuT,YAAc,GACnBvT,KAAKwT,OAAS,GACdxT,KAAKoH,KAAO,EACZpH,KAAKyT,uBAAyB,EAqIlC,OAnIAH,EAAuBpT,UAAUwT,OAAS,SAAUC,GAChD3T,KAAKuT,YAAc,GACnBvT,KAAKwT,OAAS,GACdxT,KAAKoH,KAAO,EACZpH,KAAKyT,uBAAyB,EAC1BE,GACA3T,KAAK4T,eAAe,EAAGD,IAG/BL,EAAuBpT,UAAUuF,MAAQ,SAAUkO,GAC/C3T,KAAK0T,OAAOC,IAEhBd,OAAOgB,eAAeP,EAAuBpT,UAAW,wBAAyB,CAC7EgQ,IAAK,WACD,OAAOlQ,KAAKyT,wBAEhBK,YAAY,EACZC,cAAc,IAElBT,EAAuBpT,UAAU8T,gBAAkB,SAAU7O,GACrDA,EAAYnF,KAAKoH,OACjBpH,KAAKwT,OAAOrO,IAAa,GAEzBA,EAAYnF,KAAKyT,yBACjBzT,KAAKyT,uBAAyBtO,IAGtCmO,EAAuBpT,UAAU+T,SAAW,SAAU9O,GAClD,OAAIA,EAAYnF,KAAKoH,MACVpH,KAAKwT,OAAOrO,IAI3BmO,EAAuBpT,UAAUgU,cAAgB,SAAU/O,GACvD,OAAIA,EAAYnF,KAAKoH,KACVpH,KAAKuT,YAAYpO,GAErB,MAEXmO,EAAuBpT,UAAU6H,YAAc,SAAU5C,GACrD,MAAOA,GAAanF,KAAKoH,KACrBpH,KAAKuT,YAAYvT,KAAKoH,MAAQ,KAC9BpH,KAAKwT,OAAOxT,KAAKoH,OAAQ,EACzBpH,KAAKoH,QAGbkM,EAAuBpT,UAAU8H,aAAe,SAAUC,EAAOC,GACzC,IAAhBA,IAGAD,EAAQC,EAAclI,KAAKoH,OAC3Bc,EAAclI,KAAKoH,KAAOa,GAE9BjI,KAAKuT,YAAYpL,OAAOF,EAAOC,GAC/BlI,KAAKwT,OAAOrL,OAAOF,EAAOC,GAC1BlI,KAAKoH,MAAQc,IAEjBoL,EAAuBpT,UAAUkI,aAAe,SAAUC,EAAaC,GACnE,GAAoB,IAAhBA,EAAJ,CAKA,IAFA,IAAI6L,EAAa,GACbC,EAAQ,GACH/U,EAAI,EAAGA,EAAIiJ,EAAajJ,IAC7B8U,EAAW9U,GAAK,KAChB+U,EAAM/U,IAAK,EAEfW,KAAKuT,YAAcc,EAAA,KAAmBrU,KAAKuT,YAAalL,EAAa8L,GACrEnU,KAAKwT,OAASa,EAAA,KAAmBrU,KAAKwT,OAAQnL,EAAa+L,GAC3DpU,KAAKoH,MAAQkB,IAEjBgL,EAAuBpT,UAAUoU,UAAY,SAAUnP,EAAWiP,GAC9DpU,KAAK+H,YAAY5C,GACjBnF,KAAKwT,OAAOrO,GAAaiP,GAE7Bd,EAAuBpT,UAAU0T,eAAiB,SAAUzO,EAAWgP,GACnEnU,KAAK+H,YAAY5C,GACjBnF,KAAKuT,YAAYpO,GAAagP,GAElCb,EAAuBpT,UAAUqU,YAAc,SAAUC,EAAarP,EAAWsP,GAI7E,GAHAzU,KAAKsU,UAAUnP,GAAW,GAC1BnF,KAAKyT,uBAAyBtO,EAAY,EAEtCA,IAAcqP,EAAc,EAAhC,CAIA,IAAIE,EAAmB1U,KAAKkU,cAAc/O,EAAY,GACtD,GAAyB,OAArBuP,IAA8BD,EAASE,OAAOD,GAG9C,OAFA1U,KAAK4T,eAAezO,EAAY,EAAGsP,QACnCzU,KAAKgU,gBAAgB7O,EAAY,GAIrC,IAAI9F,EAAI8F,EAAY,EACpB,MAAO9F,EAAImV,EAAa,CACpB,IAAKxU,KAAKiU,SAAS5U,GACf,MAEJA,IAEJW,KAAKyT,uBAAyBpU,IAElCiU,EAAuBpT,UAAU0U,cAAgB,SAAUzP,GACvDnF,KAAKsU,UAAUnP,GAAW,IAG9BmO,EAAuBpT,UAAU2U,WAAa,SAAUvQ,EAAOpF,GAI3D,IAHA,IAAI4V,EAAmBxQ,EAAMd,cAAgBc,EAAM9D,gBAC/CuU,EAAoB7V,EACpB8V,EAAkBhR,KAAKG,IAAI2Q,EAAkBC,GACxCE,EAAID,EAAiBC,GAAK,EAAGA,IAClCjV,KAAKgU,gBAAgB1P,EAAM9D,gBAAkByU,EAAI,GAErDjV,KAAKyE,mBAAmBH,GACxBtE,KAAK0E,kBAAkB,IAAI,OAASJ,EAAM9D,gBAAiB8D,EAAMK,aAAczF,IAEnFoU,EAAuBpT,UAAUuE,mBAAqB,SAAUH,GAC5D,IAAIO,EAAiBP,EAAM9D,gBAAkB,EACzCqE,GAAkB7E,KAAKoH,MAG3BpH,KAAKgI,aAAa1D,EAAM9D,gBAAiB8D,EAAMd,cAAgBc,EAAM9D,kBAEzE8S,EAAuBpT,UAAUwE,kBAAoB,SAAUQ,EAAUhG,GACrE,IAAIiG,EAAYD,EAAS9E,WAAa,EAClC+E,GAAanF,KAAKoH,MAGtBpH,KAAKoI,aAAalD,EAAS9E,WAAYlB,IAEpCoU,EA1IgC,GA6IvC,EAAuC,SAAU4B,GAEjD,SAASC,EAAsBC,GAC3B,IAAIC,EAAQH,EAAOI,KAAKtV,OAASA,KAmCjC,OAlCAqV,EAAME,aAAc,EACpBF,EAAMG,WAAaJ,EACnBC,EAAMI,wBAA0B,IAAI,EACpCJ,EAAMK,qBAAuB,KAC7BL,EAAMM,UAAU,OAAqBC,aAAY,SAAUC,GACvD,IAAIC,EAAqBT,EAAMG,WAAWO,yBACuB,IAA7DF,EAAEG,iBAAiBrL,QAAQmL,EAAmBG,YAGlDZ,EAAMa,0BACNb,EAAMG,WAAWW,mBAErBd,EAAMM,UAAUN,EAAMG,WAAWY,2BAA0B,SAAUP,GAC7DA,EAAEjE,cAAc,IAChByD,EAAMa,8BAIdb,EAAMM,UAAUN,EAAMG,WAAWa,wBAAuB,SAAUR,GAC9D,IAAK,IAAIxW,EAAI,EAAGC,EAAMuW,EAAErE,QAAQjS,OAAQF,EAAIC,EAAKD,IAAK,CAClD,IAAIyS,EAAS+D,EAAErE,QAAQnS,GACnBH,EAAW,eAAS4S,EAAO7S,MAAM,GACrCoW,EAAMI,wBAAwBZ,WAAW/C,EAAOxN,MAAOpF,GAE3DmW,EAAMiB,mCAEVjB,EAAMM,UAAUN,EAAMG,WAAWe,qBAAoB,WACjDlB,EAAMiB,mCAEVjB,EAAMM,UAAUN,EAAMG,WAAWgB,qBAAoB,WACjDnB,EAAMa,0BACNb,EAAMG,WAAWW,kBAErBd,EAAMa,0BACCb,EAuJX,OA5LA3C,EAAUyC,EAAuBD,GAuCjCC,EAAsBjV,UAAUuW,QAAU,WACtCzW,KAAKuV,aAAc,EACnBL,EAAOhV,UAAUuW,QAAQnB,KAAKtV,OAElCmV,EAAsBjV,UAAUgW,wBAA0B,WACtD,IAAI3R,EAAKmS,EAAuB1W,KAAKwV,YAAamB,EAAsBpS,EAAG,GAAIoP,EAAepP,EAAG,GACjGvE,KAAK0V,qBAAuBiB,EAC5B3W,KAAKyV,wBAAwBhQ,MAAMkO,GACnC3T,KAAKsW,gCAETnB,EAAsBjV,UAAUoW,6BAA+B,WAC3D,IAAIjB,EAAQrV,KACRA,KAAKwV,WAAWoB,sBAAwB5W,KAAK6W,uBAC7CC,EAAA,MAAsB,WACdzB,EAAME,aAIVF,EAAM0B,2BAIlB5B,EAAsBjV,UAAU6W,qBAAuB,SAAU3F,QACxC,IAAjBA,IAA2BA,EAAepR,KAAKwV,WAAWxG,gBAC9D,IAAIgI,EAAmB,EACnBC,EAAU,IAAI,OACdC,EAAK,OAAU7D,QAAO,GAC1B,MAAOrT,KAAK6W,sBAAuB,CAC/B,GAAIK,EAAGC,UAAYH,EAEf,MAEJ,IAAII,EAAsBpX,KAAKqX,wBAAwBJ,GACvD,GAAIG,GAAuBhG,EACvB,MAGRpR,KAAKsW,+BACLtW,KAAKwV,WAAWjN,UAAU0O,EAAQhX,SAEtCkV,EAAsBjV,UAAUoX,iBAAmB,SAAU9W,EAAiBgD,GAC1E,IAAIyT,EAAU,IAAI,OAClBjX,KAAKuX,kBAAkBN,EAASzW,EAAiBgD,GACjDxD,KAAKwV,WAAWjN,UAAU0O,EAAQhX,SAEtCkV,EAAsBjV,UAAU8N,MAAQ,WACpChO,KAAKkW,0BACLlW,KAAKwV,WAAWW,eAEpBhB,EAAsBjV,UAAUsX,kBAAoB,SAAUpX,GAC1D,IAAI6W,EAAU,IAAI,OAClBjX,KAAKyX,uBAAuBR,EAAS7W,GACrCJ,KAAKwV,WAAWjN,UAAU0O,EAAQhX,SAEtCkV,EAAsBjV,UAAUwX,kBAAoB,SAAUtX,GAC1D,IAAKJ,KAAK0V,qBACN,OAAO,EAEX,IAAIiC,EAAyB3X,KAAKyV,wBAAwBmC,sBAAwB,EAClF,QAAIxX,EAAauX,KAGbvX,EAAauX,GAGb3X,KAAKwV,WAAWqC,cAAczX,GAAc,OAKpD+U,EAAsBjV,UAAU2W,oBAAsB,WAClD,QAAK7W,KAAK0V,sBAGF1V,KAAKyV,wBAAwBmC,sBAAwB5X,KAAKwV,WAAWxG,gBAEjFmG,EAAsBjV,UAAUmX,wBAA0B,SAAUJ,GAChE,IAAKjX,KAAK6W,sBACN,OAAO7W,KAAKwV,WAAWxG,eAAiB,EAE5C,IAAI5O,EAAaJ,KAAKyV,wBAAwBmC,sBAAwB,EAEtE,OADA5X,KAAKyX,uBAAuBR,EAAS7W,GAC9BA,GAEX+U,EAAsBjV,UAAUuX,uBAAyB,SAAUR,EAAS7W,GACxE,GAAKJ,KAAK0V,qBAOV,IAJA,IAAII,EAAqB9V,KAAKwV,WAAWO,wBACrCvB,EAAcxU,KAAKwV,WAAWxG,eAC9B8I,EAAe1X,EAAa,EAEvB+E,EAAYnF,KAAKyV,wBAAwBmC,sBAAuBzS,GAAa2S,EAAc3S,IAAa,CAC7G,IAAIlG,EAAOe,KAAKwV,WAAWzO,eAAe5B,EAAY,GAClD4S,EAAiB/X,KAAKyV,wBAAwBvB,cAAc/O,GAC5D+J,EAAI8I,EAAalC,EAAoB9V,KAAK0V,qBAAsBzW,EAAM8Y,GAC1Ed,EAAQ9W,IAAIgF,EAAY,EAAG+J,EAAEjP,QAC7BD,KAAKyV,wBAAwBlB,YAAYC,EAAarP,EAAW+J,EAAEuF,UACnEtP,EAAYnF,KAAKyV,wBAAwBmC,sBAAwB,IAGzEzC,EAAsBjV,UAAUqX,kBAAoB,SAAUN,EAASzW,EAAiBgD,GACpF,GAAKxD,KAAK0V,wBAINlS,GAAiBxD,KAAKyV,wBAAwBmC,uBAIlD,GAAIpX,GAAmBR,KAAKyV,wBAAwBmC,sBAEhD5X,KAAKyX,uBAAuBR,EAASzT,OAFzC,CAQA,IAHA,IAAIyU,EAAsBjY,KAAKwV,WAAW0C,gCAAgC1X,GACtE2X,EAAY,GACZxE,EAAe,KACVtU,EAAImB,EAAkB,EAAGyX,EAAsB,GAAK5Y,GAAK,EAAGA,IAAK,CACtE,IAAI+Y,EAAwBpY,KAAKwV,WAAW0C,gCAAgC7Y,GAC5E,GAA8B,IAA1B+Y,GAGAA,EAAwBH,EAAqB,CAE7C,GADAtE,EAAe3T,KAAKyV,wBAAwBvB,cAAc7U,EAAI,GAC1DsU,EACA,MAEJwE,EAAU1X,KAAKT,KAAKwV,WAAWzO,eAAe1H,IAC9C4Y,EAAsBG,GAGzBzE,IACDA,EAAe3T,KAAK0V,qBAAqB2C,mBAE7C,IAAIvC,EAAqB9V,KAAKwV,WAAWO,wBACrCuC,EAAQ3E,EACZ,IAAStU,EAAI8Y,EAAU5Y,OAAS,EAAGF,GAAK,EAAGA,IAAK,CAC5C,IAAI6P,EAAI8I,EAAalC,EAAoB9V,KAAK0V,qBAAsByC,EAAU9Y,GAAIiZ,GAClFA,EAAQpJ,EAAEuF,SAEd,IAAK,IAAIrU,EAAaI,EAAiBJ,GAAcoD,EAAepD,IAAc,CAC9E,IAAInB,EAAOe,KAAKwV,WAAWzO,eAAe3G,GACtC8O,EAAI8I,EAAalC,EAAoB9V,KAAK0V,qBAAsBzW,EAAMqZ,GAC1ErB,EAAQ9W,IAAIC,EAAY8O,EAAEjP,QAC1BD,KAAKyV,wBAAwBb,cAAcxU,EAAa,GACxDkY,EAAQpJ,EAAEuF,YAGXU,EA7L+B,CA8LxC,QAEF,SAASuB,EAAuBtB,GAC5B,IAAIU,EAAqBV,EAAUW,wBAC/BY,EAAuBvB,EAAUmD,4BAC/B,KACA,OAAqBrI,IAAI4F,EAAmBG,UAC9CtC,EAAe,KACnB,GAAIgD,EACA,IACIhD,EAAegD,EAAoB0B,kBAEvC,MAAOxC,GACH,eAAkBA,GAClBc,EAAsB,KAG9B,MAAO,CAACA,EAAqBhD,GAEjC,SAASqE,EAAalC,EAAoBa,EAAqB1X,EAAMqZ,GACjE,IAAIpJ,EAAI,KACR,GAAIyH,EACA,IACIzH,EAAIyH,EAAoB6B,UAAUvZ,EAAMqZ,EAAMG,QAAS,GAE3D,MAAO5C,GACH,eAAkBA,GAO1B,OAJK3G,IACDA,EAAI,eAAc4G,EAAmB4C,GAAIzZ,EAAMqZ,EAAO,IAE1D,OAAWK,mBAAmBzJ,EAAEjP,OAAQhB,EAAKM,QACtC2P,E,4ECnYP,EAAwC,WACxC,IAAIyD,EAAgB,SAAUC,EAAGX,GAI7B,OAHAU,EAAgBE,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUJ,EAAGX,GAAKW,EAAEG,UAAYd,IACvE,SAAUW,EAAGX,GAAK,IAAK,IAAIgB,KAAKhB,EAAOA,EAAEiB,eAAeD,KAAIL,EAAEK,GAAKhB,EAAEgB,KAClEN,EAAcC,EAAGX,IAE5B,OAAO,SAAUW,EAAGX,GAEhB,SAASkB,IAAOnT,KAAKoT,YAAcR,EADnCD,EAAcC,EAAGX,GAEjBW,EAAE1S,UAAkB,OAAN+R,EAAaY,OAAOQ,OAAOpB,IAAMkB,EAAGjT,UAAY+R,EAAE/R,UAAW,IAAIiT,IAV3C,GAsC5C,SAASyF,IACL,OAAO,IAAI,OAER,SAASC,EAAwB5Z,GACpC,IAAIgY,EAAU2B,IAEd,OADA3B,EAAQ6B,YAAY7Z,GACbgY,EAAQ8B,SAEZ,SAASC,EAAiBC,EAAOC,GACpC,IAAIC,EAA4B,kBAAVF,EAAqBJ,EAAwBI,GAASA,EAC5E,OAAOE,EAAQ9F,OAAO6F,GAE1B,IAAIE,EAAW,EACXlP,EAAmB,IACZmP,EAAqB,IAC5BC,EAAc,WAAc,MAAM,IAAIjX,MAAM,4BAC5C,EAA2B,SAAU6S,GAGrC,SAASqE,EAAUC,EAAQC,EAAiB3D,EAAoB4D,QACjC,IAAvBA,IAAiCA,EAAqB,MAC1D,IAAIrE,EAAQH,EAAOI,KAAKtV,OAASA,KAEjCqV,EAAMsE,eAAiBtE,EAAMM,UAAU,IAAI,QAC3CN,EAAMuE,cAAgBvE,EAAMsE,eAAeE,MAC3CxE,EAAMyE,wBAA0BzE,EAAMM,UAAU,IAAI,IACpDN,EAAM0E,uBAAyB1E,EAAMyE,wBAAwBD,MAC7DxE,EAAM2E,qBAAuB3E,EAAMM,UAAU,IAAI,QACjDN,EAAMmB,oBAAsBnB,EAAM2E,qBAAqBH,MACvDxE,EAAM4E,kCAAoC5E,EAAMM,UAAU,IAAI,QAC9DN,EAAM6E,iCAAmC7E,EAAM4E,kCAAkCJ,MACjFxE,EAAM8E,mBAAqB9E,EAAMM,UAAU,IAAI,QAC/CN,EAAM+E,kBAAoB/E,EAAM8E,mBAAmBN,MACnDxE,EAAMgF,oBAAsBhF,EAAMM,UAAU,IAAI,QAChDN,EAAMiF,mBAAqBjF,EAAMgF,oBAAoBR,MACrDxE,EAAMkF,qBAAuBlF,EAAMM,UAAU,IAAI,QACjDN,EAAMkB,oBAAsBlB,EAAMkF,qBAAqBV,MACvDxE,EAAMmF,cAAgBnF,EAAMM,UAAU,IAAI,IAE1CyD,IACA/D,EAAMqD,GAAK,SAAWU,EACtB/D,EAAMoF,kBAAoBhB,EAAgBgB,kBAEtCpF,EAAMqF,oBADwB,qBAAvBhB,GAA6D,OAAvBA,EACjB,OAAIiB,MAAM,oBAAsBvB,GAGhCM,EAEhCrE,EAAMuF,qBAAuB,EAC7BvF,EAAMwF,QAAU7B,EAAiBQ,EAAQC,EAAgBP,YACzD7D,EAAMyF,SAAWvB,EAAUwB,eAAe1F,EAAMwF,QAASpB,GACzD,IAAIuB,EAAkB3F,EAAMwF,QAAQ7L,eAChCiM,EAAmB5F,EAAMwF,QAAQK,sBAAsB,IAAI,OAAM,EAAG,EAAGF,EAAiB3F,EAAMwF,QAAQhD,cAAcmD,GAAmB,GAAI,GAiC/I,OA7BIvB,EAAgB0B,uBAChB9F,EAAM+F,2BAA+BH,EAAmB1B,EAAU8B,2BAC1DL,EAAkBzB,EAAU+B,gCAGpCjG,EAAM+F,4BAA6B,EAEvC/F,EAAMkG,sBAAyBN,EAAmB1B,EAAUiC,iBAC5DnG,EAAMoG,WAAa,EACnBpG,EAAMqG,sBAAwB,EAC9BrG,EAAME,aAAc,EACpBF,EAAMsG,cAAe,EACrBtG,EAAMuG,oBAAsB9F,GAAsB,OAClDT,EAAMwG,0BAA4B,OAA8BjG,aAAY,SAAUC,GAC9EA,EAAEC,mBAAmB4C,KAAOrD,EAAMuG,oBAAoBlD,IACtDrD,EAAM4E,kCAAkC6B,KAAK,OAGrDzG,EAAM0G,YAAcC,EAAA,KAAyB5C,GAC7C/D,EAAM4G,kBAAoB,EAC1B5G,EAAM6G,aAAerJ,OAAOQ,OAAO,MACnCgC,EAAM8G,iBAAmB,IAAI,EAC7B9G,EAAM+G,gBAAkB,IAAI,OAAU/G,GACtCA,EAAMgH,YAAa,EACnBhH,EAAMiH,YAAa,EACnBjH,EAAMkH,yBAA2B,KACjClH,EAAMzU,QAAU,IAAI,OACpByU,EAAMmH,SAAW,IAAI,OACrBnH,EAAMoH,cAAgB,IAAI,EAAsBpH,GACzCA,EAykEX,OA7oEA,EAAUkE,EAAWrE,GAsErBqE,EAAUmD,iBAAmB,SAAUzd,EAAM0d,EAAS7G,EAAoB8G,GAItE,YAHgB,IAAZD,IAAsBA,EAAUpD,EAAUsD,+BACnB,IAAvB/G,IAAiCA,EAAqB,WAC9C,IAAR8G,IAAkBA,EAAM,MACrB,IAAIrD,EAAUta,EAAM0d,EAAS7G,EAAoB8G,IAE5DrD,EAAUwB,eAAiB,SAAU+B,EAAYH,GAC7C,GAAIA,EAAQI,kBAAmB,CAC3B,IAAIC,EAAqB,eAAiBF,EAAYH,EAAQM,QAASN,EAAQO,cAC/E,OAAO,IAAI9Q,EAAA,KAA+B,CACtC6Q,QAASD,EAAmBC,QAC5BE,WAAYH,EAAmBC,QAC/BC,aAAcF,EAAmBE,aACjCE,mBAAoBT,EAAQS,mBAC5BlE,WAAYyD,EAAQzD,aAG5B,OAAO,IAAI9M,EAAA,KAA+B,CACtC6Q,QAASN,EAAQM,QACjBE,WAAYR,EAAQQ,WACpBD,aAAcP,EAAQO,aACtBE,mBAAoBT,EAAQS,mBAC5BlE,WAAYyD,EAAQzD,cAG5BK,EAAUrZ,UAAUkW,0BAA4B,SAAUiH,GACtD,OAAOrd,KAAKwa,cAAc8C,WAAU,SAAUzH,GAAK,OAAOwH,EAASxH,EAAEzD,4BAEzEmH,EAAUrZ,UAAUqd,sBAAwB,SAAUF,GAClD,OAAOrd,KAAKwa,cAAcgD,WAAU,SAAU3H,GAAK,OAAOwH,EAASxH,EAAEzD,4BAEzEmH,EAAUrZ,UAAUmW,uBAAyB,SAAUgH,GACnD,OAAOrd,KAAKwa,cAAc8C,WAAU,SAAUzH,GAAK,OAAOwH,EAASxH,EAAExD,yBAEzEkH,EAAUrZ,UAAUud,mBAAqB,SAAUJ,GAC/C,OAAOrd,KAAKwa,cAAcgD,WAAU,SAAU3H,GAAK,OAAOwH,EAASxH,EAAExD,yBAEzEkH,EAAUrZ,UAAUuW,QAAU,WAC1BzW,KAAK2b,cAAe,EACpB3b,KAAK2Z,eAAemC,OACpB9b,KAAK6b,0BAA0BpF,UAC/BzW,KAAKyc,cAAchG,UACnBzW,KAAKuV,aAAc,EACnBL,EAAOhV,UAAUuW,QAAQnB,KAAKtV,MAC9BA,KAAK2b,cAAe,GAExBpC,EAAUrZ,UAAUwd,mBAAqB,WACrC,GAAI1d,KAAKuV,YACL,MAAM,IAAIlT,MAAM,uBAGxBkX,EAAUrZ,UAAUyd,yBAA2B,SAAUC,EAAW9L,GAC5D9R,KAAK2b,cAIT3b,KAAKwa,cAAcsB,KAAK,IAAI3J,EAAgCyL,EAAW9L,KAE3EyH,EAAUrZ,UAAU2d,SAAW,SAAU5E,GAErC,GADAjZ,KAAK0d,qBACS,OAAVzE,EAAJ,CAIA,IAAI6D,EAAa9D,EAAiBC,EAAOjZ,KAAK8a,SAAS5B,YACvDlZ,KAAK8d,uBAAuBhB,KAEhCvD,EAAUrZ,UAAU6d,uBAAyB,SAAUzZ,EAAO0Z,EAAaC,EAAahf,EAAMyS,EAAWC,EAAWc,GAChH,MAAO,CACHjB,QAAS,CAAC,CACFlN,MAAOA,EACP0Z,YAAaA,EACbC,YAAaA,EACbhf,KAAMA,IAEduT,IAAKxS,KAAK6a,QAAQ/M,SAClB2D,UAAWzR,KAAKke,eAChBxM,UAAWA,EACXC,UAAWA,EACXc,QAASA,IAGjB8G,EAAUrZ,UAAU4d,uBAAyB,SAAUhB,GAEnD,GADA9c,KAAK0d,qBACc,OAAfZ,EAAJ,CAIA,IAAIqB,EAAoBne,KAAKoe,oBACzBC,EAAsBre,KAAKkb,sBAAsBiD,GACjD3a,EAAgBxD,KAAKgP,eACrBpK,EAAY5E,KAAKiP,iBAAiBzL,GACtCxD,KAAK6a,QAAUiC,EACf9c,KAAKse,qBAELte,KAAKY,QAAQ6E,QACbzF,KAAKwc,SAAS/W,QAEdzF,KAAKkc,aAAerJ,OAAOQ,OAAO,MAClCrT,KAAKmc,iBAAmB,IAAI,EAE5Bnc,KAAKoc,gBAAkB,IAAI,OAAUpc,MACrCA,KAAKuc,yBAA2B,KAChCvc,KAAK2d,yBAAyB,IAAIpM,EAA4B,CAC1D,IAAIT,GACL9Q,KAAKyb,YAAY,GAAO,GAAQzb,KAAK+d,uBAAuB,IAAI,OAAM,EAAG,EAAGva,EAAeoB,GAAY,EAAGyZ,EAAqBre,KAAKue,YAAY,GAAO,GAAO,MAErKhF,EAAUrZ,UAAUse,OAAS,SAAUhM,GACnCxS,KAAK0d,qBACL,IAAIe,EAAkB,IAARjM,EAAuB,OAAS,KAC9C,GAAIxS,KAAK6a,QAAQ/M,WAAa2Q,EAA9B,CAIA,IAAIN,EAAoBne,KAAKoe,oBACzBC,EAAsBre,KAAKkb,sBAAsBiD,GACjD3a,EAAgBxD,KAAKgP,eACrBpK,EAAY5E,KAAKiP,iBAAiBzL,GACtCxD,KAAK0e,qBACL1e,KAAK6a,QAAQ2D,OAAOC,GACpBze,KAAKse,qBACLte,KAAK2e,oBACL3e,KAAK2d,yBAAyB,IAAIpM,EAA4B,CAC1D,IAAID,GACLtR,KAAKyb,YAAY,GAAO,GAAQzb,KAAK+d,uBAAuB,IAAI,OAAM,EAAG,EAAGva,EAAeoB,GAAY,EAAGyZ,EAAqBre,KAAKue,YAAY,GAAO,GAAO,MAErKhF,EAAUrZ,UAAUwe,mBAAqB,WAErC,IAAIjN,EAAYzR,KAAKke,eACjBU,EAAiB5e,KAAKmc,iBAAiB0C,OAAO,GAAG,GAAO,EAAOpN,GACnEzR,KAAK8e,uBAAuBF,IAEhCrF,EAAUrZ,UAAUye,kBAAoB,WAIpC,IAFA,IAAIlN,EAAYzR,KAAKke,eACjBU,EAAiB5e,KAAKmc,iBAAiB4C,wBAClC1f,EAAI,EAAGC,EAAMsf,EAAerf,OAAQF,EAAIC,EAAKD,IAAK,CACvD,IAAI2f,EAAOJ,EAAevf,GACtBmK,EAAQwV,EAAKC,oBAAsBD,EAAK/W,MACxCgF,EAAcjN,KAAK6a,QAAQlN,YAAYqR,EAAK1a,MAAM9D,gBAAiBwe,EAAK1a,MAAMK,aAC9EuI,EAAYlN,KAAK6a,QAAQlN,YAAYqR,EAAK1a,MAAMd,cAAewb,EAAK1a,MAAMM,WAC9Eoa,EAAKC,oBAAsBhS,EAC3B+R,EAAKE,kBAAoBhS,EACzB8R,EAAKG,gBAAkB1N,EACvBuN,EAAK/W,MAAQgF,EAAczD,EAC3BwV,EAAKI,IAAMlS,EAAY1D,EACvB,eAAgBwV,KAGxBzF,EAAUrZ,UAAUmf,iBAAmB,WACnCrf,KAAK4a,uBAC6B,IAA9B5a,KAAK4a,sBACL5a,KAAKua,qBAAqBuB,UAAKwD,IAGvC/F,EAAUrZ,UAAUqf,iBAAmB,WACnCvf,KAAK4a,uBAC6B,IAA9B5a,KAAK4a,sBACL5a,KAAKua,qBAAqBuB,UAAKwD,IAGvC/F,EAAUrZ,UAAU0W,mBAAqB,WACrC,OAAO5W,KAAK4a,qBAAuB,GAEvCrB,EAAUrZ,UAAUsf,uBAAyB,WACzC,OAAOxf,KAAK4a,sBAEhBrB,EAAUrZ,UAAUuf,qBAAuB,WACvC,OAAOzf,KAAKub,uBAEhBhC,EAAUrZ,UAAUqY,0BAA4B,WAC5C,OAAOvY,KAAKob,4BAEhB7B,EAAUrZ,UAAUwf,WAAa,WAC7B,OAAO1f,KAAKuV,aAEhBgE,EAAUrZ,UAAUyf,uBAAyB,WAEzC,GADA3f,KAAK0d,qBACD1d,KAAKuY,4BAEL,OAAO,EAKX,IAHA,IAAIqH,EAAqB,EACrBC,EAAoB,EACpB9Q,EAAY/O,KAAK6a,QAAQ7L,eACpB5O,EAAa,EAAGA,GAAc2O,EAAW3O,IAAc,CAC5D,IAAI0f,EAAa9f,KAAK6a,QAAQhD,cAAczX,GACxC0f,GAAczG,EACdwG,GAAqBC,EAGrBF,GAAsBE,EAG9B,OAAQD,EAAoBD,GAEhC/M,OAAOgB,eAAe0F,EAAUrZ,UAAW,MAAO,CAC9CgQ,IAAK,WACD,OAAOlQ,KAAK0a,qBAEhB5G,YAAY,EACZC,cAAc,IAGlBwF,EAAUrZ,UAAU6f,WAAa,WAE7B,OADA/f,KAAK0d,qBACE1d,KAAK8a,UAEhBvB,EAAUrZ,UAAU8f,qBAAuB,WACvC,MAAO,CACH/C,QAASjd,KAAK8a,SAASqC,WACvBD,aAAcld,KAAK8a,SAASoC,eAGpC3D,EAAUrZ,UAAU+f,cAAgB,SAAUC,GAC1ClgB,KAAK0d,qBACL,IAAIT,EAAuC,qBAArBiD,EAASjD,QAA2BiD,EAASjD,QAAUjd,KAAK8a,SAASmC,QACvFE,EAA6C,qBAAxB+C,EAAS/C,WAA8B+C,EAAS/C,WAAand,KAAK8a,SAASqC,WAChGD,EAAiD,qBAA1BgD,EAAShD,aAAgCgD,EAAShD,aAAeld,KAAK8a,SAASoC,aACtGE,EAA6D,qBAAhC8C,EAAS9C,mBAAsC8C,EAAS9C,mBAAqBpd,KAAK8a,SAASsC,mBACxH+C,EAAU,IAAI/T,EAAA,KAA+B,CAC7C6Q,QAASA,EACTE,WAAYA,EACZD,aAAcA,EACdhE,WAAYlZ,KAAK8a,SAAS5B,WAC1BkE,mBAAoBA,IAExB,IAAIpd,KAAK8a,SAASnG,OAAOwL,GAAzB,CAGA,IAAItK,EAAI7V,KAAK8a,SAASsF,kBAAkBD,GACxCngB,KAAK8a,SAAWqF,EAChBngB,KAAKqa,oBAAoByB,KAAKjG,KAElC0D,EAAUrZ,UAAU6c,kBAAoB,SAAUsD,EAAqBC,GACnEtgB,KAAK0d,qBACL,IAAIV,EAAqB,eAAiBhd,KAAK6a,QAASyF,EAAgBD,GACxErgB,KAAKigB,cAAc,CACf/C,aAAcF,EAAmBE,aACjCD,QAASD,EAAmBC,QAC5BE,WAAYH,EAAmBC,WAGvC1D,EAAUgH,oCAAsC,SAAUC,EAAKrD,EAAYD,GAEvE,IADA,IAAIuD,EAAY,EACPphB,EAAI,EAAGA,EAAImhB,EAAIjhB,OAAQF,IACN,OAAlBmhB,EAAIE,OAAOrhB,GACXohB,GAAatD,EAGbsD,IAGR,IAAIra,EAAS,GACb,IAAK8W,EAAc,CACf,IAAIyD,EAAU3c,KAAKC,MAAMwc,EAAYtD,GACrCsD,GAAwBtD,EACxB,IAAS9d,EAAI,EAAGA,EAAIshB,EAASthB,IACzB+G,GAAU,KAGlB,IAAS/G,EAAI,EAAGA,EAAIohB,EAAWphB,IAC3B+G,GAAU,IAEd,OAAOA,GAEXmT,EAAUqH,qBAAuB,SAAUJ,EAAKrD,EAAYD,GACxD,IAAI2D,EAA0B7E,EAAA,KAAgCwE,GAI9D,OAHiC,IAA7BK,IACAA,EAA0BL,EAAIjhB,QAE3Bga,EAAUgH,oCAAoCC,EAAIpS,UAAU,EAAGyS,GAA0B1D,EAAYD,GAAgBsD,EAAIpS,UAAUyS,IAE9ItH,EAAUrZ,UAAU0gB,qBAAuB,SAAUJ,GAEjD,OADAxgB,KAAK0d,qBACEnE,EAAUqH,qBAAqBJ,EAAKxgB,KAAK8a,SAASqC,WAAYnd,KAAK8a,SAASoC,eAIvF3D,EAAUrZ,UAAUge,aAAe,WAE/B,OADAle,KAAK0d,qBACE1d,KAAKyb,YAEhBlC,EAAUrZ,UAAU4gB,gBAAkB,WAClC,OAAO9gB,KAAK6a,QAAQiG,mBAExBvH,EAAUrZ,UAAU6gB,0BAA4B,WAC5C,OAAO/gB,KAAK6a,QAAQkG,6BAExBxH,EAAUrZ,UAAU8gB,wBAA0B,WAE1C,OADAhhB,KAAK0d,qBACE1d,KAAK0b,uBAEhBnC,EAAUrZ,UAAUyN,YAAc,SAAUsT,GACxCjhB,KAAK0d,qBACL,IAAIxY,EAAWlF,KAAKkhB,kBAAkBD,EAAY7gB,WAAY6gB,EAAY7b,OAAQ,GAClF,OAAOpF,KAAK6a,QAAQlN,YAAYzI,EAAS9E,WAAY8E,EAASE,SAElEmU,EAAUrZ,UAAUqN,cAAgB,SAAU4T,GAC1CnhB,KAAK0d,qBACL,IAAI7a,EAAUmB,KAAKG,IAAInE,KAAK6a,QAAQuG,YAAapd,KAAKI,IAAI,EAAG+c,IAC7D,OAAOnhB,KAAK6a,QAAQtN,cAAc1K,IAEtC0W,EAAUrZ,UAAUoe,mBAAqB,WACrCte,KAAKyb,WAAazb,KAAKyb,WAAa,EACpCzb,KAAK0b,sBAAwB1b,KAAKyb,YAEtClC,EAAUrZ,UAAUmhB,+BAAiC,SAAUC,GAC3DthB,KAAK0b,sBAAwB4F,GAEjC/H,EAAUrZ,UAAUqe,SAAW,SAAU/L,EAAK+O,QACtB,IAAhBA,IAA0BA,GAAc,GAC5CvhB,KAAK0d,qBACL,IAAI8D,EAAiBxhB,KAAKoe,oBACtBqD,EAAiBzhB,KAAK6N,gBAAgB2T,EAAgBhP,GAC1D,OAAI+O,EACOvhB,KAAK6a,QAAQ6G,SAAWD,EAE5BA,GAEXlI,EAAUrZ,UAAUyhB,eAAiB,SAAUnP,EAAK+O,QAC5B,IAAhBA,IAA0BA,GAAc,GAC5CvhB,KAAK0d,qBACL,IAAI8D,EAAiBxhB,KAAKoe,oBACtBqD,EAAiBzhB,KAAKkb,sBAAsBsG,EAAgBhP,GAChE,OAAI+O,EACOvhB,KAAK6a,QAAQ6G,SAASniB,OAASkiB,EAEnCA,GAEXlI,EAAUrZ,UAAU2N,gBAAkB,SAAU+T,EAAUpP,GAGtD,YAFY,IAARA,IAAkBA,EAAM,GAC5BxS,KAAK0d,qBACE1d,KAAK6a,QAAQhN,gBAAgB7N,KAAK6hB,cAAcD,GAAWpP,IAEtE+G,EAAUrZ,UAAUgb,sBAAwB,SAAU0G,EAAUpP,GAG5D,YAFY,IAARA,IAAkBA,EAAM,GAC5BxS,KAAK0d,qBACE1d,KAAK6a,QAAQK,sBAAsBlb,KAAK6hB,cAAcD,GAAWpP,IAE5E+G,EAAUrZ,UAAU4hB,yBAA2B,SAAUF,EAAUpP,GAG/D,YAFY,IAARA,IAAkBA,EAAM,GAC5BxS,KAAK0d,qBACE1d,KAAK6a,QAAQiH,yBAAyB9hB,KAAK6hB,cAAcD,GAAWpP,IAE/E+G,EAAUrZ,UAAU8O,aAAe,WAE/B,OADAhP,KAAK0d,qBACE1d,KAAK6a,QAAQ7L,gBAExBuK,EAAUrZ,UAAU6G,eAAiB,SAAU3G,GAE3C,GADAJ,KAAK0d,qBACDtd,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpB,OAAOrC,KAAK6a,QAAQ9T,eAAe3G,IAEvCmZ,EAAUrZ,UAAU2X,cAAgB,SAAUzX,GAE1C,GADAJ,KAAK0d,qBACDtd,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpB,OAAOrC,KAAK6a,QAAQhD,cAAczX,IAEtCmZ,EAAUrZ,UAAU6hB,gBAAkB,WAElC,OADA/hB,KAAK0d,qBACE1d,KAAK6a,QAAQkH,mBAExBxI,EAAUrZ,UAAU4N,OAAS,WAEzB,OADA9N,KAAK0d,qBACE1d,KAAK6a,QAAQ/M,UAExByL,EAAUrZ,UAAU8hB,iBAAmB,SAAU5hB,GAE7C,OADAJ,KAAK0d,qBACE,GAEXnE,EAAUrZ,UAAU+O,iBAAmB,SAAU7O,GAE7C,GADAJ,KAAK0d,qBACDtd,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpB,OAAOrC,KAAK6a,QAAQhD,cAAczX,GAAc,GAEpDmZ,EAAUrZ,UAAUgY,gCAAkC,SAAU9X,GAE5D,GADAJ,KAAK0d,qBACDtd,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpB,OAAOrC,KAAK6a,QAAQ3C,gCAAgC9X,IAExDmZ,EAAUrZ,UAAU+hB,+BAAiC,SAAU7hB,GAE3D,GADAJ,KAAK0d,qBACDtd,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpB,OAAOrC,KAAK6a,QAAQoH,+BAA+B7hB,IAMvDmZ,EAAUrZ,UAAUgiB,mCAAqC,SAAU5d,GAC/D,IAGI9D,EACAmE,EAJAwd,EAAaniB,KAAK6a,QAAQ7L,eAC1BoT,EAAyB9d,EAAM9D,gBAC/B6hB,EAAqB/d,EAAMK,YAG/B,GAAIyd,EAAyB,EACzB5hB,EAAkB,EAClBmE,EAAc,OAEb,GAAIyd,EAAyBD,EAC9B3hB,EAAkB2hB,EAClBxd,EAAc3E,KAAKiP,iBAAiBzO,QAIpC,GADAA,EAA2C,EAAzB4hB,EACdC,GAAsB,EACtB1d,EAAc,MAEb,CACD,IAAI2d,EAAYtiB,KAAKiP,iBAAiBzO,GAElCmE,EADA0d,GAAsBC,EACRA,EAGqB,EAArBD,EAI1B,IAEI7e,EACAoB,EAHA2d,EAAuBje,EAAMd,cAC7Bgf,EAAmBle,EAAMM,UAG7B,GAAI2d,EAAuB,EACvB/e,EAAgB,EAChBoB,EAAY,OAEX,GAAI2d,EAAuBJ,EAC5B3e,EAAgB2e,EAChBvd,EAAY5E,KAAKiP,iBAAiBzL,QAIlC,GADAA,EAAuC,EAAvB+e,EACZC,GAAoB,EACpB5d,EAAY,MAEX,CACG0d,EAAYtiB,KAAKiP,iBAAiBzL,GAElCoB,EADA4d,GAAoBF,EACRA,EAGmB,EAAnBE,EAIxB,OAAIJ,IAA2B5hB,GACxB6hB,IAAuB1d,GACvB4d,IAAyB/e,GACzBgf,IAAqB5d,GACrBN,aAAiB,UACfA,aAAiB,QACfA,EAEJ,IAAI,OAAM9D,EAAiBmE,EAAanB,EAAeoB,IAElE2U,EAAUrZ,UAAUuiB,iBAAmB,SAAUriB,EAAYgF,EAAQsd,GACjE,GAA0B,kBAAftiB,GAA6C,kBAAXgF,EACzC,OAAO,EAEX,GAAIud,MAAMviB,IAAeuiB,MAAMvd,GAC3B,OAAO,EAEX,GAAIhF,EAAa,GAAKgF,EAAS,EAC3B,OAAO,EAEX,IAAkB,EAAbhF,KAAoBA,IAAwB,EAATgF,KAAgBA,EACpD,OAAO,EAEX,IAAI2J,EAAY/O,KAAK6a,QAAQ7L,eAC7B,GAAI5O,EAAa2O,EACb,OAAO,EAEX,GAAe,IAAX3J,EACA,OAAO,EAEX,IAAIkd,EAAYtiB,KAAKiP,iBAAiB7O,GACtC,GAAIgF,EAASkd,EACT,OAAO,EAEX,GAAuB,IAAnBI,EAA2C,CAE3C,IAAIE,EAAiB5iB,KAAK6a,QAAQgI,gBAAgBziB,EAAYgF,EAAS,GACvE,GAAI4W,EAAA,KAAwB4G,GACxB,OAAO,EAGf,OAAO,GAEXrJ,EAAUrZ,UAAUghB,kBAAoB,SAAU4B,EAAaC,EAASL,GACpE,IAAItiB,EAAa4D,KAAKC,MAA8B,kBAAhB6e,GAA6BH,MAAMG,GAA8B,EAAdA,GACnF1d,EAASpB,KAAKC,MAA0B,kBAAZ8e,GAAyBJ,MAAMI,GAAsB,EAAVA,GACvEhU,EAAY/O,KAAK6a,QAAQ7L,eAC7B,GAAI5O,EAAa,EACb,OAAO,IAAI,OAAS,EAAG,GAE3B,GAAIA,EAAa2O,EACb,OAAO,IAAI,OAASA,EAAW/O,KAAKiP,iBAAiBF,IAEzD,GAAI3J,GAAU,EACV,OAAO,IAAI,OAAShF,EAAY,GAEpC,IAAIkiB,EAAYtiB,KAAKiP,iBAAiB7O,GACtC,GAAIgF,GAAUkd,EACV,OAAO,IAAI,OAASliB,EAAYkiB,GAEpC,GAAuB,IAAnBI,EAA2C,CAI3C,IAAIE,EAAiB5iB,KAAK6a,QAAQgI,gBAAgBziB,EAAYgF,EAAS,GACvE,GAAI4W,EAAA,KAAwB4G,GACxB,OAAO,IAAI,OAASxiB,EAAYgF,EAAS,GAGjD,OAAO,IAAI,OAAShF,EAAYgF,IAEpCmU,EAAUrZ,UAAU8iB,iBAAmB,SAAU9d,GAC7C,IAAIwd,EAAiB,EAGrB,OAFA1iB,KAAK0d,qBAEDxY,aAAoB,QAChBlF,KAAKyiB,iBAAiBvd,EAAS9E,WAAY8E,EAASE,OAAQsd,GACrDxd,EAGRlF,KAAKkhB,kBAAkBhc,EAAS9E,WAAY8E,EAASE,OAAQsd,IAExEnJ,EAAUrZ,UAAU+iB,cAAgB,SAAU3e,EAAOoe,GACjD,IAAIliB,EAAkB8D,EAAM9D,gBACxBmE,EAAcL,EAAMK,YACpBnB,EAAgBc,EAAMd,cACtBoB,EAAYN,EAAMM,UACtB,IAAK5E,KAAKyiB,iBAAiBjiB,EAAiBmE,EAAa,GACrD,OAAO,EAEX,IAAK3E,KAAKyiB,iBAAiBjf,EAAeoB,EAAW,GACjD,OAAO,EAEX,GAAuB,IAAnB8d,EAA2C,CAC3C,IAAIQ,EAAuBve,EAAc,EAAI3E,KAAK6a,QAAQgI,gBAAgBriB,EAAiBmE,EAAc,GAAK,EAC1Gwe,EAAqBve,EAAY,GAAKA,GAAa5E,KAAK6a,QAAQhD,cAAcrU,GAAiBxD,KAAK6a,QAAQgI,gBAAgBrf,EAAeoB,EAAY,GAAK,EAC5Jwe,EAA2BpH,EAAA,KAAwBkH,GACnDG,EAAyBrH,EAAA,KAAwBmH,GACrD,OAAKC,IAA6BC,EAKtC,OAAO,GAEX9J,EAAUrZ,UAAU2hB,cAAgB,SAAUyB,GAC1C,IAAIZ,EAAiB,EAGrB,GAFA1iB,KAAK0d,qBAEA4F,aAAkB,UAAYA,aAAkB,SAC7CtjB,KAAKijB,cAAcK,EAAQZ,GAC3B,OAAOY,EAGf,IAAIrb,EAAQjI,KAAKkhB,kBAAkBoC,EAAO9iB,gBAAiB8iB,EAAO3e,YAAa,GAC3Eya,EAAMpf,KAAKkhB,kBAAkBoC,EAAO9f,cAAe8f,EAAO1e,UAAW,GACrEpE,EAAkByH,EAAM7H,WACxBuE,EAAcsD,EAAM7C,OACpB5B,EAAgB4b,EAAIhf,WACpBwE,EAAYwa,EAAIha,OACpB,GAAuB,IAAnBsd,EAA2C,CAC3C,IAAIQ,EAAuBve,EAAc,EAAI3E,KAAK6a,QAAQgI,gBAAgBriB,EAAiBmE,EAAc,GAAK,EAC1Gwe,EAAqBve,EAAY,GAAKA,GAAa5E,KAAK6a,QAAQhD,cAAcrU,GAAiBxD,KAAK6a,QAAQgI,gBAAgBrf,EAAeoB,EAAY,GAAK,EAC5Jwe,EAA2BpH,EAAA,KAAwBkH,GACnDG,EAAyBrH,EAAA,KAAwBmH,GACrD,OAAKC,GAA6BC,EAG9B7iB,IAAoBgD,GAAiBmB,IAAgBC,EAE9C,IAAI,OAAMpE,EAAiBmE,EAAc,EAAGnB,EAAeoB,EAAY,GAE9Ewe,GAA4BC,EAErB,IAAI,OAAM7iB,EAAiBmE,EAAc,EAAGnB,EAAeoB,EAAY,GAE9Ewe,EAEO,IAAI,OAAM5iB,EAAiBmE,EAAc,EAAGnB,EAAeoB,GAG/D,IAAI,OAAMpE,EAAiBmE,EAAanB,EAAeoB,EAAY,GAf/D,IAAI,OAAMpE,EAAiBmE,EAAanB,EAAeoB,GAiBtE,OAAO,IAAI,OAAMpE,EAAiBmE,EAAanB,EAAeoB,IAElE2U,EAAUrZ,UAAUqjB,eAAiB,SAAUtC,EAAape,GACxD7C,KAAK0d,qBACL,IAAI8F,EAAYxjB,KAAK2N,YAAYsT,GAAepe,EAChD,OAAO7C,KAAKuN,cAAcvJ,KAAKG,IAAInE,KAAK6a,QAAQuG,YAAapd,KAAKI,IAAI,EAAGof,MAE7EjK,EAAUrZ,UAAUke,kBAAoB,WACpCpe,KAAK0d,qBACL,IAAI3O,EAAY/O,KAAKgP,eACrB,OAAO,IAAI,OAAM,EAAG,EAAGD,EAAW/O,KAAKiP,iBAAiBF,KAE5DwK,EAAUrZ,UAAUujB,sBAAwB,SAAUnX,EAAaE,EAAYd,EAAgBa,GAC3F,OAAOvM,KAAK6a,QAAQ4I,sBAAsBnX,EAAaE,EAAYd,EAAgBa,IAEvFgN,EAAUrZ,UAAUiM,YAAc,SAAU/B,EAAcsZ,EAAgBrZ,EAASC,EAAWC,EAAgBmB,EAAgBa,GAG1H,IAAID,EAOJ,QATyB,IAArBC,IAA+BA,EAAmBrC,GACtDlK,KAAK0d,qBAGDpR,EADA,OAAMqX,SAASD,GACD1jB,KAAK6hB,cAAc6B,GAGnB1jB,KAAKoe,qBAElB/T,GAAWD,EAAaO,QAAQ,MAAQ,EAAG,CAE5C,IAAI0B,EAAe,IAAI,OAAajC,EAAcC,EAASC,EAAWC,GAClEiC,EAAaH,EAAa7B,qBAC9B,OAAKgC,EAGExM,KAAKyjB,sBAAsBnX,EAAaE,EAAYd,EAAgBa,GAFhE,GAIf,OAAO,OAAgBJ,YAAYnM,KAAM,IAAI,OAAaoK,EAAcC,EAASC,EAAWC,GAAiB+B,EAAaZ,EAAgBa,IAE9IgN,EAAUrZ,UAAUwO,cAAgB,SAAUtE,EAAcwZ,EAAgBvZ,EAASC,EAAWC,EAAgBmB,GAC5G1L,KAAK0d,qBACL,IAAI/O,EAAc3O,KAAKgjB,iBAAiBY,GACxC,IAAKvZ,GAAWD,EAAaO,QAAQ,MAAQ,EAAG,CAC5C,IAAI0B,EAAe,IAAI,OAAajC,EAAcC,EAASC,EAAWC,GAClEiC,EAAaH,EAAa7B,qBAC9B,IAAKgC,EACD,OAAO,KAEX,IAAIuC,EAAY/O,KAAKgP,eACjB1C,EAAc,IAAI,OAAMqC,EAAYvO,WAAYuO,EAAYvJ,OAAQ2J,EAAW/O,KAAKiP,iBAAiBF,IACrG8U,EAAM7jB,KAAKyjB,sBAAsBnX,EAAaE,EAAYd,EAAgB,GAE9E,OADA,OAAgBgD,cAAc1O,KAAM,IAAI,OAAaoK,EAAcC,EAASC,EAAWC,GAAiBoE,EAAajD,GACjHmY,EAAItkB,OAAS,EACNskB,EAAI,IAEfvX,EAAc,IAAI,OAAM,EAAG,EAAGqC,EAAYvO,WAAYJ,KAAKiP,iBAAiBN,EAAYvO,aACxFyjB,EAAM7jB,KAAKyjB,sBAAsBnX,EAAaE,EAAYd,EAAgB,GACtEmY,EAAItkB,OAAS,EACNskB,EAAI,GAER,MAEX,OAAO,OAAgBnV,cAAc1O,KAAM,IAAI,OAAaoK,EAAcC,EAASC,EAAWC,GAAiBoE,EAAajD,IAEhI6N,EAAUrZ,UAAUqP,kBAAoB,SAAUnF,EAAcwZ,EAAgBvZ,EAASC,EAAWC,EAAgBmB,GAChH1L,KAAK0d,qBACL,IAAI/O,EAAc3O,KAAKgjB,iBAAiBY,GACxC,OAAO,OAAgBrU,kBAAkBvP,KAAM,IAAI,OAAaoK,EAAcC,EAASC,EAAWC,GAAiBoE,EAAajD,IAIpI6N,EAAUrZ,UAAU4jB,iBAAmB,WACnC9jB,KAAKoc,gBAAgB0H,oBAEzBvK,EAAUrZ,UAAU6jB,QAAU,SAAUvR,GACpC,IAAIwR,EAAgC,OAAlBhkB,KAAK8N,SAAoB,EAAa,EACxD,GAAIkW,IAAexR,EAGnB,IACIxS,KAAK8Z,wBAAwBmK,oBAC7BjkB,KAAKwa,cAAcyJ,oBACnBjkB,KAAKoc,gBAAgB2H,QAAQvR,GAEjC,QACIxS,KAAKwa,cAAc0J,kBACnBlkB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAUikB,mBAAqB,SAAUC,EAAmBC,EAAgBC,GAClF,IAGI,OAFAtkB,KAAK8Z,wBAAwBmK,oBAC7BjkB,KAAKwa,cAAcyJ,oBACZjkB,KAAKukB,oBAAoBH,EAAmBC,EAAgBC,GAEvE,QACItkB,KAAKwa,cAAc0J,kBACnBlkB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAUqkB,oBAAsB,SAAUH,EAAmBC,EAAgBC,GACnF,IAAIjP,EAAQrV,KACZ,GAAIA,KAAK8a,SAASsC,oBAAsBpd,KAAKuc,yBAA0B,CAYnE,IATA,IAAIiI,EAAgBH,EAAeI,KAAI,SAAUC,GAC7C,MAAO,CACHpgB,MAAO+Q,EAAMwM,cAAc6C,EAAGpgB,OAC9BrF,KAAMylB,EAAGzlB,SAKb0lB,GAAsB,EACjBtlB,EAAI,EAAGC,EAAM8kB,EAAkB7kB,OAAQF,EAAIC,EAAKD,IAAK,CAG1D,IAFA,IAAIulB,EAAMR,EAAkB/kB,GACxBwlB,GAAmB,EACd5P,EAAI,EAAG6P,EAAON,EAAcjlB,OAAQ0V,EAAI6P,EAAM7P,IAAK,CACxD,IAAI8P,EAAYP,EAAcvP,GAAG3Q,MAC7B0gB,EAAaD,EAAUvkB,gBAAkBokB,EAAIphB,cAC7CyhB,EAAaL,EAAIpkB,gBAAkBukB,EAAUvhB,cACjD,IAAKwhB,IAAeC,EAAY,CAC5BJ,GAAmB,EACnB,OAGR,IAAKA,EAAkB,CACnBF,GAAsB,EACtB,OAGR,GAAIA,EACA,IAAStlB,EAAI,EAAGC,EAAMU,KAAKuc,yBAAyBhd,OAAQF,EAAIC,EAAKD,IAAK,CACtE,IAAI6lB,EAAiBllB,KAAKuc,yBAAyBld,GAC/C8lB,EAAgBnlB,KAAKiP,iBAAiBiW,GACtCE,GAAgB,EACpB,IAASnQ,EAAI,EAAG6P,EAAON,EAAcjlB,OAAQ0V,EAAI6P,EAAM7P,IAAK,CACpD8P,EAAYP,EAAcvP,GAAG3Q,MAAjC,IACI+gB,EAAWb,EAAcvP,GAAGhW,KAChC,KAAIimB,EAAiBH,EAAUvkB,iBAAmB0kB,EAAiBH,EAAUvhB,mBAMzE0hB,IAAmBH,EAAUvkB,iBAAmBukB,EAAUpgB,cAAgBwgB,GACvEJ,EAAUO,WAAaD,GAAYA,EAAS9lB,OAAS,GAA4B,OAAvB8lB,EAAS3E,OAAO,OAI7EwE,IAAmBH,EAAUvkB,iBAA6C,IAA1BukB,EAAUpgB,aACvDogB,EAAUO,WAAaD,GAAYA,EAAS9lB,OAAS,GAA8C,OAAzC8lB,EAAS3E,OAAO2E,EAAS9lB,OAAS,KADnG,CAMA6lB,GAAgB,EAChB,OAEAA,GACAf,EAAe5jB,KAAK,CAChB6D,MAAO,IAAI,OAAM4gB,EAAgB,EAAGA,EAAgBC,GACpDlmB,KAAM,OAKtBe,KAAKuc,yBAA2B,KAEpC,OAAOvc,KAAKoc,gBAAgBmJ,kBAAkBnB,EAAmBC,EAAgBC,IAErF/K,EAAUrZ,UAAU2U,WAAa,SAAU2Q,GACvC,IAGI,OAFAxlB,KAAK8Z,wBAAwBmK,oBAC7BjkB,KAAKwa,cAAcyJ,oBACZjkB,KAAKylB,YAAYD,GAE5B,QACIxlB,KAAKwa,cAAc0J,kBACnBlkB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAUulB,YAAc,SAAUD,GACxC,IAAK,IAAInmB,EAAI,EAAGC,EAAMkmB,EAAcjmB,OAAQF,EAAIC,EAAKD,IACjDmmB,EAAcnmB,GAAGiF,MAAQtE,KAAK6hB,cAAc2D,EAAcnmB,GAAGiF,OAEjE,IAAIohB,EAAe1lB,KAAK6a,QAAQ7L,eAC5B5I,EAASpG,KAAK6a,QAAQhG,WAAW2Q,EAAexlB,KAAK8a,SAASsC,oBAC9DuI,EAAe3lB,KAAK6a,QAAQ7L,eAC5B4W,EAAiBxf,EAAOoL,QAE5B,GADAxR,KAAKuc,yBAA2BnW,EAAOyf,8BACT,IAA1BD,EAAermB,OAAc,CAC7B,IAAIumB,EAAoB,GACpB/W,EAAY2W,EAChB,IAASrmB,EAAI,EAAGC,EAAMsmB,EAAermB,OAAQF,EAAIC,EAAKD,IAAK,CACvD,IAAIyS,EAAS8T,EAAevmB,GACxBkF,EAAK,eAASuN,EAAO7S,MAAOC,EAAWqF,EAAG,GAAIpF,EAAkBoF,EAAG,GAAI7B,EAAiB6B,EAAG,GAC/FvE,KAAKY,QAAQ4D,WAAWsN,EAAOxN,MAAOpF,EAAUC,GAChDa,KAAKwc,SAAShY,WAAWsN,EAAOxN,MAAOpF,EAAUC,EAAiBuD,EAAgBoP,EAAO7S,KAAKM,OAAS,EAAIuS,EAAO7S,KAAKQ,WAAW,GAAK,GACvIO,KAAK8Z,wBAAwBgC,OAC7B9b,KAAKmc,iBAAiB4J,cAAcjU,EAAOkM,YAAalM,EAAOmM,YAAanM,EAAO7S,KAAKM,OAAQuS,EAAOkU,kBAOvG,IANA,IAAIxlB,EAAkBsR,EAAOxN,MAAM9D,gBAC/BgD,EAAgBsO,EAAOxN,MAAMd,cAC7BsR,EAAmBtR,EAAgBhD,EACnCuU,EAAoB7V,EACpB8V,EAAkBhR,KAAKG,IAAI2Q,EAAkBC,GAC7CkR,EAAwBlR,EAAoBD,EACvCG,EAAID,EAAiBC,GAAK,EAAGA,IAAK,CACvC,IAAIiR,EAAiB1lB,EAAkByU,EACnCkR,EAAwBR,EAAe5W,EAAYkX,EAAuBC,EAC9EJ,EAAkBrlB,KAAK,IAAIuQ,EAAoBkV,EAAgBlmB,KAAK+G,eAAeof,KAEvF,GAAInR,EAAkBF,EAAkB,CAEpC,IAAIsR,EAAwB5lB,EAAkBwU,EAC9C8Q,EAAkBrlB,KAAK,IAAIyQ,EAAqBkV,EAAwB,EAAG5iB,IAE/E,GAAIwR,EAAkBD,EAAmB,CAMrC,IAJA,IAAIsR,EAAmB7lB,EAAkBwU,EACrCsR,EAAMvR,EAAoBC,EAC1B7D,EAAiBwU,EAAe5W,EAAYuX,EAAMD,EAAmB,EACrEE,EAAW,GACNC,EAAM,EAAGA,EAAMF,EAAKE,IAAO,CAChC,IAAIpmB,EAAa+Q,EAAiBqV,EAClCD,EAASnmB,EAAa+Q,GAAkBnR,KAAK+G,eAAe3G,GAEhE0lB,EAAkBrlB,KAAK,IAAI4Q,EAAsBgV,EAAmB,EAAG7lB,EAAkBuU,EAAmBwR,IAEhHxX,GAAakX,EAEjBjmB,KAAKse,qBACLte,KAAK2d,yBAAyB,IAAIpM,EAA4BuU,EAAmB9lB,KAAKke,eAAgBle,KAAKqc,WAAYrc,KAAKsc,YAAa,CACrI9K,QAASoU,EACTpT,IAAKxS,KAAK6a,QAAQ/M,SAClB2D,UAAWzR,KAAKke,eAChBxM,UAAW1R,KAAKqc,WAChB1K,UAAW3R,KAAKsc,WAChB7J,SAAS,IAGjB,OAAOrM,EAAOqgB,cAElBlN,EAAUrZ,UAAUwmB,MAAQ,WACxB1mB,KAAKqc,YAAa,EAClB,IAAInN,EAAIlP,KAAKoc,gBAAgBuK,OAE7B,OADA3mB,KAAKqc,YAAa,EACbnN,GAGLlP,KAAKqhB,+BAA+BnS,EAAE0X,mBAC/B1X,EAAE2X,YAHE,MAKftN,EAAUrZ,UAAUymB,KAAO,WACvB,IAGI,OAFA3mB,KAAK8Z,wBAAwBmK,oBAC7BjkB,KAAKwa,cAAcyJ,oBACZjkB,KAAK0mB,QAEhB,QACI1mB,KAAKwa,cAAc0J,kBACnBlkB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAU4mB,QAAU,WAC1B,OAAO9mB,KAAKoc,gBAAgB0K,WAEhCvN,EAAUrZ,UAAU6mB,MAAQ,WACxB/mB,KAAKsc,YAAa,EAClB,IAAIpN,EAAIlP,KAAKoc,gBAAgB4K,OAE7B,OADAhnB,KAAKsc,YAAa,EACbpN,GAGLlP,KAAKqhB,+BAA+BnS,EAAE0X,mBAC/B1X,EAAE2X,YAHE,MAKftN,EAAUrZ,UAAU8mB,KAAO,WACvB,IAGI,OAFAhnB,KAAK8Z,wBAAwBmK,oBAC7BjkB,KAAKwa,cAAcyJ,oBACZjkB,KAAK+mB,QAEhB,QACI/mB,KAAKwa,cAAc0J,kBACnBlkB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAU+mB,QAAU,WAC1B,OAAOjnB,KAAKoc,gBAAgB6K,WAIhC1N,EAAUrZ,UAAUgnB,kBAAoB,SAAUC,EAAUC,QACxC,IAAZA,IAAsBA,EAAU,GACpCpnB,KAAK0d,qBACL,IAEI,OADA1d,KAAK8Z,wBAAwBmK,oBACtBjkB,KAAKqnB,mBAAmBD,EAASD,GAE5C,QACInnB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAUmnB,mBAAqB,SAAUD,EAASD,GACxD,IAAI9R,EAAQrV,KACRsnB,EAAiB,CACjBC,cAAe,SAAUjjB,EAAOqY,GAE5B,OADAtH,EAAMyE,wBAAwBgC,OACvBzG,EAAMmS,sBAAsBJ,EAAS,GAAI,CAAC,CAAE9iB,MAAOA,EAAOqY,QAASA,KAAY,IAE1F8K,iBAAkB,SAAU/O,EAAIgP,GAC5BrS,EAAMyE,wBAAwBgC,OAC9BzG,EAAMsS,sBAAsBjP,EAAIgP,IAEpCE,wBAAyB,SAAUlP,EAAIiE,GACnCtH,EAAMyE,wBAAwBgC,OAC9BzG,EAAMwS,6BAA6BnP,EAAIoP,GAAkBnL,KAE7DoL,iBAAkB,SAAUrP,GACxBrD,EAAMyE,wBAAwBgC,OAC9BzG,EAAMmS,sBAAsBJ,EAAS,CAAC1O,GAAK,KAE/CsP,iBAAkB,SAAUC,EAAgBC,GACxC,OAA8B,IAA1BD,EAAe1oB,QAA0C,IAA1B2oB,EAAe3oB,OAEvC,IAEX8V,EAAMyE,wBAAwBgC,OACvBzG,EAAMmS,sBAAsBJ,EAASa,EAAgBC,MAGhE9hB,EAAS,KACb,IACIA,EAAS+gB,EAASG,GAEtB,MAAOzR,GACH,eAAkBA,GAQtB,OALAyR,EAAeC,cAAgBjO,EAC/BgO,EAAeG,iBAAmBnO,EAClCgO,EAAeM,wBAA0BtO,EACzCgO,EAAeS,iBAAmBzO,EAClCgO,EAAeU,iBAAmB1O,EAC3BlT,GAEXmT,EAAUrZ,UAAU8nB,iBAAmB,SAAUC,EAAgBC,EAAgBd,GAM7E,QALgB,IAAZA,IAAsBA,EAAU,GACpCpnB,KAAK0d,qBACAuK,IACDA,EAAiB,IAES,IAA1BA,EAAe1oB,QAA0C,IAA1B2oB,EAAe3oB,OAE9C,MAAO,GAEX,IAGI,OAFAS,KAAK8Z,wBAAwBmK,oBAC7BjkB,KAAK8Z,wBAAwBgC,OACtB9b,KAAKwnB,sBAAsBJ,EAASa,EAAgBC,GAE/D,QACIloB,KAAK8Z,wBAAwBoK,oBAGrC3K,EAAUrZ,UAAUioB,iBAAmB,SAAUzP,GAC7C,OAAO1Y,KAAKooB,mBAAmB1P,IAEnCa,EAAUrZ,UAAUmoB,iBAAmB,SAAU3P,EAAIgP,EAAUY,GAC3D,IAAItJ,EAAQtG,EAAK1Y,KAAKkc,aAAaxD,GAAM,KACzC,IAAKsG,EACD,OAAK0I,EAKE1nB,KAAKwnB,sBAAsB,EAAG,GAAI,CAAC,CAAEljB,MAAOojB,EAAU/K,QAAS4L,GAAsBD,MAAmB,GAHpG,KAKf,IAAKZ,EAID,OAFA1nB,KAAKmc,iBAAiBqM,OAAOxJ,UACtBhf,KAAKkc,aAAa8C,EAAKtG,IACvB,KAGX,IAAIpU,EAAQtE,KAAKkiB,mCAAmCwF,GAChDza,EAAcjN,KAAK6a,QAAQlN,YAAYrJ,EAAM9D,gBAAiB8D,EAAMK,aACpEuI,EAAYlN,KAAK6a,QAAQlN,YAAYrJ,EAAMd,cAAec,EAAMM,WAKpE,OAJA5E,KAAKmc,iBAAiBqM,OAAOxJ,GAC7BA,EAAKhR,MAAMhO,KAAKke,eAAgBjR,EAAaC,EAAW5I,GACxD0a,EAAKyJ,WAAWF,GAAsBD,IACtCtoB,KAAKmc,iBAAiBuM,OAAO1J,GACtBA,EAAKtG,IAEhBa,EAAUrZ,UAAUyoB,gCAAkC,SAAUvB,GAC5D,IAAIpnB,KAAKuV,YAIT,IADA,IAAIqT,EAAQ5oB,KAAKmc,iBAAiB0M,sBAAsBzB,GAC/C/nB,EAAI,EAAGC,EAAMspB,EAAMrpB,OAAQF,EAAIC,EAAKD,IAAK,CAC9C,IAAI2f,EAAO4J,EAAMvpB,GACjBW,KAAKmc,iBAAiBqM,OAAOxJ,UACtBhf,KAAKkc,aAAa8C,EAAKtG,MAGtCa,EAAUrZ,UAAU4oB,qBAAuB,SAAUC,GACjD,IAAI/J,EAAOhf,KAAKkc,aAAa6M,GAC7B,OAAK/J,EAGEA,EAAKrC,QAFD,MAIfpD,EAAUrZ,UAAUkoB,mBAAqB,SAAUW,GAC/C,IAAI/J,EAAOhf,KAAKkc,aAAa6M,GAC7B,IAAK/J,EACD,OAAO,KAEX,IAAIvN,EAAYzR,KAAKke,eAOrB,OANIc,EAAKG,kBAAoB1N,GACzBzR,KAAKmc,iBAAiB6M,YAAYhK,EAAMvN,GAEzB,OAAfuN,EAAK1a,QACL0a,EAAK1a,MAAQtE,KAAKipB,YAAYjK,EAAKC,oBAAqBD,EAAKE,oBAE1DF,EAAK1a,OAEhBiV,EAAUrZ,UAAUgpB,mBAAqB,SAAU9oB,EAAYgnB,EAAS+B,GAGpE,YAFgB,IAAZ/B,IAAsBA,EAAU,QACR,IAAxB+B,IAAkCA,GAAsB,GACxD/oB,EAAa,GAAKA,EAAaJ,KAAKgP,eAC7B,GAEJhP,KAAKopB,oBAAoBhpB,EAAYA,EAAYgnB,EAAS+B,IAErE5P,EAAUrZ,UAAUkpB,oBAAsB,SAAUC,EAAkBC,EAAgBlC,EAAS+B,QAC3E,IAAZ/B,IAAsBA,EAAU,QACR,IAAxB+B,IAAkCA,GAAsB,GAC5D,IAAIpa,EAAY/O,KAAKgP,eACjBxO,EAAkBwD,KAAKG,IAAI4K,EAAW/K,KAAKI,IAAI,EAAGilB,IAClD7lB,EAAgBQ,KAAKG,IAAI4K,EAAW/K,KAAKI,IAAI,EAAGklB,IAChD1kB,EAAY5E,KAAKiP,iBAAiBzL,GACtC,OAAOxD,KAAKupB,uBAAuB,IAAI,OAAM/oB,EAAiB,EAAGgD,EAAeoB,GAAYwiB,EAAS+B,IAEzG5P,EAAUrZ,UAAUspB,sBAAwB,SAAUllB,EAAO8iB,EAAS+B,QAClD,IAAZ/B,IAAsBA,EAAU,QACR,IAAxB+B,IAAkCA,GAAsB,GAC5D,IAAIM,EAAiBzpB,KAAK6hB,cAAcvd,GACxC,OAAOtE,KAAKupB,uBAAuBE,EAAgBrC,EAAS+B,IAEhE5P,EAAUrZ,UAAUwpB,4BAA8B,SAAUtC,EAAS+B,QACjD,IAAZ/B,IAAsBA,EAAU,QACR,IAAxB+B,IAAkCA,GAAsB,GAC5D,IAAI1X,EAAYzR,KAAKke,eACjB9X,EAASpG,KAAKmc,iBAAiB0C,OAAOuI,EAAS+B,GAAqB,EAAM1X,GAC9E,OAAOzR,KAAK8e,uBAAuB1Y,IAEvCmT,EAAUrZ,UAAUypB,kBAAoB,SAAUvC,EAAS+B,QACvC,IAAZ/B,IAAsBA,EAAU,QACR,IAAxB+B,IAAkCA,GAAsB,GAC5D,IAAI1X,EAAYzR,KAAKke,eACjB9X,EAASpG,KAAKmc,iBAAiB0C,OAAOuI,EAAS+B,GAAqB,EAAO1X,GAC/E,OAAOzR,KAAK8e,uBAAuB1Y,IAEvCmT,EAAUrZ,UAAUqpB,uBAAyB,SAAUK,EAAaC,EAAeV,GAC/E,IAAIlc,EAAcjN,KAAK6a,QAAQlN,YAAYic,EAAYppB,gBAAiBopB,EAAYjlB,aAChFuI,EAAYlN,KAAK6a,QAAQlN,YAAYic,EAAYpmB,cAAeomB,EAAYhlB,WAC5E6M,EAAYzR,KAAKke,eACjB9X,EAASpG,KAAKmc,iBAAiB2N,eAAe7c,EAAaC,EAAW2c,EAAeV,EAAqB1X,GAC9G,OAAOzR,KAAK8e,uBAAuB1Y,IAEvCmT,EAAUrZ,UAAU4e,uBAAyB,SAAU8J,GACnD,IAAK,IAAIvpB,EAAI,EAAGC,EAAMspB,EAAMrpB,OAAQF,EAAIC,EAAKD,IAAK,CAC9C,IAAI2f,EAAO4J,EAAMvpB,GACE,OAAf2f,EAAK1a,QACL0a,EAAK1a,MAAQtE,KAAKipB,YAAYjK,EAAKC,oBAAqBD,EAAKE,oBAGrE,OAAO0J,GAEXrP,EAAUrZ,UAAU+oB,YAAc,SAAUhhB,EAAOmX,GAC/C,OAAOpf,KAAK6a,QAAQkP,WAAW9hB,EAAOmX,EAAMnX,IAEhDsR,EAAUrZ,UAAUynB,sBAAwB,SAAUoB,EAAczF,GAChE,IAAItE,EAAOhf,KAAKkc,aAAa6M,GAC7B,GAAK/J,EAAL,CAGA,IAAI1a,EAAQtE,KAAKkiB,mCAAmCoB,GAChDrW,EAAcjN,KAAK6a,QAAQlN,YAAYrJ,EAAM9D,gBAAiB8D,EAAMK,aACpEuI,EAAYlN,KAAK6a,QAAQlN,YAAYrJ,EAAMd,cAAec,EAAMM,WACpE5E,KAAKmc,iBAAiBqM,OAAOxJ,GAC7BA,EAAKhR,MAAMhO,KAAKke,eAAgBjR,EAAaC,EAAW5I,GACxDtE,KAAKmc,iBAAiBuM,OAAO1J,KAEjCzF,EAAUrZ,UAAU2nB,6BAA+B,SAAUkB,EAAcpM,GACvE,IAAIqC,EAAOhf,KAAKkc,aAAa6M,GAC7B,GAAK/J,EAAL,CAGA,IAAIgL,KAA0BhL,EAAKrC,QAAQsN,gBAAiBjL,EAAKrC,QAAQsN,cAAcC,OACnFC,KAAyBxN,EAAQsN,gBAAiBtN,EAAQsN,cAAcC,OACxEF,IAA2BG,GAE3BnqB,KAAKmc,iBAAiBqM,OAAOxJ,GAC7BA,EAAKyJ,WAAW9L,GAChB3c,KAAKmc,iBAAiBuM,OAAO1J,IAG7BA,EAAKyJ,WAAW9L,KAGxBpD,EAAUrZ,UAAUsnB,sBAAwB,SAAUJ,EAASgD,EAAmBlC,GAC9E,IAAIzW,EAAYzR,KAAKke,eACjBmM,EAAoBD,EAAkB7qB,OACtC+qB,EAAqB,EACrBC,EAAoBrC,EAAe3oB,OACnCirB,EAAqB,EACrBpkB,EAAS,IAAI4M,MAAMuX,GACvB,MAAOD,EAAqBD,GAAqBG,EAAqBD,EAAmB,CACrF,IAAIvL,EAAO,KACX,GAAIsL,EAAqBD,EAAmB,CAExC,GACIrL,EAAOhf,KAAKkc,aAAakO,EAAkBE,aACrCtL,GAAQsL,EAAqBD,GAEnCrL,GACAhf,KAAKmc,iBAAiBqM,OAAOxJ,GAGrC,GAAIwL,EAAqBD,EAAmB,CAExC,IAAKvL,EAAM,CACP,IAAIyL,IAA0BzqB,KAAKic,kBAC/B8M,EAAe/oB,KAAK+b,YAAc,IAAM0O,EAC5CzL,EAAO,IAAI,OAAa+J,EAAc,EAAG,GACzC/oB,KAAKkc,aAAa6M,GAAgB/J,EAGtC,IAAI0L,EAAgBxC,EAAesC,GAC/BlmB,EAAQtE,KAAKkiB,mCAAmCwI,EAAcpmB,OAC9DqY,EAAUmL,GAAkB4C,EAAc/N,SAC1C1P,EAAcjN,KAAK6a,QAAQlN,YAAYrJ,EAAM9D,gBAAiB8D,EAAMK,aACpEuI,EAAYlN,KAAK6a,QAAQlN,YAAYrJ,EAAMd,cAAec,EAAMM,WACpEoa,EAAKoI,QAAUA,EACfpI,EAAKhR,MAAMyD,EAAWxE,EAAaC,EAAW5I,GAC9C0a,EAAKyJ,WAAW9L,GAChB3c,KAAKmc,iBAAiBuM,OAAO1J,GAC7B5Y,EAAOokB,GAAsBxL,EAAKtG,GAClC8R,SAGIxL,UACOhf,KAAKkc,aAAa8C,EAAKtG,IAI1C,OAAOtS,GAIXmT,EAAUrZ,UAAUyqB,cAAgB,SAAUvqB,EAAYH,GACtD,GAAIG,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpBrC,KAAKY,QAAQ2H,UAAUvI,KAAK4b,oBAAoBlD,GAAItY,EAAa,EAAGJ,KAAK6a,QAAQhD,cAAczX,GAAaH,IAEhHsZ,EAAUrZ,UAAUqI,UAAY,SAAUtI,GACtC,GAAsB,IAAlBA,EAAOV,OAAX,CAIA,IADA,IAAIqrB,EAAS,GACJvrB,EAAI,EAAGC,EAAMW,EAAOV,OAAQF,EAAIC,EAAKD,IAAK,CAC/C,IAAIwrB,EAAU5qB,EAAOZ,GACrBurB,EAAOnqB,KAAK,CAAE0Q,eAAgB0Z,EAAQrqB,gBAAiB4Q,aAAcyZ,EAAQrqB,gBAAkBqqB,EAAQ5qB,OAAOV,OAAS,IACvH,IAAK,IAAI0V,EAAI,EAAG6P,EAAO+F,EAAQ5qB,OAAOV,OAAQ0V,EAAI6P,EAAM7P,IACpDjV,KAAK2qB,cAAcE,EAAQrqB,gBAAkByU,EAAG4V,EAAQ5qB,OAAOgV,IAGvEjV,KAAK8qB,6BAA6B,CAC9BC,4BAA4B,EAC5BH,OAAQA,MAGhBrR,EAAUrZ,UAAU8qB,kBAAoB,SAAU/qB,GAC9CD,KAAKwc,SAAS9W,IAAIzF,GAClBD,KAAK8qB,6BAA6B,CAC9BC,4BAA4B,EAC5BH,OAAQ,CAAC,CAAEzZ,eAAgB,EAAGC,aAAcpR,KAAKgP,oBAGzDuK,EAAUrZ,UAAUoX,iBAAmB,SAAU9W,EAAiBgD,GAC9DhD,EAAkBwD,KAAKI,IAAI,EAAG5D,GAC9BgD,EAAgBQ,KAAKG,IAAInE,KAAK6a,QAAQ7L,eAAgBxL,GACtDxD,KAAKyc,cAAcnF,iBAAiB9W,EAAiBgD,IAEzD+V,EAAUrZ,UAAUiW,YAAc,WAC9BnW,KAAKY,QAAQ6E,QACbzF,KAAK8qB,6BAA6B,CAC9BC,4BAA4B,EAC5BH,OAAQ,CAAC,CACDzZ,eAAgB,EAChBC,aAAcpR,KAAK6a,QAAQ7L,oBAI3CuK,EAAUrZ,UAAU4qB,6BAA+B,SAAUjV,GACpD7V,KAAK2b,cACN3b,KAAKma,mBAAmB2B,KAAKjG,IAGrC0D,EAAUrZ,UAAU+qB,kBAAoB,WACpCjrB,KAAKyc,cAAczO,SAEvBuL,EAAUrZ,UAAUsX,kBAAoB,SAAUpX,GAC9C,GAAIA,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpBrC,KAAKyc,cAAcjF,kBAAkBpX,IAEzCmZ,EAAUrZ,UAAUwX,kBAAoB,SAAUtX,GAC9C,OAAOJ,KAAKyc,cAAc/E,kBAAkBtX,IAEhDmZ,EAAUrZ,UAAUgrB,gBAAkB,SAAU9qB,GACxCJ,KAAK0X,kBAAkBtX,IACvBJ,KAAKwX,kBAAkBpX,IAG/BmZ,EAAUrZ,UAAUwD,cAAgB,SAAUtD,GAC1C,GAAIA,EAAa,GAAKA,EAAaJ,KAAKgP,eACpC,MAAM,IAAI3M,MAAM,gCAEpB,OAAOrC,KAAKmrB,eAAe/qB,IAE/BmZ,EAAUrZ,UAAUirB,eAAiB,SAAU/qB,GAC3C,IAAIkH,EAAWtH,KAAK+G,eAAe3G,GAC/BgrB,EAAkBprB,KAAKY,QAAQyG,UAAUrH,KAAK4b,oBAAoBlD,GAAItY,EAAa,EAAGkH,GAC1F,OAAOtH,KAAKwc,SAAS5W,kBAAkBxF,EAAYgrB,IAEvD7R,EAAUrZ,UAAU6V,sBAAwB,WACxC,OAAO/V,KAAK4b,qBAEhBrC,EAAUrZ,UAAUmrB,UAAY,WAC5B,OAAOrrB,KAAK4b,oBAAoB3F,UAEpCsD,EAAUrZ,UAAUorB,QAAU,SAAUxV,GACpC,GAAI9V,KAAK4b,oBAAoBlD,KAAO5C,EAAmB4C,GAAvD,CAIA,IAAI7C,EAAI,CACJ0V,YAAavrB,KAAK4b,oBAAoB3F,SACtCuV,YAAa1V,EAAmBG,UAEpCjW,KAAK4b,oBAAsB9F,EAC3B9V,KAAKga,qBAAqB8B,KAAKjG,GAC/B7V,KAAKia,kCAAkC6B,KAAK,MAEhDvC,EAAUrZ,UAAUurB,wBAA0B,SAAUrrB,EAAYgF,GAChE,IAAIF,EAAWlF,KAAKgjB,iBAAiB,IAAI,OAAS5iB,EAAYgF,IAC1D/E,EAAaL,KAAK0D,cAAcwB,EAAS9E,YAC7C,OAAOC,EAAWsH,cAActH,EAAWqrB,uBAAuBxmB,EAASE,OAAS,KAGxFmU,EAAUrZ,UAAUyrB,kBAAoB,SAAUC,GAC9C5rB,KAAK0d,qBACL,IAAIxY,EAAWlF,KAAKgjB,iBAAiB4I,GACjCC,EAAc7rB,KAAK+G,eAAe7B,EAAS9E,YAC3CC,EAAaL,KAAKmrB,eAAejmB,EAAS9E,YAC1Cc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GAEjEb,EAAKgV,EAAUuS,wBAAwBzrB,EAAYa,GAAa6qB,EAAgBxnB,EAAG,GAAIynB,EAAcznB,EAAG,GACxG0nB,EAAkB,eAAc/mB,EAASE,OAAQ,OAA8B8mB,kBAAkB7rB,EAAWsH,cAAczG,IAAc2qB,EAAYzd,UAAU2d,EAAeC,GAAcD,GAE/L,GAAIE,GAAmBA,EAAgBtnB,aAAeinB,EAAUxmB,QAAUwmB,EAAUxmB,QAAU6mB,EAAgBrnB,UAC1G,OAAOqnB,EAGX,GAAI/qB,EAAa,GAAK6qB,IAAkB7mB,EAASE,OAAS,EAAG,CAEzD,IAAI+mB,EAAK5S,EAAUuS,wBAAwBzrB,EAAYa,EAAa,GAAIkrB,EAAgBD,EAAG,GAAIE,EAAcF,EAAG,GAC5GG,EAAiB,eAAcpnB,EAASE,OAAQ,OAA8B8mB,kBAAkB7rB,EAAWsH,cAAczG,EAAa,IAAK2qB,EAAYzd,UAAUge,EAAeC,GAAcD,GAElM,GAAIE,GAAkBA,EAAe3nB,aAAeinB,EAAUxmB,QAAUwmB,EAAUxmB,QAAUknB,EAAe1nB,UACvG,OAAO0nB,EAGf,OAAO,MAEX/S,EAAUuS,wBAA0B,SAAUzrB,EAAYa,GAItD,IAHA,IAAIqrB,EAAalsB,EAAWsH,cAAczG,GAEtC+L,EAAc,EACT5N,EAAI6B,EAAY7B,GAAK,GAAKgB,EAAWsH,cAActI,KAAOktB,EAAYltB,IAC3E4N,EAAc5M,EAAWwG,eAAexH,GAI5C,IADA,IAAI6N,EAAY7M,EAAW0G,iBAAiBxH,OACnBwB,GAAhB1B,EAAI6B,EAAyBb,EAAWiD,YAAYjE,EAAI0B,GAAcV,EAAWsH,cAActI,KAAOktB,EAAYltB,IACvH6N,EAAY7M,EAAWuG,aAAavH,GAExC,MAAO,CAAC4N,EAAaC,IAEzBqM,EAAUrZ,UAAUssB,qBAAuB,SAAUtnB,GACjD,IAAIunB,EAAiBzsB,KAAK2rB,kBAAkBzmB,GAC5C,OAAKunB,EAOE,CACHC,KAAMD,EAAeC,KAAKC,OAAO,EAAGznB,EAASE,OAASqnB,EAAe9nB,aACrEA,YAAa8nB,EAAe9nB,YAC5BC,UAAWM,EAASE,QATb,CACHsnB,KAAM,GACN/nB,YAAaO,EAASE,OACtBR,UAAWM,EAASE,SAShCmU,EAAUrZ,UAAU0sB,sBAAwB,SAAUC,EAAUjB,GAC5D,IAAIkB,EAAUD,EAAS3hB,cACnBhG,EAAWlF,KAAKgjB,iBAAiB4I,GACjCvrB,EAAaL,KAAKmrB,eAAejmB,EAAS9E,YAC1CmsB,EAAalsB,EAAWsH,cAActH,EAAWqrB,uBAAuBxmB,EAASE,OAAS,IAC1F2nB,EAAkB,OAA8BC,mBAAmBT,GACvE,IAAKQ,EACD,OAAO,KAEX,IAAIE,EAAOF,EAAgBG,cAAcJ,GACzC,OAAKG,EAGEjtB,KAAKmtB,uBAAuBF,EAAM/nB,GAF9B,MAIfqU,EAAUrZ,UAAUktB,aAAe,SAAUloB,GACzC,OAAOlF,KAAKqtB,cAAcrtB,KAAKgjB,iBAAiB9d,KAEpDqU,EAAUrZ,UAAUmtB,cAAgB,SAAUnoB,GAC1C,IAAI9E,EAAa8E,EAAS9E,WACtBC,EAAaL,KAAKmrB,eAAe/qB,GACjCW,EAAaV,EAAWiD,WACxBgE,EAAWtH,KAAK6a,QAAQ9T,eAAe3G,GACvCc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GACrE,GAAIlE,EAAa,EACb,OAAO,KAEX,IAAIosB,EAAsB,OAA8BN,mBAAmB3sB,EAAWsH,cAAczG,IAEpG,GAAIosB,IAAwB,eAAsBjtB,EAAWktB,qBAAqBrsB,IAAc,CAG5F,IADA,IAAIssB,EAAoBxpB,KAAKI,IAAI,EAAGc,EAASE,OAAS,EAAIkoB,EAAoBG,kBACrEpuB,EAAI6B,EAAa,EAAG7B,GAAK,EAAGA,IAAK,CACtC,IAAIoK,EAAiBpJ,EAAWuG,aAAavH,GAC7C,GAAIoK,GAAkB+jB,EAClB,MAEA,eAAsBntB,EAAWktB,qBAAqBluB,MACtDmuB,EAAoB/jB,GAI5B,IAAIikB,EAAkB1pB,KAAKG,IAAImD,EAAS/H,OAAQ2F,EAASE,OAAS,EAAIkoB,EAAoBG,kBAGtF5d,EAAa,KACjB,MAAO,EAAM,CACT,IAAI8d,EAAe,OAAcC,uBAAuBN,EAAoBO,aAAcztB,EAAYkH,EAAUkmB,EAAmBE,GACnI,IAAKC,EAED,MAGJ,GAAIA,EAAahpB,aAAeO,EAASE,QAAUF,EAASE,QAAUuoB,EAAa/oB,UAAW,CAC1F,IAAIkpB,EAAmBxmB,EAAS8G,UAAUuf,EAAahpB,YAAc,EAAGgpB,EAAa/oB,UAAY,GAAGsG,cAChGgE,EAAIlP,KAAK+tB,mBAAmBJ,EAAcL,EAAoBJ,cAAcY,GAAmBR,EAAoBU,kBAAkBF,IACrI5e,IACAW,EAAaX,GAGrBse,EAAoBG,EAAa/oB,UAAY,EAEjD,GAAIiL,EACA,OAAOA,EAIf,GAAI3O,EAAa,GAAKb,EAAWwG,eAAe3F,KAAgBgE,EAASE,OAAS,EAAG,CACjF,IAAI6oB,EAAiB/sB,EAAa,EAC9BgtB,EAAmB,OAA8BlB,mBAAmB3sB,EAAWsH,cAAcsmB,IAEjG,GAAIC,IAAqB,eAAsB7tB,EAAWktB,qBAAqBU,IAAkB,CAI7F,IAFIT,EAAoBxpB,KAAKI,IAAI,EAAGc,EAASE,OAAS,EAAI8oB,EAAiBT,kBACvEC,EAAkB1pB,KAAKG,IAAImD,EAAS/H,OAAQ2F,EAASE,OAAS,EAAI8oB,EAAiBT,kBAC9EpuB,EAAI4uB,EAAiB,EAAG5uB,EAAI0B,EAAY1B,IAAK,CAClD,IAAI8uB,EAAmB9tB,EAAWwG,eAAexH,GACjD,GAAI8uB,GAAoBT,EACpB,MAEA,eAAsBrtB,EAAWktB,qBAAqBluB,MACtDquB,EAAkBS,GAGtBR,EAAe,OAAcS,uBAAuBF,EAAiBG,cAAejuB,EAAYkH,EAAUkmB,EAAmBE,GAEjI,GAAIC,GAAgBA,EAAahpB,aAAeO,EAASE,QAAUF,EAASE,QAAUuoB,EAAa/oB,UAAW,CACtGkpB,EAAmBxmB,EAAS8G,UAAUuf,EAAahpB,YAAc,EAAGgpB,EAAa/oB,UAAY,GAAGsG,cAChGgE,EAAIlP,KAAK+tB,mBAAmBJ,EAAcO,EAAiBhB,cAAcY,GAAmBI,EAAiBF,kBAAkBF,IACnI,GAAI5e,EACA,OAAOA,IAKvB,OAAO,MAEXqK,EAAUrZ,UAAU6tB,mBAAqB,SAAUJ,EAAcV,EAAMqB,GACnE,IAAKrB,EACD,OAAO,KAEX,GAAIqB,EAAQ,CACR,IAAIC,EAAUvuB,KAAKwuB,yBAAyBvB,EAAMU,EAAac,kBAC/D,GAAIF,EACA,MAAO,CAACZ,EAAcY,OAGzB,CACGA,EAAUvuB,KAAKmtB,uBAAuBF,EAAMU,EAAa/f,oBAC7D,GAAI2gB,EACA,MAAO,CAACZ,EAAcY,GAG9B,OAAO,MAEXhV,EAAUrZ,UAAUitB,uBAAyB,SAAUL,EAAS5nB,GAyB5D,IAvBA,IAAIqnB,EAAaO,EAAQhX,mBAAmB4C,GACxCgW,EAAuB5B,EAAQuB,cAC/BM,GAAS,EACTC,EAAmC,SAAUxuB,EAAYkH,EAAUkmB,EAAmBE,GACtF,MAAO,EAAM,CACT,IAAIxe,EAAI,OAAckf,uBAAuBM,EAAsBtuB,EAAYkH,EAAUkmB,EAAmBE,GAC5G,IAAKxe,EACD,MAEJ,IAAI2f,EAAUvnB,EAAS8G,UAAUc,EAAEvK,YAAc,EAAGuK,EAAEtK,UAAY,GAAGsG,cAOrE,GANI4hB,EAAQwB,OAAOO,GACfF,IAEK7B,EAAQgC,QAAQD,IACrBF,IAEU,IAAVA,EACA,OAAOzf,EAEXwe,EAAkBxe,EAAEvK,YAAc,EAEtC,OAAO,MAEFvE,EAAa8E,EAAS9E,WAAYA,GAAc,EAAGA,IAAc,CACtE,IAAIC,EAAaL,KAAKmrB,eAAe/qB,GACjCW,EAAaV,EAAWiD,WACxBgE,EAAWtH,KAAK6a,QAAQ9T,eAAe3G,GACvCc,EAAaH,EAAa,EAC1BysB,EAAoBlmB,EAAS/H,OAC7BmuB,EAAkBpmB,EAAS/H,OAC3Ba,IAAe8E,EAAS9E,aACxBc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GACjEooB,EAAoBtoB,EAASE,OAAS,EACtCsoB,EAAkBxoB,EAASE,OAAS,GAGxC,IADA,IAAI2pB,GAAoB,EACjB7tB,GAAc,EAAGA,IAAc,CAClC,IAAI8tB,EAAiB3uB,EAAWsH,cAAczG,KAAgBqrB,IAAe,eAAsBlsB,EAAWktB,qBAAqBrsB,IACnI,GAAI8tB,EAEID,EAEAvB,EAAoBntB,EAAWwG,eAAe3F,IAI9CssB,EAAoBntB,EAAWwG,eAAe3F,GAC9CwsB,EAAkBrtB,EAAWuG,aAAa1F,SAK9C,GAAI6tB,GAAqBvB,IAAsBE,EAAiB,CAC5D,IAAIxe,EAAI0f,EAAiCxuB,EAAYkH,EAAUkmB,EAAmBE,GAClF,GAAIxe,EACA,OAAOA,EAInB6f,EAAoBC,EAExB,GAAID,GAAqBvB,IAAsBE,EAAiB,CACxDxe,EAAI0f,EAAiCxuB,EAAYkH,EAAUkmB,EAAmBE,GAClF,GAAIxe,EACA,OAAOA,GAInB,OAAO,MAEXqK,EAAUrZ,UAAUsuB,yBAA2B,SAAU1B,EAAS5nB,GA0B9D,IAxBA,IAAIqnB,EAAaO,EAAQhX,mBAAmB4C,GACxCuW,EAAenC,EAAQe,aACvBc,EAAQ,EACRO,EAAmC,SAAU9uB,EAAYkH,EAAUkmB,EAAmBE,GACtF,MAAO,EAAM,CACT,IAAIxe,EAAI,OAAc0e,uBAAuBqB,EAAc7uB,EAAYkH,EAAUkmB,EAAmBE,GACpG,IAAKxe,EACD,MAEJ,IAAI2f,EAAUvnB,EAAS8G,UAAUc,EAAEvK,YAAc,EAAGuK,EAAEtK,UAAY,GAAGsG,cAOrE,GANI4hB,EAAQwB,OAAOO,GACfF,IAEK7B,EAAQgC,QAAQD,IACrBF,IAEU,IAAVA,EACA,OAAOzf,EAEXse,EAAoBte,EAAEtK,UAAY,EAEtC,OAAO,MAEPmK,EAAY/O,KAAKgP,eACZ5O,EAAa8E,EAAS9E,WAAYA,GAAc2O,EAAW3O,IAAc,CAC9E,IAAIC,EAAaL,KAAKmrB,eAAe/qB,GACjCW,EAAaV,EAAWiD,WACxBgE,EAAWtH,KAAK6a,QAAQ9T,eAAe3G,GACvCc,EAAa,EACbssB,EAAoB,EACpBE,EAAkB,EAClBttB,IAAe8E,EAAS9E,aACxBc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GACjEooB,EAAoBtoB,EAASE,OAAS,EACtCsoB,EAAkBxoB,EAASE,OAAS,GAGxC,IADA,IAAI2pB,GAAoB,EACjB7tB,EAAaH,EAAYG,IAAc,CAC1C,IAAI8tB,EAAiB3uB,EAAWsH,cAAczG,KAAgBqrB,IAAe,eAAsBlsB,EAAWktB,qBAAqBrsB,IACnI,GAAI8tB,EAEID,IAMAvB,EAAoBntB,EAAWwG,eAAe3F,IAJ9CwsB,EAAkBrtB,EAAWuG,aAAa1F,QAU9C,GAAI6tB,GAAqBvB,IAAsBE,EAAiB,CAC5D,IAAIxe,EAAIggB,EAAiC9uB,EAAYkH,EAAUkmB,EAAmBE,GAClF,GAAIxe,EACA,OAAOA,EAInB6f,EAAoBC,EAExB,GAAID,GAAqBvB,IAAsBE,EAAiB,CACxDxe,EAAIggB,EAAiC9uB,EAAYkH,EAAUkmB,EAAmBE,GAClF,GAAIxe,EACA,OAAOA,GAInB,OAAO,MAEXqK,EAAUrZ,UAAUivB,gBAAkB,SAAUvD,GAI5C,IAHA,IAAI1mB,EAAWlF,KAAKgjB,iBAAiB4I,GACjCW,GAAc,EACd6C,EAAe,KACVhvB,EAAa8E,EAAS9E,WAAYA,GAAc,EAAGA,IAAc,CACtE,IAAIC,EAAaL,KAAKmrB,eAAe/qB,GACjCW,EAAaV,EAAWiD,WACxBgE,EAAWtH,KAAK6a,QAAQ9T,eAAe3G,GACvCc,EAAaH,EAAa,EAC1BysB,EAAoBlmB,EAAS/H,OAC7BmuB,EAAkBpmB,EAAS/H,OAC/B,GAAIa,IAAe8E,EAAS9E,WAAY,CACpCc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GACjEooB,EAAoBtoB,EAASE,OAAS,EACtCsoB,EAAkBxoB,EAASE,OAAS,EACpC,IAAIiqB,EAAkBhvB,EAAWsH,cAAczG,GAC3CqrB,IAAe8C,IACf9C,EAAa8C,EACbD,EAAe,OAA8BpC,mBAAmBT,IAIxE,IADA,IAAIwC,GAAoB,EACjB7tB,GAAc,EAAGA,IAAc,CAC9BmuB,EAAkBhvB,EAAWsH,cAAczG,GAC/C,GAAIqrB,IAAe8C,EAAiB,CAEhC,GAAID,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CAC5E,IAAIxe,EAAI,OAAckf,uBAAuBgB,EAAaf,cAAejuB,EAAYkH,EAAUkmB,EAAmBE,GAClH,GAAIxe,EACA,OAAOlP,KAAKsvB,gBAAgBF,EAAclgB,GAE9C6f,GAAoB,EAExBxC,EAAa8C,EACbD,EAAe,OAA8BpC,mBAAmBT,GAEpE,IAAIyC,IAAmBI,IAAiB,eAAsB/uB,EAAWktB,qBAAqBrsB,IAC9F,GAAI8tB,EAEID,EAEAvB,EAAoBntB,EAAWwG,eAAe3F,IAI9CssB,EAAoBntB,EAAWwG,eAAe3F,GAC9CwsB,EAAkBrtB,EAAWuG,aAAa1F,SAK9C,GAAIkuB,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CACxExe,EAAI,OAAckf,uBAAuBgB,EAAaf,cAAejuB,EAAYkH,EAAUkmB,EAAmBE,GAClH,GAAIxe,EACA,OAAOlP,KAAKsvB,gBAAgBF,EAAclgB,GAItD6f,EAAoBC,EAExB,GAAII,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CACxExe,EAAI,OAAckf,uBAAuBgB,EAAaf,cAAejuB,EAAYkH,EAAUkmB,EAAmBE,GAClH,GAAIxe,EACA,OAAOlP,KAAKsvB,gBAAgBF,EAAclgB,IAItD,OAAO,MAEXqK,EAAUrZ,UAAUqvB,gBAAkB,SAAU3D,GAK5C,IAJA,IAAI1mB,EAAWlF,KAAKgjB,iBAAiB4I,GACjC7c,EAAY/O,KAAKgP,eACjBud,GAAc,EACd6C,EAAe,KACVhvB,EAAa8E,EAAS9E,WAAYA,GAAc2O,EAAW3O,IAAc,CAC9E,IAAIC,EAAaL,KAAKmrB,eAAe/qB,GACjCW,EAAaV,EAAWiD,WACxBgE,EAAWtH,KAAK6a,QAAQ9T,eAAe3G,GACvCc,EAAa,EACbssB,EAAoB,EACpBE,EAAkB,EACtB,GAAIttB,IAAe8E,EAAS9E,WAAY,CACpCc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GACjEooB,EAAoBtoB,EAASE,OAAS,EACtCsoB,EAAkBxoB,EAASE,OAAS,EACpC,IAAIiqB,EAAkBhvB,EAAWsH,cAAczG,GAC3CqrB,IAAe8C,IACf9C,EAAa8C,EACbD,EAAe,OAA8BpC,mBAAmBT,IAIxE,IADA,IAAIwC,GAAoB,EACjB7tB,EAAaH,EAAYG,IAAc,CACtCmuB,EAAkBhvB,EAAWsH,cAAczG,GAC/C,GAAIqrB,IAAe8C,EAAiB,CAEhC,GAAID,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CAC5E,IAAIxe,EAAI,OAAc0e,uBAAuBwB,EAAavB,aAAcztB,EAAYkH,EAAUkmB,EAAmBE,GACjH,GAAIxe,EACA,OAAOlP,KAAKsvB,gBAAgBF,EAAclgB,GAE9C6f,GAAoB,EAExBxC,EAAa8C,EACbD,EAAe,OAA8BpC,mBAAmBT,GAEpE,IAAIyC,IAAmBI,IAAiB,eAAsB/uB,EAAWktB,qBAAqBrsB,IAC9F,GAAI8tB,EAEID,IAMAvB,EAAoBntB,EAAWwG,eAAe3F,IAJ9CwsB,EAAkBrtB,EAAWuG,aAAa1F,QAU9C,GAAIkuB,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CACxExe,EAAI,OAAc0e,uBAAuBwB,EAAavB,aAAcztB,EAAYkH,EAAUkmB,EAAmBE,GACjH,GAAIxe,EACA,OAAOlP,KAAKsvB,gBAAgBF,EAAclgB,GAItD6f,EAAoBC,EAExB,GAAII,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CACxExe,EAAI,OAAc0e,uBAAuBwB,EAAavB,aAAcztB,EAAYkH,EAAUkmB,EAAmBE,GACjH,GAAIxe,EACA,OAAOlP,KAAKsvB,gBAAgBF,EAAclgB,IAItD,OAAO,MAEXqK,EAAUrZ,UAAUsvB,sBAAwB,SAAU5D,EAAW6D,GAC7D,IAAIpa,EAAQrV,UACQ,IAAhByvB,IAA0BA,EAAc,YAyC5C,IAxCA,IAAIvqB,EAAWlF,KAAKgjB,iBAAiB4I,GACjC7c,EAAY/O,KAAKgP,eACjB0gB,EAAc,IAAIC,IAClBC,EAAS,GACTC,EAAc,SAAUtD,EAAY6C,GACpC,IAAKM,EAAYI,IAAIvD,GAAa,CAE9B,IADA,IAAI7iB,EAAM,GACDrK,EAAI,EAAGC,EAAM8vB,EAAeA,EAAaW,SAASxwB,OAAS,EAAGF,EAAIC,EAAKD,IAC5EqK,EAAIrK,GAAK,EAEbqwB,EAAYhqB,IAAI6mB,EAAY7iB,GAEhCkmB,EAASF,EAAYxf,IAAIqc,IAEzByD,EAAgB,SAAUZ,EAAchvB,EAAYkH,EAAUkmB,EAAmBE,GACjF,MAAO,EAAM,CACT,IAAIxe,EAAI,OAAc0e,uBAAuBwB,EAAavB,aAAcztB,EAAYkH,EAAUkmB,EAAmBE,GACjH,IAAKxe,EACD,MAEJ,IAAI2f,EAAUvnB,EAAS8G,UAAUc,EAAEvK,YAAc,EAAGuK,EAAEtK,UAAY,GAAGsG,cACjE4hB,EAAUsC,EAAalC,cAAc2B,GACzC,GAAI/B,IACIA,EAAQwB,OAAOO,GACfe,EAAO9C,EAAQ5e,SAEV4e,EAAQgC,QAAQD,IACrBe,EAAO9C,EAAQ5e,UAEY,IAA3B0hB,EAAO9C,EAAQ5e,QACf,OAAOmH,EAAM0Y,mBAAmB7e,EAAG4d,GAAS,GAGpDU,EAAoBte,EAAEtK,UAAY,EAEtC,OAAO,MAEP2nB,GAAc,EACd6C,EAAe,KACfa,EAAYC,KAAKC,MACZ/vB,EAAa8E,EAAS9E,WAAYA,GAAc2O,EAAW3O,IAAc,CAC9E,IAAIgwB,EAAcF,KAAKC,MAAQF,EAC/B,GAAIG,EAAcX,EACd,OAAO,KAEX,IAAIpvB,EAAaL,KAAKmrB,eAAe/qB,GACjCW,EAAaV,EAAWiD,WACxBgE,EAAWtH,KAAK6a,QAAQ9T,eAAe3G,GACvCc,EAAa,EACbssB,EAAoB,EACpBE,EAAkB,EACtB,GAAIttB,IAAe8E,EAAS9E,WAAY,CACpCc,EAAab,EAAWqrB,uBAAuBxmB,EAASE,OAAS,GACjEooB,EAAoBtoB,EAASE,OAAS,EACtCsoB,EAAkBxoB,EAASE,OAAS,EACpC,IAAIiqB,EAAkBhvB,EAAWsH,cAAczG,GAC3CqrB,IAAe8C,IACf9C,EAAa8C,EACbD,EAAe,OAA8BpC,mBAAmBT,GAChEsD,EAAYtD,EAAY6C,IAIhC,IADA,IAAIL,GAAoB,EACjB7tB,EAAaH,EAAYG,IAAc,CACtCmuB,EAAkBhvB,EAAWsH,cAAczG,GAC/C,GAAIqrB,IAAe8C,EAAiB,CAEhC,GAAID,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CAC5E,IAAIxe,EAAI8gB,EAAcZ,EAAchvB,EAAYkH,EAAUkmB,EAAmBE,GAC7E,GAAIxe,EACA,OAAOA,EAEX6f,GAAoB,EAExBxC,EAAa8C,EACbD,EAAe,OAA8BpC,mBAAmBT,GAChEsD,EAAYtD,EAAY6C,GAE5B,IAAIJ,IAAmBI,IAAiB,eAAsB/uB,EAAWktB,qBAAqBrsB,IAC9F,GAAI8tB,EAEID,IAMAvB,EAAoBntB,EAAWwG,eAAe3F,IAJ9CwsB,EAAkBrtB,EAAWuG,aAAa1F,QAU9C,GAAIkuB,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CACxExe,EAAI8gB,EAAcZ,EAAchvB,EAAYkH,EAAUkmB,EAAmBE,GAC7E,GAAIxe,EACA,OAAOA,EAInB6f,EAAoBC,EAExB,GAAII,GAAgBL,GAAqBvB,IAAsBE,EAAiB,CACxExe,EAAI8gB,EAAcZ,EAAchvB,EAAYkH,EAAUkmB,EAAmBE,GAC7E,GAAIxe,EACA,OAAOA,GAInB,OAAO,MAEXqK,EAAUrZ,UAAUovB,gBAAkB,SAAUF,EAAclgB,GAC1D,IAAKA,EACD,OAAO,KAEX,IAAIjQ,EAAOe,KAAK6N,gBAAgBqB,GAChCjQ,EAAOA,EAAKiM,cACZ,IAAI+hB,EAAOmC,EAAalC,cAAcjuB,GACtC,OAAKguB,EAGE,CACH3oB,MAAO4K,EACPmhB,KAAMpD,EAAKoD,KACXC,MAAOrD,EAAKqD,MACZhC,OAAQc,EAAapB,kBAAkB/uB,IANhC,MAcfsa,EAAUgX,mBAAqB,SAAUC,EAAMvT,GAC3C,IAAIwT,EAAS,EACTpxB,EAAI,EACJC,EAAMkxB,EAAKjxB,OACf,MAAOF,EAAIC,EAAK,CACZ,IAAI+L,EAASmlB,EAAK/wB,WAAWJ,GAC7B,GAAe,KAAXgM,EACAolB,QAEC,IAAe,IAAXplB,EAIL,MAHAolB,EAASA,EAASA,EAASxT,EAAUA,EAKzC5d,IAEJ,OAAIA,IAAMC,GACE,EAELmxB,GAEXlX,EAAUrZ,UAAUwwB,oBAAsB,SAAUvrB,GAChD,OAAOoU,EAAUgX,mBAAmBvwB,KAAK6a,QAAQ9T,eAAe5B,EAAY,GAAInF,KAAK8a,SAASmC,UAElG1D,EAAUrZ,UAAUywB,qBAAuB,SAAUvwB,EAAYwwB,EAAeC,GAC5E,IAAIxb,EAAQrV,KACZA,KAAK0d,qBACL,IAAI3O,EAAY/O,KAAKgP,eACrB,GAAI5O,EAAa,GAAKA,EAAa2O,EAC/B,MAAM,IAAI1M,MAAM,gCAyEpB,IAvEA,IAAIyuB,EAAe,OAA8BC,gBAAgB/wB,KAAK4b,oBAAoBlD,IACtFsY,EAAUC,QAAQH,GAAgBA,EAAaE,SAC/CE,GAA4B,EAC5BC,GAA6B,EAC7BC,GAA4B,EAC5BC,GAA6B,EAC7BC,EAAoB,SAAUlxB,GAC9B,IAAkC,IAA9B8wB,KAAkE,IAA9BA,GAAmCA,EAA2B9wB,EAAa,GAAI,CACnH8wB,GAA4B,EAC5BC,GAA6B,EAE7B,IAAK,IAAIhsB,EAAY/E,EAAa,EAAG+E,GAAa,EAAGA,IAAa,CAC9D,IAAIosB,EAAWlc,EAAMqb,oBAAoBvrB,GACzC,GAAIosB,GAAY,EAAG,CACfL,EAA2B/rB,EAC3BgsB,EAA4BI,EAC5B,QAIZ,IAAkC,IAA9BH,EAAiC,CACjCA,GAA4B,EAC5BC,GAA6B,EAE7B,IAASlsB,EAAY/E,EAAY+E,EAAY4J,EAAW5J,IAAa,CACjE,IAAIqsB,EAAWnc,EAAMqb,oBAAoBvrB,GACzC,GAAIqsB,GAAY,EAAG,CACfJ,EAA2BjsB,EAC3BksB,EAA4BG,EAC5B,UAKZC,GAA8B,EAC9BC,GAA+B,EAC/BC,GAA8B,EAC9BC,GAA+B,EAC/BC,EAAsB,SAAUzxB,GAChC,IAAoC,IAAhCqxB,EAAmC,CACnCA,GAA8B,EAC9BC,GAA+B,EAE/B,IAAK,IAAIvsB,EAAY/E,EAAa,EAAG+E,GAAa,EAAGA,IAAa,CAC9D,IAAI2sB,EAAWzc,EAAMqb,oBAAoBvrB,GACzC,GAAI2sB,GAAY,EAAG,CACfL,EAA6BtsB,EAC7BusB,EAA8BI,EAC9B,QAIZ,IAAoC,IAAhCH,KAAsE,IAAhCA,GAAqCA,EAA6BvxB,EAAa,GAAI,CACzHuxB,GAA8B,EAC9BC,GAA+B,EAE/B,IAASzsB,EAAY/E,EAAY+E,EAAY4J,EAAW5J,IAAa,CACjE,IAAI4sB,EAAW1c,EAAMqb,oBAAoBvrB,GACzC,GAAI4sB,GAAY,EAAG,CACfJ,EAA6BxsB,EAC7BysB,EAA8BG,EAC9B,UAKZvxB,EAAkB,EAClBwxB,GAAO,EACPxuB,EAAgB,EAChByuB,GAAS,EACTxB,EAAS,EACJyB,EAAW,EAAGF,GAAQC,EAAQC,IAAY,CAC/C,IAAIC,EAAe/xB,EAAa8xB,EAC5BE,EAAiBhyB,EAAa8xB,EAYlC,GAXiB,IAAbA,IAAmBC,EAAe,GAAKA,EAAevB,KACtDoB,GAAO,GAEM,IAAbE,IAAmBE,EAAiBrjB,GAAaqjB,EAAiBvB,KAClEoB,GAAS,GAETC,EAAW,MAEXF,GAAO,EACPC,GAAS,GAETD,EAAM,CAEN,IAAIK,OAAoB,EACpBC,EAAgBtyB,KAAK0wB,oBAAoByB,EAAe,GAY5D,GAXIG,GAAiB,GAGjBlB,EAA2Be,EAAe,EAC1Cd,EAA4BiB,EAC5BD,EAAoBruB,KAAKuuB,KAAKD,EAAgBtyB,KAAK8a,SAASqC,cAG5DmU,EAAkBa,GAClBE,EAAoBryB,KAAKwyB,iCAAiCxB,EAASG,EAA2BE,IAEjF,IAAba,EAAgB,CAKhB,GAHA1xB,EAAkB2xB,EAClB3uB,EAAgB4uB,EAChB3B,EAAS4B,EACM,IAAX5B,EAEA,MAAO,CAAEjwB,gBAAiBA,EAAiBgD,cAAeA,EAAeitB,OAAQA,GAErF,SAEA4B,GAAqB5B,EACrBjwB,EAAkB2xB,EAGlBH,GAAO,EAGf,GAAIC,EAAQ,CAER,IAAIQ,OAAsB,EACtBH,EAAgBtyB,KAAK0wB,oBAAoB0B,EAAiB,GAC1DE,GAAiB,GAGjBb,EAA6BW,EAAiB,EAC9CV,EAA8BY,EAC9BG,EAAsBzuB,KAAKuuB,KAAKD,EAAgBtyB,KAAK8a,SAASqC,cAG9D0U,EAAoBO,GACpBK,EAAsBzyB,KAAKwyB,iCAAiCxB,EAASU,EAA6BE,IAElGa,GAAuBhC,EACvBjtB,EAAgB4uB,EAGhBH,GAAS,GAIrB,MAAO,CAAEzxB,gBAAiBA,EAAiBgD,cAAeA,EAAeitB,OAAQA,IAErFlX,EAAUrZ,UAAUwyB,qBAAuB,SAAUlyB,EAAiBgD,GAClExD,KAAK0d,qBACL,IAAI3O,EAAY/O,KAAKgP,eACrB,GAAIxO,EAAkB,GAAKA,EAAkBuO,EACzC,MAAM,IAAI1M,MAAM,qCAEpB,GAAImB,EAAgB,GAAKA,EAAgBuL,EACrC,MAAM,IAAI1M,MAAM,mCASpB,IAPA,IAAIyuB,EAAe,OAA8BC,gBAAgB/wB,KAAK4b,oBAAoBlD,IACtFsY,EAAUC,QAAQH,GAAgBA,EAAaE,SAC/C5qB,EAAS,IAAI4M,MAAMxP,EAAgBhD,EAAkB,GACrDmyB,GAAyB,EACzBC,GAA0B,EAC1BC,GAAyB,EACzBC,GAA0B,EACrB1yB,EAAaI,EAAiBJ,GAAcoD,EAAepD,IAAc,CAC9E,IAAI2yB,EAAc3yB,EAAaI,EAC3B8xB,EAAgBtyB,KAAK0wB,oBAAoBtwB,EAAa,GAC1D,GAAIkyB,GAAiB,EAGjBK,EAAwBvyB,EAAa,EACrCwyB,EAAyBN,EACzBlsB,EAAO2sB,GAAe/uB,KAAKuuB,KAAKD,EAAgBtyB,KAAK8a,SAASqC,gBALlE,CAQA,IAA+B,IAA3BwV,EAA8B,CAC9BA,GAAyB,EACzBC,GAA0B,EAE1B,IAAK,IAAIztB,EAAY/E,EAAa,EAAG+E,GAAa,EAAGA,IAAa,CAC9D,IAAIsrB,EAASzwB,KAAK0wB,oBAAoBvrB,GACtC,GAAIsrB,GAAU,EAAG,CACbkC,EAAwBxtB,EACxBytB,EAAyBnC,EACzB,QAIZ,IAA+B,IAA3BoC,KAA4D,IAA3BA,GAAgCA,EAAwBzyB,EAAa,GAAI,CAC1GyyB,GAAyB,EACzBC,GAA0B,EAE1B,IAAS3tB,EAAY/E,EAAY+E,EAAY4J,EAAW5J,IAAa,CAC7DsrB,EAASzwB,KAAK0wB,oBAAoBvrB,GACtC,GAAIsrB,GAAU,EAAG,CACboC,EAAwB1tB,EACxB2tB,EAAyBrC,EACzB,QAIZrqB,EAAO2sB,GAAe/yB,KAAKwyB,iCAAiCxB,EAAS4B,EAAwBE,IAEjG,OAAO1sB,GAEXmT,EAAUrZ,UAAUsyB,iCAAmC,SAAUxB,EAAS4B,EAAwBE,GAC9F,OAAgC,IAA5BF,IAA6D,IAA5BE,EAE1B,EAEFF,EAAyBE,EAEtB,EAAI9uB,KAAKC,MAAM2uB,EAAyB5yB,KAAK8a,SAASqC,YAEzDyV,IAA2BE,GAK5B9B,EAHGhtB,KAAKuuB,KAAKO,EAAyB9yB,KAAK8a,SAASqC,YAS5C,EAAInZ,KAAKC,MAAM6uB,EAAyB9yB,KAAK8a,SAASqC,aAI1E5D,EAAUiC,iBAAmB,SAC7BjC,EAAU8B,0BAA4B,SACtC9B,EAAU+B,gCAAkC,IAC5C/B,EAAUsD,yBAA2B,CACjCpC,mBAAmB,EACnBwC,QAAS,OAAsBA,QAC/BE,WAAY,OAAsBA,WAClCD,aAAc,OAAsBA,aACpCH,mBAAmB,EACnB7D,WAAY,EACZkE,mBAAoB,OAAsBA,mBAC1CjC,uBAAwB,OAAsBA,wBAE3C5B,EA9oEmB,CA+oE5B,QAGE,EAAkC,WAClC,SAASyZ,IACLhzB,KAAKizB,kBAAoB,IAAI,OAC7BjzB,KAAKkzB,kBAAoB,IAAI,OAuDjC,OArDAF,EAAiB9yB,UAAU4pB,eAAiB,SAAU7hB,EAAOmX,EAAKyK,EAAeV,EAAqBhK,GAClG,IAAIgU,EAAKnzB,KAAKizB,kBAAkBnJ,eAAe7hB,EAAOmX,EAAKyK,EAAeV,EAAqBhK,GAC3FiU,EAAKpzB,KAAKkzB,kBAAkBpJ,eAAe7hB,EAAOmX,EAAKyK,EAAeV,EAAqBhK,GAC/F,OAAOgU,EAAGjhB,OAAOkhB,IAErBJ,EAAiB9yB,UAAU2e,OAAS,SAAUgL,EAAeV,EAAqBkK,EAAmBlU,GACjG,GAAIkU,EACA,OAAOrzB,KAAKkzB,kBAAkBrU,OAAOgL,EAAeV,EAAqBhK,GAGzE,IAAIgU,EAAKnzB,KAAKizB,kBAAkBpU,OAAOgL,EAAeV,EAAqBhK,GACvEiU,EAAKpzB,KAAKkzB,kBAAkBrU,OAAOgL,EAAeV,EAAqBhK,GAC3E,OAAOgU,EAAGjhB,OAAOkhB,IAGzBJ,EAAiB9yB,UAAU2oB,sBAAwB,SAAUzB,GACzD,IAAI+L,EAAKnzB,KAAKizB,kBAAkBpK,sBAAsBzB,GAClDgM,EAAKpzB,KAAKkzB,kBAAkBrK,sBAAsBzB,GACtD,OAAO+L,EAAGjhB,OAAOkhB,IAErBJ,EAAiB9yB,UAAU6e,sBAAwB,WAC/C,IAAIoU,EAAKnzB,KAAKizB,kBAAkBlU,wBAC5BqU,EAAKpzB,KAAKkzB,kBAAkBnU,wBAChC,OAAOoU,EAAGjhB,OAAOkhB,IAErBJ,EAAiB9yB,UAAUwoB,OAAS,SAAU1J,GACtC,eAAyBA,GACzBhf,KAAKkzB,kBAAkBxK,OAAO1J,GAG9Bhf,KAAKizB,kBAAkBvK,OAAO1J,IAGtCgU,EAAiB9yB,UAAUsoB,OAAS,SAAUxJ,GACtC,eAAyBA,GACzBhf,KAAKkzB,kBAAkB1K,OAAOxJ,GAG9Bhf,KAAKizB,kBAAkBzK,OAAOxJ,IAGtCgU,EAAiB9yB,UAAU8oB,YAAc,SAAUhK,EAAMG,GACjD,eAAyBH,GACzBhf,KAAKkzB,kBAAkBlK,YAAYhK,EAAMG,GAGzCnf,KAAKizB,kBAAkBjK,YAAYhK,EAAMG,IAGjD6T,EAAiB9yB,UAAU6lB,cAAgB,SAAUljB,EAAQtD,EAAQ0K,EAAY+b,GAC7EhmB,KAAKizB,kBAAkBlN,cAAcljB,EAAQtD,EAAQ0K,EAAY+b,GACjEhmB,KAAKkzB,kBAAkBnN,cAAcljB,EAAQtD,EAAQ0K,EAAY+b,IAE9DgN,EA1D0B,GA4DrC,SAASM,EAAeC,GACpB,OAAOA,EAAUC,QAAQ,iBAAkB,KAE/C,IAAIC,GAAmC,WACnC,SAASA,EAAkB9W,GACvB3c,KAAKkqB,MAAQvN,EAAQuN,OAAS,GAC9BlqB,KAAK0zB,UAAY/W,EAAQ+W,WAAa,GAE1C,OAAOD,EAL2B,GAOlC,GAAqD,SAAUve,GAE/D,SAASye,EAAoChX,GACzC,IAAItH,EAAQH,EAAOI,KAAKtV,KAAM2c,IAAY3c,KAG1C,OAFAqV,EAAMue,eAAiB,KACvBve,EAAMnQ,SAAwC,kBAArByX,EAAQzX,SAAwByX,EAAQzX,SAAWkH,EAAA,KAAwBynB,OAC7Fxe,EA0BX,OA/BA,EAAUse,EAAqCze,GAO/Cye,EAAoCzzB,UAAU4zB,SAAW,SAAUC,GAS/D,OARK/zB,KAAK4zB,iBACa,UAAfG,EAAMliB,MAAoB7R,KAAK0zB,UAC/B1zB,KAAK4zB,eAAiB5zB,KAAKg0B,cAAch0B,KAAK0zB,UAAWK,GAGzD/zB,KAAK4zB,eAAiB5zB,KAAKg0B,cAAch0B,KAAKkqB,MAAO6J,IAGtD/zB,KAAK4zB,gBAEhBD,EAAoCzzB,UAAU+zB,sBAAwB,WAClEj0B,KAAK4zB,eAAiB,MAE1BD,EAAoCzzB,UAAU8zB,cAAgB,SAAU9J,EAAO6J,GAC3E,GAAqB,kBAAV7J,EACP,OAAOA,EAEX,IAAIgK,EAAIhK,EAAQ6J,EAAMD,SAAS5J,EAAMxR,IAAM,KAC3C,OAAKwb,EAGEA,EAAEC,WAFE,IAIRR,EAhC6C,CAiCtDF,IAEE,GAA+C,SAAUve,GAEzD,SAASkf,EAA8BzX,GACnC,IAAItH,EAAQH,EAAOI,KAAKtV,KAAM2c,IAAY3c,KAE1C,OADAqV,EAAMnQ,SAAWyX,EAAQzX,SAClBmQ,EAsBX,OA1BA,EAAU+e,EAA+Blf,GAMzCkf,EAA8Bl0B,UAAU4zB,SAAW,SAAUC,GASzD,OARK/zB,KAAK4zB,iBACa,UAAfG,EAAMliB,MAAoB7R,KAAK0zB,UAC/B1zB,KAAK4zB,eAAiB5zB,KAAKg0B,cAAch0B,KAAK0zB,UAAWK,GAGzD/zB,KAAK4zB,eAAiB5zB,KAAKg0B,cAAch0B,KAAKkqB,MAAO6J,IAGtD/zB,KAAK4zB,gBAEhBQ,EAA8Bl0B,UAAU+zB,sBAAwB,WAC5Dj0B,KAAK4zB,oBAAiBtU,GAE1B8U,EAA8Bl0B,UAAU8zB,cAAgB,SAAU9J,EAAO6J,GACrE,MAAqB,kBAAV7J,EACA,OAAMmK,QAAQnK,GAElB6J,EAAMD,SAAS5J,EAAMxR,KAEzB0b,EA3BuC,CA4BhDX,IAEE,GAAwC,WACxC,SAASa,EAAuB3X,GAC5B3c,KAAKu0B,WAAa5X,EAAQ4X,YAAc,EACxCv0B,KAAKw0B,OAAS7X,EAAQ6X,QAAU,EAChCx0B,KAAKuzB,UAAY5W,EAAQ4W,UAAYD,EAAe3W,EAAQ4W,WAAa,KACzEvzB,KAAKy0B,aAAe,eAAoB9X,EAAQ8X,cAChDz0B,KAAK00B,wBAA0B,eAAoB/X,EAAQ+X,yBAC3D10B,KAAK20B,YAAchY,EAAQgY,cAAe,EAC1C30B,KAAK40B,gBAAkBjY,EAAQiY,kBAAmB,EAClD50B,KAAK60B,sBAAwBlY,EAAQkY,wBAAyB,EAC9D70B,KAAKiqB,cAAgBtN,EAAQsN,cAAgB,IAAI,GAAoCtN,EAAQsN,eAAiB,KAC9GjqB,KAAK80B,QAAUnY,EAAQmY,QAAU,IAAI,GAA8BnY,EAAQmY,SAAW,KACtF90B,KAAK+0B,qBAAuBpY,EAAQoY,qBAAuBzB,EAAe3W,EAAQoY,sBAAwB,KAC1G/0B,KAAKg1B,0BAA4BrY,EAAQqY,0BAA4B1B,EAAe3W,EAAQqY,2BAA6B,KACzHh1B,KAAKi1B,gBAAkBtY,EAAQsY,gBAAkB3B,EAAe3W,EAAQsY,iBAAmB,KAC3Fj1B,KAAKk1B,gBAAkBvY,EAAQuY,gBAAkB5B,EAAe3W,EAAQuY,iBAAmB,KAC3Fl1B,KAAKm1B,oCAAsCxY,EAAQwY,sCAAuC,EAC1Fn1B,KAAKo1B,uBAAyBzY,EAAQyY,uBAAyB9B,EAAe3W,EAAQyY,wBAA0B,KAChHp1B,KAAKq1B,sBAAwB1Y,EAAQ0Y,sBAAwB/B,EAAe3W,EAAQ0Y,uBAAyB,KAQjH,OANAf,EAAuBgB,SAAW,SAAU3Y,GACxC,OAAO,IAAI2X,EAAuB3X,IAEtC2X,EAAuBiB,cAAgB,SAAU5Y,GAC7C,OAAO,IAAI2X,EAAuB3X,IAE/B2X,EA1BgC,GA6B3C,GAAuBkB,MAAQ,GAAuBF,SAAS,IAI/D,IAAI/M,GAAwB,CACxB,GAAuB+M,SAAS,CAAEf,WAAY,IAC9C,GAAuBe,SAAS,CAAEf,WAAY,IAC9C,GAAuBe,SAAS,CAAEf,WAAY,IAC9C,GAAuBe,SAAS,CAAEf,WAAY,KAElD,SAASzM,GAAkBnL,GACvB,OAAIA,aAAmB,GACZA,EAEJ,GAAuB4Y,cAAc5Y,GAEhD,IAAI,GAA6C,SAAUzH,GAEvD,SAASugB,IACL,IAAIpgB,EAAQH,EAAOI,KAAKtV,OAASA,KAKjC,OAJAqV,EAAMlS,QAAUkS,EAAMM,UAAU,IAAI,QACpCN,EAAMwE,MAAQxE,EAAMlS,QAAQ0W,MAC5BxE,EAAMqgB,aAAe,EACrBrgB,EAAMsgB,aAAc,EACbtgB,EAiBX,OAxBA,EAAUogB,EAA6BvgB,GASvCugB,EAA4Bv1B,UAAU+jB,kBAAoB,WACtDjkB,KAAK01B,gBAETD,EAA4Bv1B,UAAUgkB,gBAAkB,WACpDlkB,KAAK01B,eACqB,IAAtB11B,KAAK01B,cACD11B,KAAK21B,cACL31B,KAAK21B,aAAc,EACnB31B,KAAKmD,QAAQ2Y,KAAK,MAI9B2Z,EAA4Bv1B,UAAU4b,KAAO,WACzC9b,KAAK21B,aAAc,GAEhBF,EAzBqC,CA0B9C,QAGE,GAAyC,SAAUvgB,GAEnD,SAAS0gB,IACL,IAAIvgB,EAAQH,EAAOI,KAAKtV,OAASA,KAUjC,OANAqV,EAAMwgB,aAAexgB,EAAMM,UAAU,IAAI,QACzCN,EAAMiI,UAAYjI,EAAMwgB,aAAahc,MACrCxE,EAAMygB,aAAezgB,EAAMM,UAAU,IAAI,QACzCN,EAAMmI,UAAYnI,EAAMygB,aAAajc,MACrCxE,EAAMqgB,aAAe,EACrBrgB,EAAM0gB,eAAiB,KAChB1gB,EA6BX,OAzCA,EAAUugB,EAAyB1gB,GAcnC0gB,EAAwB11B,UAAU+jB,kBAAoB,WAClDjkB,KAAK01B,gBAETE,EAAwB11B,UAAUgkB,gBAAkB,WAEhD,GADAlkB,KAAK01B,eACqB,IAAtB11B,KAAK01B,cACuB,OAAxB11B,KAAK+1B,eAAyB,CAC9B,IAAIlgB,EAAI7V,KAAK+1B,eACb/1B,KAAK+1B,eAAiB,KACtB/1B,KAAK61B,aAAa/Z,KAAKjG,GACvB7V,KAAK81B,aAAaha,KAAKjG,KAInC+f,EAAwB11B,UAAU4b,KAAO,SAAUjG,GAC3C7V,KAAK01B,aAAe,EAChB11B,KAAK+1B,eACL/1B,KAAK+1B,eAAiB/1B,KAAK+1B,eAAehkB,MAAM8D,GAGhD7V,KAAK+1B,eAAiBlgB,GAI9B7V,KAAK61B,aAAa/Z,KAAKjG,GACvB7V,KAAK81B,aAAaha,KAAKjG,KAEpB+f,EA1CiC,CA2C1C,S,kCCx8EF,wIAIO,IAAII,EAAwB,oCAQnC,SAASC,EAAiBC,QACD,IAAjBA,IAA2BA,EAAe,IAE9C,IADA,IAAI1c,EAAS,yBACJxS,EAAK,EAAGmvB,EAA0BH,EAAuBhvB,EAAKmvB,EAAwB52B,OAAQyH,IAAM,CACzG,IAAIovB,EAAMD,EAAwBnvB,GAC9BkvB,EAAavrB,QAAQyrB,IAAQ,IAGjC5c,GAAU,KAAO4c,GAGrB,OADA5c,GAAU,SACH,IAAI6c,OAAO7c,EAAQ,KAGvB,IAAI8c,EAAsBL,IAC1B,SAASM,EAA0BC,GACtC,IAAIpwB,EAASkwB,EACb,GAAIE,GAAmBA,aAA0BH,OAC7C,GAAKG,EAAe1rB,OAchB1E,EAASowB,MAde,CACxB,IAAIC,EAAQ,IACRD,EAAeE,aACfD,GAAS,KAETD,EAAe/rB,YACfgsB,GAAS,KAETD,EAAezrB,UACf0rB,GAAS,KAEbrwB,EAAS,IAAIiwB,OAAOG,EAAehd,OAAQid,GAOnD,OADArwB,EAAOwK,UAAY,EACZxK,EAEX,SAASuwB,EAAiBvxB,EAAQoxB,EAAgBv3B,EAAM23B,GAEpD,IAGIC,EAHAC,EAAM1xB,EAAS,EAAIwxB,EACnB3uB,EAAQhJ,EAAK83B,YAAY,IAAKD,EAAM,GAAK,EAC7CN,EAAe5lB,UAAY3I,EAE3B,MAAO4uB,EAAQL,EAAe3lB,KAAK5R,GAAO,CACtC,IAAI8N,EAAa8pB,EAAM3oB,OAAS,EAChC,GAAInB,GAAc+pB,GAAON,EAAe5lB,WAAakmB,EACjD,MAAO,CACHpK,KAAMmK,EAAM,GACZlyB,YAAaiyB,EAAa,EAAI7pB,EAC9BnI,UAAWgyB,EAAa,EAAIJ,EAAe5lB,WAIvD,OAAO,KAEX,SAASomB,EAAiB5xB,EAAQoxB,EAAgBv3B,EAAM23B,GAIpD,IAEIC,EAFAC,EAAM1xB,EAAS,EAAIwxB,EACvBJ,EAAe5lB,UAAY,EAE3B,MAAOimB,EAAQL,EAAe3lB,KAAK5R,GAAO,CACtC,IAAI8N,EAAa8pB,EAAM3oB,OAAS,EAChC,GAAInB,EAAa+pB,EAEb,OAAO,KAEN,GAAIN,EAAe5lB,WAAakmB,EAEjC,MAAO,CACHpK,KAAMmK,EAAM,GACZlyB,YAAaiyB,EAAa,EAAI7pB,EAC9BnI,UAAWgyB,EAAa,EAAIJ,EAAe5lB,WAIvD,OAAO,KAEJ,SAASqmB,EAAc7xB,EAAQoxB,EAAgBv3B,EAAM23B,GAGxDJ,EAAe5lB,UAAY,EAC3B,IAAIimB,EAAQL,EAAe3lB,KAAK5R,GAChC,IAAK43B,EACD,OAAO,KAGX,IAAIhT,EAAMgT,EAAM,GAAGlsB,QAAQ,MAAQ,EAE7BqsB,EAAiB5xB,EAAQoxB,EAAgBv3B,EAAM23B,GAE/CD,EAAiBvxB,EAAQoxB,EAAgBv3B,EAAM23B,GAKrD,OADAJ,EAAe5lB,UAAY,EACpBiT","file":"js/chunk-vendors~d13273ef.67cf3631.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { TokenMetadata } from '../modes.js';\r\nexport function countEOL(text) {\r\n    var eolCount = 0;\r\n    var firstLineLength = 0;\r\n    var lastLineStart = 0;\r\n    for (var i = 0, len = text.length; i < len; i++) {\r\n        var chr = text.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n            }\r\n            lastLineStart = i + 1;\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            lastLineStart = i + 1;\r\n        }\r\n    }\r\n    if (eolCount === 0) {\r\n        firstLineLength = text.length;\r\n    }\r\n    return [eolCount, firstLineLength, text.length - lastLineStart];\r\n}\r\nfunction getDefaultMetadata(topLevelLanguageId) {\r\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\r\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\r\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\r\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\r\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n}\r\nvar EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\r\nvar MultilineTokensBuilder = /** @class */ (function () {\r\n    function MultilineTokensBuilder() {\r\n        this.tokens = [];\r\n    }\r\n    MultilineTokensBuilder.prototype.add = function (lineNumber, lineTokens) {\r\n        if (this.tokens.length > 0) {\r\n            var last = this.tokens[this.tokens.length - 1];\r\n            var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\r\n            if (lastLineNumber + 1 === lineNumber) {\r\n                // append\r\n                last.tokens.push(lineTokens);\r\n                return;\r\n            }\r\n        }\r\n        this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\r\n    };\r\n    return MultilineTokensBuilder;\r\n}());\r\nexport { MultilineTokensBuilder };\r\nvar SparseEncodedTokens = /** @class */ (function () {\r\n    function SparseEncodedTokens(tokens) {\r\n        this._tokens = tokens;\r\n        this._tokenCount = tokens.length / 4;\r\n    }\r\n    SparseEncodedTokens.prototype.getMaxDeltaLine = function () {\r\n        var tokenCount = this.getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return -1;\r\n        }\r\n        return this.getDeltaLine(tokenCount - 1);\r\n    };\r\n    SparseEncodedTokens.prototype.getTokenCount = function () {\r\n        return this._tokenCount;\r\n    };\r\n    SparseEncodedTokens.prototype.getDeltaLine = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex];\r\n    };\r\n    SparseEncodedTokens.prototype.getStartCharacter = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    };\r\n    SparseEncodedTokens.prototype.getEndCharacter = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    };\r\n    SparseEncodedTokens.prototype.getMetadata = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 3];\r\n    };\r\n    SparseEncodedTokens.prototype.clear = function () {\r\n        this._tokenCount = 0;\r\n    };\r\n    SparseEncodedTokens.prototype.acceptDeleteRange = function (horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\r\n        // This is a bit complex, here are the cases I used to think about this:\r\n        //\r\n        // 1. The token starts before the deletion range\r\n        // 1a. The token is completely before the deletion range\r\n        //               -----------\r\n        //                          xxxxxxxxxxx\r\n        // 1b. The token starts before, the deletion range ends after the token\r\n        //               -----------\r\n        //                      xxxxxxxxxxx\r\n        // 1c. The token starts before, the deletion range ends precisely with the token\r\n        //               ---------------\r\n        //                      xxxxxxxx\r\n        // 1d. The token starts before, the deletion range is inside the token\r\n        //               ---------------\r\n        //                    xxxxx\r\n        //\r\n        // 2. The token starts at the same position with the deletion range\r\n        // 2a. The token starts at the same position, and ends inside the deletion range\r\n        //               -------\r\n        //               xxxxxxxxxxx\r\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n        //               ----------\r\n        //               xxxxxxxxxx\r\n        // 2c. The token starts at the same position, and ends after the deletion range\r\n        //               -------------\r\n        //               xxxxxxx\r\n        //\r\n        // 3. The token starts inside the deletion range\r\n        // 3a. The token is inside the deletion range\r\n        //                -------\r\n        //             xxxxxxxxxxxxx\r\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n        //                ----------\r\n        //             xxxxxxxxxxxxx\r\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n        //                ------------\r\n        //             xxxxxxxxxxx\r\n        //\r\n        // 4. The token starts after the deletion range\r\n        //                  -----------\r\n        //          xxxxxxxx\r\n        //\r\n        var tokens = this._tokens;\r\n        var tokenCount = this._tokenCount;\r\n        var deletedLineCount = (endDeltaLine - startDeltaLine);\r\n        var newTokenCount = 0;\r\n        var hasDeletedTokens = false;\r\n        for (var i = 0; i < tokenCount; i++) {\r\n            var srcOffset = 4 * i;\r\n            var tokenDeltaLine = tokens[srcOffset];\r\n            var tokenStartCharacter = tokens[srcOffset + 1];\r\n            var tokenEndCharacter = tokens[srcOffset + 2];\r\n            var tokenMetadata = tokens[srcOffset + 3];\r\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\r\n                // 1a. The token is completely before the deletion range\r\n                // => nothing to do\r\n                newTokenCount++;\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\r\n                // 1b, 1c, 1d\r\n                // => the token survives, but it needs to shrink\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 1d. The token starts before, the deletion range is inside the token\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 1b. The token starts before, the deletion range ends after the token\r\n                    // 1c. The token starts before, the deletion range ends precisely with the token\r\n                    // => the token shrinks its ending to the deletion start\r\n                    tokenEndCharacter = startCharacter;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\r\n                // 2a, 2b, 2c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 2c. The token starts at the same position, and ends after the deletion range\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 2a. The token starts at the same position, and ends inside the deletion range\r\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\r\n                // 3a, 3b, 3c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n                    // => the token moves left and shrinks\r\n                    if (tokenDeltaLine === startDeltaLine) {\r\n                        // the deletion started on the same line as the token\r\n                        // => the token moves left and shrinks\r\n                        tokenStartCharacter = startCharacter;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                    else {\r\n                        // the deletion started on a line above the token\r\n                        // => the token moves to the beginning of the line\r\n                        tokenStartCharacter = 0;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                }\r\n                else {\r\n                    // 3a. The token is inside the deletion range\r\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine > endDeltaLine) {\r\n                // 4. (partial) The token starts after the deletion range, on a line below...\r\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\r\n                    // early stop, there is no need to walk all the tokens and do nothing...\r\n                    newTokenCount = tokenCount;\r\n                    break;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n            }\r\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\r\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\r\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\r\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\r\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n                tokenStartCharacter -= (endCharacter - startCharacter);\r\n                tokenEndCharacter -= (endCharacter - startCharacter);\r\n            }\r\n            else {\r\n                throw new Error(\"Not possible!\");\r\n            }\r\n            var destOffset = 4 * newTokenCount;\r\n            tokens[destOffset] = tokenDeltaLine;\r\n            tokens[destOffset + 1] = tokenStartCharacter;\r\n            tokens[destOffset + 2] = tokenEndCharacter;\r\n            tokens[destOffset + 3] = tokenMetadata;\r\n            newTokenCount++;\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n    };\r\n    SparseEncodedTokens.prototype.acceptInsertText = function (deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        // Here are the cases I used to think about this:\r\n        //\r\n        // 1. The token is completely before the insertion point\r\n        //            -----------   |\r\n        // 2. The token ends precisely at the insertion point\r\n        //            -----------|\r\n        // 3. The token contains the insertion point\r\n        //            -----|------\r\n        // 4. The token starts precisely at the insertion point\r\n        //            |-----------\r\n        // 5. The token is completely after the insertion point\r\n        //            |   -----------\r\n        //\r\n        var isInsertingPreciselyOneWordCharacter = (eolCount === 0\r\n            && firstLineLength === 1\r\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\r\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\r\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\r\n        var tokens = this._tokens;\r\n        var tokenCount = this._tokenCount;\r\n        for (var i = 0; i < tokenCount; i++) {\r\n            var offset = 4 * i;\r\n            var tokenDeltaLine = tokens[offset];\r\n            var tokenStartCharacter = tokens[offset + 1];\r\n            var tokenEndCharacter = tokens[offset + 2];\r\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\r\n                // 1. The token is completely before the insertion point\r\n                // => nothing to do\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\r\n                // 2. The token ends precisely at the insertion point\r\n                // => expand the end character only if inserting precisely one character that is a word character\r\n                if (isInsertingPreciselyOneWordCharacter) {\r\n                    tokenEndCharacter += 1;\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\r\n                // 3. The token contains the insertion point\r\n                if (eolCount === 0) {\r\n                    // => just expand the end character\r\n                    tokenEndCharacter += firstLineLength;\r\n                }\r\n                else {\r\n                    // => cut off the token\r\n                    tokenEndCharacter = character;\r\n                }\r\n            }\r\n            else {\r\n                // 4. or 5.\r\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\r\n                    // 4. The token starts precisely at the insertion point\r\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\r\n                    // => otherwise behave as in case 5.\r\n                    if (isInsertingPreciselyOneWordCharacter) {\r\n                        continue;\r\n                    }\r\n                }\r\n                // => the token must move and keep its size constant\r\n                if (tokenDeltaLine === deltaLine) {\r\n                    tokenDeltaLine += eolCount;\r\n                    // this token is on the line where the insertion is taking place\r\n                    if (eolCount === 0) {\r\n                        tokenStartCharacter += firstLineLength;\r\n                        tokenEndCharacter += firstLineLength;\r\n                    }\r\n                    else {\r\n                        var tokenLength = tokenEndCharacter - tokenStartCharacter;\r\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\r\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\r\n                    }\r\n                }\r\n                else {\r\n                    tokenDeltaLine += eolCount;\r\n                }\r\n            }\r\n            tokens[offset] = tokenDeltaLine;\r\n            tokens[offset + 1] = tokenStartCharacter;\r\n            tokens[offset + 2] = tokenEndCharacter;\r\n        }\r\n    };\r\n    return SparseEncodedTokens;\r\n}());\r\nexport { SparseEncodedTokens };\r\nvar LineTokens2 = /** @class */ (function () {\r\n    function LineTokens2(actual, startTokenIndex, endTokenIndex) {\r\n        this._actual = actual;\r\n        this._startTokenIndex = startTokenIndex;\r\n        this._endTokenIndex = endTokenIndex;\r\n    }\r\n    LineTokens2.prototype.getCount = function () {\r\n        return this._endTokenIndex - this._startTokenIndex + 1;\r\n    };\r\n    LineTokens2.prototype.getStartCharacter = function (tokenIndex) {\r\n        return this._actual.getStartCharacter(this._startTokenIndex + tokenIndex);\r\n    };\r\n    LineTokens2.prototype.getEndCharacter = function (tokenIndex) {\r\n        return this._actual.getEndCharacter(this._startTokenIndex + tokenIndex);\r\n    };\r\n    LineTokens2.prototype.getMetadata = function (tokenIndex) {\r\n        return this._actual.getMetadata(this._startTokenIndex + tokenIndex);\r\n    };\r\n    return LineTokens2;\r\n}());\r\nexport { LineTokens2 };\r\nvar MultilineTokens2 = /** @class */ (function () {\r\n    function MultilineTokens2(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    MultilineTokens2.prototype._updateEndLineNumber = function () {\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    };\r\n    MultilineTokens2.prototype.getLineTokens = function (lineNumber) {\r\n        if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\r\n            var findResult = MultilineTokens2._findTokensWithLine(this.tokens, lineNumber - this.startLineNumber);\r\n            if (findResult) {\r\n                var startTokenIndex = findResult[0], endTokenIndex = findResult[1];\r\n                return new LineTokens2(this.tokens, startTokenIndex, endTokenIndex);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    MultilineTokens2._findTokensWithLine = function (tokens, deltaLine) {\r\n        var low = 0;\r\n        var high = tokens.getTokenCount() - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            var midDeltaLine = tokens.getDeltaLine(mid);\r\n            if (midDeltaLine < deltaLine) {\r\n                low = mid + 1;\r\n            }\r\n            else if (midDeltaLine > deltaLine) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                var min = mid;\r\n                while (min > low && tokens.getDeltaLine(min - 1) === deltaLine) {\r\n                    min--;\r\n                }\r\n                var max = mid;\r\n                while (max < high && tokens.getDeltaLine(max + 1) === deltaLine) {\r\n                    max++;\r\n                }\r\n                return [min, max];\r\n            }\r\n        }\r\n        if (tokens.getDeltaLine(low) === deltaLine) {\r\n            return [low, low];\r\n        }\r\n        return null;\r\n    };\r\n    MultilineTokens2.prototype.applyEdit = function (range, text) {\r\n        var _a = countEOL(text), eolCount = _a[0], firstLineLength = _a[1], lastLineLength = _a[2];\r\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\r\n    };\r\n    MultilineTokens2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        this._updateEndLineNumber();\r\n    };\r\n    MultilineTokens2.prototype._acceptDeleteRange = function (range) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            // Nothing to delete\r\n            return;\r\n        }\r\n        var firstLineIndex = range.startLineNumber - this.startLineNumber;\r\n        var lastLineIndex = range.endLineNumber - this.startLineNumber;\r\n        if (lastLineIndex < 0) {\r\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\r\n            var deletedLinesCount = lastLineIndex - firstLineIndex;\r\n            this.startLineNumber -= deletedLinesCount;\r\n            return;\r\n        }\r\n        var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion occurs entirely after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion completely encompasses this block\r\n            this.startLineNumber = 0;\r\n            this.tokens.clear();\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0) {\r\n            var deletedBefore = -firstLineIndex;\r\n            this.startLineNumber -= deletedBefore;\r\n            this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\r\n        }\r\n        else {\r\n            this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\r\n        }\r\n    };\r\n    MultilineTokens2.prototype._acceptInsertText = function (position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        var lineIndex = position.lineNumber - this.startLineNumber;\r\n        if (lineIndex < 0) {\r\n            // this insertion occurs before this block, so we only need to adjust line numbers\r\n            this.startLineNumber += eolCount;\r\n            return;\r\n        }\r\n        var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this insertion occurs after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n    };\r\n    return MultilineTokens2;\r\n}());\r\nexport { MultilineTokens2 };\r\nvar MultilineTokens = /** @class */ (function () {\r\n    function MultilineTokens(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n    }\r\n    return MultilineTokens;\r\n}());\r\nexport { MultilineTokens };\r\nfunction toUint32Array(arr) {\r\n    if (arr instanceof Uint32Array) {\r\n        return arr;\r\n    }\r\n    else {\r\n        return new Uint32Array(arr);\r\n    }\r\n}\r\nvar TokensStore2 = /** @class */ (function () {\r\n    function TokensStore2() {\r\n        this._pieces = [];\r\n    }\r\n    TokensStore2.prototype.flush = function () {\r\n        this._pieces = [];\r\n    };\r\n    TokensStore2.prototype.set = function (pieces) {\r\n        this._pieces = pieces || [];\r\n    };\r\n    TokensStore2.prototype.addSemanticTokens = function (lineNumber, aTokens) {\r\n        var pieces = this._pieces;\r\n        if (pieces.length === 0) {\r\n            return aTokens;\r\n        }\r\n        var pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\r\n        var bTokens = this._pieces[pieceIndex].getLineTokens(lineNumber);\r\n        if (!bTokens) {\r\n            return aTokens;\r\n        }\r\n        var aLen = aTokens.getCount();\r\n        var bLen = bTokens.getCount();\r\n        var aIndex = 0;\r\n        var result = [], resultLen = 0;\r\n        for (var bIndex = 0; bIndex < bLen; bIndex++) {\r\n            var bStartCharacter = bTokens.getStartCharacter(bIndex);\r\n            var bEndCharacter = bTokens.getEndCharacter(bIndex);\r\n            var bMetadata = bTokens.getMetadata(bIndex);\r\n            var bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 2048 /* ITALIC_MASK */ : 0)\r\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 4096 /* BOLD_MASK */ : 0)\r\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 8192 /* UNDERLINE_MASK */ : 0)\r\n                | ((bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\r\n                | ((bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\r\n            var aMask = (~bMask) >>> 0;\r\n            // push any token from `a` that is before `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = aTokens.getMetadata(aIndex);\r\n                aIndex++;\r\n            }\r\n            // push the token from `a` if it intersects the token from `b`\r\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\r\n                result[resultLen++] = bStartCharacter;\r\n                result[resultLen++] = aTokens.getMetadata(aIndex);\r\n            }\r\n            // skip any tokens from `a` that are contained inside `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask);\r\n                aIndex++;\r\n            }\r\n            if (aIndex < aLen && aTokens.getEndOffset(aIndex) === bEndCharacter) {\r\n                // `a` ends exactly at the same spot as `b`!\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask);\r\n                aIndex++;\r\n            }\r\n            else {\r\n                var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\r\n                // push the token from `b`\r\n                result[resultLen++] = bEndCharacter;\r\n                result[resultLen++] = (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask);\r\n            }\r\n        }\r\n        // push the remaining tokens from `a`\r\n        while (aIndex < aLen) {\r\n            result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n            result[resultLen++] = aTokens.getMetadata(aIndex);\r\n            aIndex++;\r\n        }\r\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\r\n    };\r\n    TokensStore2._findFirstPieceWithLine = function (pieces, lineNumber) {\r\n        var low = 0;\r\n        var high = pieces.length - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            if (pieces[mid].endLineNumber < lineNumber) {\r\n                low = mid + 1;\r\n            }\r\n            else if (pieces[mid].startLineNumber > lineNumber) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\r\n                    mid--;\r\n                }\r\n                return mid;\r\n            }\r\n        }\r\n        return low;\r\n    };\r\n    //#region Editing\r\n    TokensStore2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        for (var _i = 0, _a = this._pieces; _i < _a.length; _i++) {\r\n            var piece = _a[_i];\r\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        }\r\n    };\r\n    return TokensStore2;\r\n}());\r\nexport { TokensStore2 };\r\nvar TokensStore = /** @class */ (function () {\r\n    function TokensStore() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    TokensStore.prototype.flush = function () {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    };\r\n    TokensStore.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\r\n        var rawLineTokens = null;\r\n        if (lineIndex < this._len) {\r\n            rawLineTokens = this._lineTokens[lineIndex];\r\n        }\r\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\r\n            return new LineTokens(toUint32Array(rawLineTokens), lineText);\r\n        }\r\n        var lineTokens = new Uint32Array(2);\r\n        lineTokens[0] = lineText.length;\r\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n        return new LineTokens(lineTokens, lineText);\r\n    };\r\n    TokensStore._massageTokens = function (topLevelLanguageId, lineTextLength, _tokens) {\r\n        var tokens = _tokens ? toUint32Array(_tokens) : null;\r\n        if (lineTextLength === 0) {\r\n            var hasDifferentLanguageId = false;\r\n            if (tokens && tokens.length > 1) {\r\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\r\n            }\r\n            if (!hasDifferentLanguageId) {\r\n                return EMPTY_LINE_TOKENS;\r\n            }\r\n        }\r\n        if (!tokens || tokens.length === 0) {\r\n            var tokens_1 = new Uint32Array(2);\r\n            tokens_1[0] = lineTextLength;\r\n            tokens_1[1] = getDefaultMetadata(topLevelLanguageId);\r\n            return tokens_1.buffer;\r\n        }\r\n        // Ensure the last token covers the end of the text\r\n        tokens[tokens.length - 2] = lineTextLength;\r\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\r\n            // Store directly the ArrayBuffer pointer to save an object\r\n            return tokens.buffer;\r\n        }\r\n        return tokens;\r\n    };\r\n    TokensStore.prototype._ensureLine = function (lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._lineTokens[this._len] = null;\r\n            this._len++;\r\n        }\r\n    };\r\n    TokensStore.prototype._deleteLines = function (start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._lineTokens.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    };\r\n    TokensStore.prototype._insertLines = function (insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        var lineTokens = [];\r\n        for (var i = 0; i < insertCount; i++) {\r\n            lineTokens[i] = null;\r\n        }\r\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\r\n        this._len += insertCount;\r\n    };\r\n    TokensStore.prototype.setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, _tokens) {\r\n        var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\r\n        this._ensureLine(lineIndex);\r\n        this._lineTokens[lineIndex] = tokens;\r\n    };\r\n    //#region Editing\r\n    TokensStore.prototype.acceptEdit = function (range, eolCount, firstLineLength) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\r\n    };\r\n    TokensStore.prototype._acceptDeleteRange = function (range) {\r\n        var firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\r\n            return;\r\n        }\r\n        this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\r\n        var lastLineIndex = range.endLineNumber - 1;\r\n        var lastLineTokens = null;\r\n        if (lastLineIndex < this._len) {\r\n            lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\r\n        // Delete middle lines\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    };\r\n    TokensStore.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        var lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (eolCount === 0) {\r\n            // Inserting text on one line\r\n            this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n            return;\r\n        }\r\n        this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\r\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    };\r\n    TokensStore._deleteBeginning = function (lineTokens, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        return TokensStore._delete(lineTokens, 0, toChIndex);\r\n    };\r\n    TokensStore._deleteEnding = function (lineTokens, fromChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var lineTextLength = tokens[tokens.length - 2];\r\n        return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\r\n    };\r\n    TokensStore._delete = function (lineTokens, fromChIndex, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var tokensCount = (tokens.length >>> 1);\r\n        // special case: deleting everything\r\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\r\n            return EMPTY_LINE_TOKENS;\r\n        }\r\n        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\r\n        var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\r\n        var fromTokenEndOffset = tokens[fromTokenIndex << 1];\r\n        if (toChIndex < fromTokenEndOffset) {\r\n            // the delete range is inside a single token\r\n            var delta_1 = (toChIndex - fromChIndex);\r\n            for (var i = fromTokenIndex; i < tokensCount; i++) {\r\n                tokens[i << 1] -= delta_1;\r\n            }\r\n            return lineTokens;\r\n        }\r\n        var dest;\r\n        var lastEnd;\r\n        if (fromTokenStartOffset !== fromChIndex) {\r\n            tokens[fromTokenIndex << 1] = fromChIndex;\r\n            dest = ((fromTokenIndex + 1) << 1);\r\n            lastEnd = fromChIndex;\r\n        }\r\n        else {\r\n            dest = (fromTokenIndex << 1);\r\n            lastEnd = fromTokenStartOffset;\r\n        }\r\n        var delta = (toChIndex - fromChIndex);\r\n        for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\r\n            var tokenEndOffset = tokens[tokenIndex << 1] - delta;\r\n            if (tokenEndOffset > lastEnd) {\r\n                tokens[dest++] = tokenEndOffset;\r\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\r\n                lastEnd = tokenEndOffset;\r\n            }\r\n        }\r\n        if (dest === tokens.length) {\r\n            // nothing to trim\r\n            return lineTokens;\r\n        }\r\n        var tmp = new Uint32Array(dest);\r\n        tmp.set(tokens.subarray(0, dest), 0);\r\n        return tmp.buffer;\r\n    };\r\n    TokensStore._append = function (lineTokens, _otherTokens) {\r\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        if (lineTokens === EMPTY_LINE_TOKENS) {\r\n            return _otherTokens;\r\n        }\r\n        if (lineTokens === null) {\r\n            return lineTokens;\r\n        }\r\n        if (_otherTokens === null) {\r\n            // cannot determine combined line length...\r\n            return null;\r\n        }\r\n        var myTokens = toUint32Array(lineTokens);\r\n        var otherTokens = toUint32Array(_otherTokens);\r\n        var otherTokensCount = (otherTokens.length >>> 1);\r\n        var result = new Uint32Array(myTokens.length + otherTokens.length);\r\n        result.set(myTokens, 0);\r\n        var dest = myTokens.length;\r\n        var delta = myTokens[myTokens.length - 2];\r\n        for (var i = 0; i < otherTokensCount; i++) {\r\n            result[dest++] = otherTokens[(i << 1)] + delta;\r\n            result[dest++] = otherTokens[(i << 1) + 1];\r\n        }\r\n        return result.buffer;\r\n    };\r\n    TokensStore._insert = function (lineTokens, chIndex, textLength) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            // nothing to do\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var tokensCount = (tokens.length >>> 1);\r\n        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\r\n        if (fromTokenIndex > 0) {\r\n            var fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\r\n            if (fromTokenStartOffset === chIndex) {\r\n                fromTokenIndex--;\r\n            }\r\n        }\r\n        for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\r\n            tokens[tokenIndex << 1] += textLength;\r\n        }\r\n        return lineTokens;\r\n    };\r\n    return TokensStore;\r\n}());\r\nexport { TokensStore };\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { FindMatch } from '../model.js';\r\nvar LIMIT_FIND_COUNT = 999;\r\nvar SearchParams = /** @class */ (function () {\r\n    function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\r\n        this.searchString = searchString;\r\n        this.isRegex = isRegex;\r\n        this.matchCase = matchCase;\r\n        this.wordSeparators = wordSeparators;\r\n    }\r\n    SearchParams.prototype.parseSearchRequest = function () {\r\n        if (this.searchString === '') {\r\n            return null;\r\n        }\r\n        // Try to create a RegExp out of the params\r\n        var multiline;\r\n        if (this.isRegex) {\r\n            multiline = isMultilineRegexSource(this.searchString);\r\n        }\r\n        else {\r\n            multiline = (this.searchString.indexOf('\\n') >= 0);\r\n        }\r\n        var regex = null;\r\n        try {\r\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\r\n                matchCase: this.matchCase,\r\n                wholeWord: false,\r\n                multiline: multiline,\r\n                global: true,\r\n                unicode: true\r\n            });\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        if (!regex) {\r\n            return null;\r\n        }\r\n        var canUseSimpleSearch = (!this.isRegex && !multiline);\r\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\r\n            // casing might make a difference\r\n            canUseSimpleSearch = this.matchCase;\r\n        }\r\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\r\n    };\r\n    return SearchParams;\r\n}());\r\nexport { SearchParams };\r\nexport function isMultilineRegexSource(searchString) {\r\n    if (!searchString || searchString.length === 0) {\r\n        return false;\r\n    }\r\n    for (var i = 0, len = searchString.length; i < len; i++) {\r\n        var chCode = searchString.charCodeAt(i);\r\n        if (chCode === 92 /* Backslash */) {\r\n            // move to next char\r\n            i++;\r\n            if (i >= len) {\r\n                // string ends with a \\\r\n                break;\r\n            }\r\n            var nextChCode = searchString.charCodeAt(i);\r\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */ || nextChCode === 119 /* w */) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nvar SearchData = /** @class */ (function () {\r\n    function SearchData(regex, wordSeparators, simpleSearch) {\r\n        this.regex = regex;\r\n        this.wordSeparators = wordSeparators;\r\n        this.simpleSearch = simpleSearch;\r\n    }\r\n    return SearchData;\r\n}());\r\nexport { SearchData };\r\nexport function createFindMatch(range, rawMatches, captureMatches) {\r\n    if (!captureMatches) {\r\n        return new FindMatch(range, null);\r\n    }\r\n    var matches = [];\r\n    for (var i = 0, len = rawMatches.length; i < len; i++) {\r\n        matches[i] = rawMatches[i];\r\n    }\r\n    return new FindMatch(range, matches);\r\n}\r\nvar LineFeedCounter = /** @class */ (function () {\r\n    function LineFeedCounter(text) {\r\n        var lineFeedsOffsets = [];\r\n        var lineFeedsOffsetsLen = 0;\r\n        for (var i = 0, textLen = text.length; i < textLen; i++) {\r\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\r\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\r\n            }\r\n        }\r\n        this._lineFeedsOffsets = lineFeedsOffsets;\r\n    }\r\n    LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\r\n        var lineFeedsOffsets = this._lineFeedsOffsets;\r\n        var min = 0;\r\n        var max = lineFeedsOffsets.length - 1;\r\n        if (max === -1) {\r\n            // no line feeds\r\n            return 0;\r\n        }\r\n        if (offset <= lineFeedsOffsets[0]) {\r\n            // before first line feed\r\n            return 0;\r\n        }\r\n        while (min < max) {\r\n            var mid = min + ((max - min) / 2 >> 0);\r\n            if (lineFeedsOffsets[mid] >= offset) {\r\n                max = mid - 1;\r\n            }\r\n            else {\r\n                if (lineFeedsOffsets[mid + 1] >= offset) {\r\n                    // bingo!\r\n                    min = mid;\r\n                    max = mid;\r\n                }\r\n                else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n        }\r\n        return min + 1;\r\n    };\r\n    return LineFeedCounter;\r\n}());\r\nvar TextModelSearch = /** @class */ (function () {\r\n    function TextModelSearch() {\r\n    }\r\n    TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return [];\r\n        }\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\r\n        }\r\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\r\n    };\r\n    /**\r\n     * Multiline search always executes on the lines concatenated with \\n.\r\n     * We must therefore compensate for the count of \\n in case the model is CRLF\r\n     */\r\n    TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\r\n        var startOffset;\r\n        var lineFeedCountBeforeMatch = 0;\r\n        if (lfCounter) {\r\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\r\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            startOffset = deltaOffset + matchIndex;\r\n        }\r\n        var endOffset;\r\n        if (lfCounter) {\r\n            var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\r\n            var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\r\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            endOffset = startOffset + match0.length;\r\n        }\r\n        var startPosition = model.getPositionAt(startOffset);\r\n        var endPosition = model.getPositionAt(endOffset);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    };\r\n    TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\r\n        var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        var text = model.getValueInRange(searchRange, 1 /* LF */);\r\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        var result = [];\r\n        var counter = 0;\r\n        var m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n            if (counter >= limitResultCount) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\r\n        var result = [];\r\n        var resultLen = 0;\r\n        // Early case for a search range that starts & stops on the same line number\r\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\r\n            var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        // Collect results from first line\r\n        var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\r\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n        // Collect results from middle lines\r\n        for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\r\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        // Collect results from last line\r\n        if (resultLen < limitResultCount) {\r\n            var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        return result;\r\n    };\r\n    TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        var wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            var searchString = searchData.simpleSearch;\r\n            var searchStringLen = searchString.length;\r\n            var textLength = text.length;\r\n            var lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    };\r\n    TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\r\n        var searchTextStart = new Position(searchStart.lineNumber, 1);\r\n        var deltaOffset = model.getOffsetAt(searchTextStart);\r\n        var lineCount = model.getLineCount();\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\r\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        searcher.reset(searchStart.column - 1);\r\n        var m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n        }\r\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\r\n            // Try again from the top\r\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\r\n        var lineCount = model.getLineCount();\r\n        var startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        var text = model.getLineContent(startLineNumber);\r\n        var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (var i = 1; i <= lineCount; i++) {\r\n            var lineIndex = (startLineNumber + i - 1) % lineCount;\r\n            var text_3 = model.getLineContent(lineIndex + 1);\r\n            var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\r\n            if (r_1) {\r\n                return r_1;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\r\n        // Set regex to search from column\r\n        searcher.reset(fromColumn - 1);\r\n        var m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    };\r\n    TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\r\n        var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\r\n        if (matches.length > 0) {\r\n            return matches[matches.length - 1];\r\n        }\r\n        var lineCount = model.getLineCount();\r\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\r\n            // Try again with all content\r\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\r\n        var lineCount = model.getLineCount();\r\n        var startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\r\n        var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (var i = 1; i <= lineCount; i++) {\r\n            var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\r\n            var text_4 = model.getLineContent(lineIndex + 1);\r\n            var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\r\n            if (r_2) {\r\n                return r_2;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\r\n        var bestResult = null;\r\n        var m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return bestResult;\r\n    };\r\n    return TextModelSearch;\r\n}());\r\nexport { TextModelSearch };\r\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex === 0) {\r\n        // Match starts at start of string\r\n        return true;\r\n    }\r\n    var charBefore = text.charCodeAt(matchStartIndex - 1);\r\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\r\n        // The character before the match is a word separator\r\n        return true;\r\n    }\r\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\r\n        // The character before the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        var firstCharInMatch = text.charCodeAt(matchStartIndex);\r\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\r\n            // The first character inside the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex + matchLength === textLength) {\r\n        // Match ends at end of string\r\n        return true;\r\n    }\r\n    var charAfter = text.charCodeAt(matchStartIndex + matchLength);\r\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\r\n        // The character after the match is a word separator\r\n        return true;\r\n    }\r\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\r\n        // The character after the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\r\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\r\n            // The last character in the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\r\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\r\n}\r\nvar Searcher = /** @class */ (function () {\r\n    function Searcher(wordSeparators, searchRegex) {\r\n        this._wordSeparators = wordSeparators;\r\n        this._searchRegex = searchRegex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    Searcher.prototype.reset = function (lastIndex) {\r\n        this._searchRegex.lastIndex = lastIndex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    };\r\n    Searcher.prototype.next = function (text) {\r\n        var textLength = text.length;\r\n        var m;\r\n        do {\r\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\r\n                // Reached the end of the line\r\n                return null;\r\n            }\r\n            m = this._searchRegex.exec(text);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            var matchStartIndex = m.index;\r\n            var matchLength = m[0].length;\r\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\r\n                if (matchLength === 0) {\r\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\r\n                    // we attempt to recover from that by advancing by one\r\n                    this._searchRegex.lastIndex += 1;\r\n                    continue;\r\n                }\r\n                // Exit early if the regex matches the same range twice\r\n                return null;\r\n            }\r\n            this._prevMatchStartIndex = matchStartIndex;\r\n            this._prevMatchLength = matchLength;\r\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\r\n                return m;\r\n            }\r\n        } while (m);\r\n        return null;\r\n    };\r\n    return Searcher;\r\n}());\r\nexport { Searcher };\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * An event describing that a model has been reset to a new value.\r\n * @internal\r\n */\r\nvar ModelRawFlush = /** @class */ (function () {\r\n    function ModelRawFlush() {\r\n        this.changeType = 1 /* Flush */;\r\n    }\r\n    return ModelRawFlush;\r\n}());\r\nexport { ModelRawFlush };\r\n/**\r\n * An event describing that a line has changed in a model.\r\n * @internal\r\n */\r\nvar ModelRawLineChanged = /** @class */ (function () {\r\n    function ModelRawLineChanged(lineNumber, detail) {\r\n        this.changeType = 2 /* LineChanged */;\r\n        this.lineNumber = lineNumber;\r\n        this.detail = detail;\r\n    }\r\n    return ModelRawLineChanged;\r\n}());\r\nexport { ModelRawLineChanged };\r\n/**\r\n * An event describing that line(s) have been deleted in a model.\r\n * @internal\r\n */\r\nvar ModelRawLinesDeleted = /** @class */ (function () {\r\n    function ModelRawLinesDeleted(fromLineNumber, toLineNumber) {\r\n        this.changeType = 3 /* LinesDeleted */;\r\n        this.fromLineNumber = fromLineNumber;\r\n        this.toLineNumber = toLineNumber;\r\n    }\r\n    return ModelRawLinesDeleted;\r\n}());\r\nexport { ModelRawLinesDeleted };\r\n/**\r\n * An event describing that line(s) have been inserted in a model.\r\n * @internal\r\n */\r\nvar ModelRawLinesInserted = /** @class */ (function () {\r\n    function ModelRawLinesInserted(fromLineNumber, toLineNumber, detail) {\r\n        this.changeType = 4 /* LinesInserted */;\r\n        this.fromLineNumber = fromLineNumber;\r\n        this.toLineNumber = toLineNumber;\r\n        this.detail = detail;\r\n    }\r\n    return ModelRawLinesInserted;\r\n}());\r\nexport { ModelRawLinesInserted };\r\n/**\r\n * An event describing that a model has had its EOL changed.\r\n * @internal\r\n */\r\nvar ModelRawEOLChanged = /** @class */ (function () {\r\n    function ModelRawEOLChanged() {\r\n        this.changeType = 5 /* EOLChanged */;\r\n    }\r\n    return ModelRawEOLChanged;\r\n}());\r\nexport { ModelRawEOLChanged };\r\n/**\r\n * An event describing a change in the text of a model.\r\n * @internal\r\n */\r\nvar ModelRawContentChangedEvent = /** @class */ (function () {\r\n    function ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing) {\r\n        this.changes = changes;\r\n        this.versionId = versionId;\r\n        this.isUndoing = isUndoing;\r\n        this.isRedoing = isRedoing;\r\n    }\r\n    ModelRawContentChangedEvent.prototype.containsEvent = function (type) {\r\n        for (var i = 0, len = this.changes.length; i < len; i++) {\r\n            var change = this.changes[i];\r\n            if (change.changeType === type) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    ModelRawContentChangedEvent.merge = function (a, b) {\r\n        var changes = [].concat(a.changes).concat(b.changes);\r\n        var versionId = b.versionId;\r\n        var isUndoing = (a.isUndoing || b.isUndoing);\r\n        var isRedoing = (a.isRedoing || b.isRedoing);\r\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\r\n    };\r\n    return ModelRawContentChangedEvent;\r\n}());\r\nexport { ModelRawContentChangedEvent };\r\n/**\r\n * @internal\r\n */\r\nvar InternalModelContentChangeEvent = /** @class */ (function () {\r\n    function InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent) {\r\n        this.rawContentChangedEvent = rawContentChangedEvent;\r\n        this.contentChangedEvent = contentChangedEvent;\r\n    }\r\n    InternalModelContentChangeEvent.prototype.merge = function (other) {\r\n        var rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\r\n        var contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\r\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\r\n    };\r\n    InternalModelContentChangeEvent._mergeChangeEvents = function (a, b) {\r\n        var changes = [].concat(a.changes).concat(b.changes);\r\n        var eol = b.eol;\r\n        var versionId = b.versionId;\r\n        var isUndoing = (a.isUndoing || b.isUndoing);\r\n        var isRedoing = (a.isRedoing || b.isRedoing);\r\n        var isFlush = (a.isFlush || b.isFlush);\r\n        return {\r\n            changes: changes,\r\n            eol: eol,\r\n            versionId: versionId,\r\n            isUndoing: isUndoing,\r\n            isRedoing: isRedoing,\r\n            isFlush: isFlush\r\n        };\r\n    };\r\n    return InternalModelContentChangeEvent;\r\n}());\r\nexport { InternalModelContentChangeEvent };\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { TokenizationRegistry } from '../modes.js';\r\nimport { nullTokenize2 } from '../modes/nullMode.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport { StopWatch } from '../../../base/common/stopwatch.js';\r\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nvar TokenizationStateStore = /** @class */ (function () {\r\n    function TokenizationStateStore() {\r\n        this._beginState = [];\r\n        this._valid = [];\r\n        this._len = 0;\r\n        this._invalidLineStartIndex = 0;\r\n    }\r\n    TokenizationStateStore.prototype._reset = function (initialState) {\r\n        this._beginState = [];\r\n        this._valid = [];\r\n        this._len = 0;\r\n        this._invalidLineStartIndex = 0;\r\n        if (initialState) {\r\n            this._setBeginState(0, initialState);\r\n        }\r\n    };\r\n    TokenizationStateStore.prototype.flush = function (initialState) {\r\n        this._reset(initialState);\r\n    };\r\n    Object.defineProperty(TokenizationStateStore.prototype, \"invalidLineStartIndex\", {\r\n        get: function () {\r\n            return this._invalidLineStartIndex;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    TokenizationStateStore.prototype._invalidateLine = function (lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            this._valid[lineIndex] = false;\r\n        }\r\n        if (lineIndex < this._invalidLineStartIndex) {\r\n            this._invalidLineStartIndex = lineIndex;\r\n        }\r\n    };\r\n    TokenizationStateStore.prototype._isValid = function (lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            return this._valid[lineIndex];\r\n        }\r\n        return false;\r\n    };\r\n    TokenizationStateStore.prototype.getBeginState = function (lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            return this._beginState[lineIndex];\r\n        }\r\n        return null;\r\n    };\r\n    TokenizationStateStore.prototype._ensureLine = function (lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._beginState[this._len] = null;\r\n            this._valid[this._len] = false;\r\n            this._len++;\r\n        }\r\n    };\r\n    TokenizationStateStore.prototype._deleteLines = function (start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._beginState.splice(start, deleteCount);\r\n        this._valid.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    };\r\n    TokenizationStateStore.prototype._insertLines = function (insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        var beginState = [];\r\n        var valid = [];\r\n        for (var i = 0; i < insertCount; i++) {\r\n            beginState[i] = null;\r\n            valid[i] = false;\r\n        }\r\n        this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\r\n        this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\r\n        this._len += insertCount;\r\n    };\r\n    TokenizationStateStore.prototype._setValid = function (lineIndex, valid) {\r\n        this._ensureLine(lineIndex);\r\n        this._valid[lineIndex] = valid;\r\n    };\r\n    TokenizationStateStore.prototype._setBeginState = function (lineIndex, beginState) {\r\n        this._ensureLine(lineIndex);\r\n        this._beginState[lineIndex] = beginState;\r\n    };\r\n    TokenizationStateStore.prototype.setEndState = function (linesLength, lineIndex, endState) {\r\n        this._setValid(lineIndex, true);\r\n        this._invalidLineStartIndex = lineIndex + 1;\r\n        // Check if this was the last line\r\n        if (lineIndex === linesLength - 1) {\r\n            return;\r\n        }\r\n        // Check if the end state has changed\r\n        var previousEndState = this.getBeginState(lineIndex + 1);\r\n        if (previousEndState === null || !endState.equals(previousEndState)) {\r\n            this._setBeginState(lineIndex + 1, endState);\r\n            this._invalidateLine(lineIndex + 1);\r\n            return;\r\n        }\r\n        // Perhaps we can skip tokenizing some lines...\r\n        var i = lineIndex + 1;\r\n        while (i < linesLength) {\r\n            if (!this._isValid(i)) {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        this._invalidLineStartIndex = i;\r\n    };\r\n    TokenizationStateStore.prototype.setFakeTokens = function (lineIndex) {\r\n        this._setValid(lineIndex, false);\r\n    };\r\n    //#region Editing\r\n    TokenizationStateStore.prototype.applyEdits = function (range, eolCount) {\r\n        var deletingLinesCnt = range.endLineNumber - range.startLineNumber;\r\n        var insertingLinesCnt = eolCount;\r\n        var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n        for (var j = editingLinesCnt; j >= 0; j--) {\r\n            this._invalidateLine(range.startLineNumber + j - 1);\r\n        }\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\r\n    };\r\n    TokenizationStateStore.prototype._acceptDeleteRange = function (range) {\r\n        var firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    };\r\n    TokenizationStateStore.prototype._acceptInsertText = function (position, eolCount) {\r\n        var lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    };\r\n    return TokenizationStateStore;\r\n}());\r\nexport { TokenizationStateStore };\r\nvar TextModelTokenization = /** @class */ (function (_super) {\r\n    __extends(TextModelTokenization, _super);\r\n    function TextModelTokenization(textModel) {\r\n        var _this = _super.call(this) || this;\r\n        _this._isDisposed = false;\r\n        _this._textModel = textModel;\r\n        _this._tokenizationStateStore = new TokenizationStateStore();\r\n        _this._tokenizationSupport = null;\r\n        _this._register(TokenizationRegistry.onDidChange(function (e) {\r\n            var languageIdentifier = _this._textModel.getLanguageIdentifier();\r\n            if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\r\n                return;\r\n            }\r\n            _this._resetTokenizationState();\r\n            _this._textModel.clearTokens();\r\n        }));\r\n        _this._register(_this._textModel.onDidChangeRawContentFast(function (e) {\r\n            if (e.containsEvent(1 /* Flush */)) {\r\n                _this._resetTokenizationState();\r\n                return;\r\n            }\r\n        }));\r\n        _this._register(_this._textModel.onDidChangeContentFast(function (e) {\r\n            for (var i = 0, len = e.changes.length; i < len; i++) {\r\n                var change = e.changes[i];\r\n                var eolCount = countEOL(change.text)[0];\r\n                _this._tokenizationStateStore.applyEdits(change.range, eolCount);\r\n            }\r\n            _this._beginBackgroundTokenization();\r\n        }));\r\n        _this._register(_this._textModel.onDidChangeAttached(function () {\r\n            _this._beginBackgroundTokenization();\r\n        }));\r\n        _this._register(_this._textModel.onDidChangeLanguage(function () {\r\n            _this._resetTokenizationState();\r\n            _this._textModel.clearTokens();\r\n        }));\r\n        _this._resetTokenizationState();\r\n        return _this;\r\n    }\r\n    TextModelTokenization.prototype.dispose = function () {\r\n        this._isDisposed = true;\r\n        _super.prototype.dispose.call(this);\r\n    };\r\n    TextModelTokenization.prototype._resetTokenizationState = function () {\r\n        var _a = initializeTokenization(this._textModel), tokenizationSupport = _a[0], initialState = _a[1];\r\n        this._tokenizationSupport = tokenizationSupport;\r\n        this._tokenizationStateStore.flush(initialState);\r\n        this._beginBackgroundTokenization();\r\n    };\r\n    TextModelTokenization.prototype._beginBackgroundTokenization = function () {\r\n        var _this = this;\r\n        if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\r\n            platform.setImmediate(function () {\r\n                if (_this._isDisposed) {\r\n                    // disposed in the meantime\r\n                    return;\r\n                }\r\n                _this._revalidateTokensNow();\r\n            });\r\n        }\r\n    };\r\n    TextModelTokenization.prototype._revalidateTokensNow = function (toLineNumber) {\r\n        if (toLineNumber === void 0) { toLineNumber = this._textModel.getLineCount(); }\r\n        var MAX_ALLOWED_TIME = 1;\r\n        var builder = new MultilineTokensBuilder();\r\n        var sw = StopWatch.create(false);\r\n        while (this._hasLinesToTokenize()) {\r\n            if (sw.elapsed() > MAX_ALLOWED_TIME) {\r\n                // Stop if MAX_ALLOWED_TIME is reached\r\n                break;\r\n            }\r\n            var tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\r\n            if (tokenizedLineNumber >= toLineNumber) {\r\n                break;\r\n            }\r\n        }\r\n        this._beginBackgroundTokenization();\r\n        this._textModel.setTokens(builder.tokens);\r\n    };\r\n    TextModelTokenization.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {\r\n        var builder = new MultilineTokensBuilder();\r\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\r\n        this._textModel.setTokens(builder.tokens);\r\n    };\r\n    TextModelTokenization.prototype.reset = function () {\r\n        this._resetTokenizationState();\r\n        this._textModel.clearTokens();\r\n    };\r\n    TextModelTokenization.prototype.forceTokenization = function (lineNumber) {\r\n        var builder = new MultilineTokensBuilder();\r\n        this._updateTokensUntilLine(builder, lineNumber);\r\n        this._textModel.setTokens(builder.tokens);\r\n    };\r\n    TextModelTokenization.prototype.isCheapToTokenize = function (lineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            return true;\r\n        }\r\n        var firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\r\n        if (lineNumber > firstInvalidLineNumber) {\r\n            return false;\r\n        }\r\n        if (lineNumber < firstInvalidLineNumber) {\r\n            return true;\r\n        }\r\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    TextModelTokenization.prototype._hasLinesToTokenize = function () {\r\n        if (!this._tokenizationSupport) {\r\n            return false;\r\n        }\r\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\r\n    };\r\n    TextModelTokenization.prototype._tokenizeOneInvalidLine = function (builder) {\r\n        if (!this._hasLinesToTokenize()) {\r\n            return this._textModel.getLineCount() + 1;\r\n        }\r\n        var lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\r\n        this._updateTokensUntilLine(builder, lineNumber);\r\n        return lineNumber;\r\n    };\r\n    TextModelTokenization.prototype._updateTokensUntilLine = function (builder, lineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            return;\r\n        }\r\n        var languageIdentifier = this._textModel.getLanguageIdentifier();\r\n        var linesLength = this._textModel.getLineCount();\r\n        var endLineIndex = lineNumber - 1;\r\n        // Validate all states up to and including endLineIndex\r\n        for (var lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\r\n            var text = this._textModel.getLineContent(lineIndex + 1);\r\n            var lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\r\n            var r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, lineStartState);\r\n            builder.add(lineIndex + 1, r.tokens);\r\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\r\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\r\n        }\r\n    };\r\n    TextModelTokenization.prototype._tokenizeViewport = function (builder, startLineNumber, endLineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            // nothing to do\r\n            return;\r\n        }\r\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\r\n            // nothing to do\r\n            return;\r\n        }\r\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\r\n            // tokenization has reached the viewport start...\r\n            this._updateTokensUntilLine(builder, endLineNumber);\r\n            return;\r\n        }\r\n        var nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\r\n        var fakeLines = [];\r\n        var initialState = null;\r\n        for (var i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\r\n            var newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\r\n            if (newNonWhitespaceIndex === 0) {\r\n                continue;\r\n            }\r\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\r\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\r\n                if (initialState) {\r\n                    break;\r\n                }\r\n                fakeLines.push(this._textModel.getLineContent(i));\r\n                nonWhitespaceColumn = newNonWhitespaceIndex;\r\n            }\r\n        }\r\n        if (!initialState) {\r\n            initialState = this._tokenizationSupport.getInitialState();\r\n        }\r\n        var languageIdentifier = this._textModel.getLanguageIdentifier();\r\n        var state = initialState;\r\n        for (var i = fakeLines.length - 1; i >= 0; i--) {\r\n            var r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], state);\r\n            state = r.endState;\r\n        }\r\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            var text = this._textModel.getLineContent(lineNumber);\r\n            var r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, state);\r\n            builder.add(lineNumber, r.tokens);\r\n            this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\r\n            state = r.endState;\r\n        }\r\n    };\r\n    return TextModelTokenization;\r\n}(Disposable));\r\nexport { TextModelTokenization };\r\nfunction initializeTokenization(textModel) {\r\n    var languageIdentifier = textModel.getLanguageIdentifier();\r\n    var tokenizationSupport = (textModel.isTooLargeForTokenization()\r\n        ? null\r\n        : TokenizationRegistry.get(languageIdentifier.language));\r\n    var initialState = null;\r\n    if (tokenizationSupport) {\r\n        try {\r\n            initialState = tokenizationSupport.getInitialState();\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n            tokenizationSupport = null;\r\n        }\r\n    }\r\n    return [tokenizationSupport, initialState];\r\n}\r\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, state) {\r\n    var r = null;\r\n    if (tokenizationSupport) {\r\n        try {\r\n            r = tokenizationSupport.tokenize2(text, state.clone(), 0);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n        }\r\n    }\r\n    if (!r) {\r\n        r = nullTokenize2(languageIdentifier.id, text, state, 0);\r\n    }\r\n    LineTokens.convertToEndOffset(r.tokens, text.length);\r\n    return r;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { URI } from '../../../base/common/uri.js';\r\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport * as model from '../model.js';\r\nimport { EditStack } from './editStack.js';\r\nimport { guessIndentation } from './indentationGuesser.js';\r\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\r\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\r\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\r\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\r\nimport { TextModelTokenization } from './textModelTokens.js';\r\nimport { getWordAtText } from './wordHelper.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\r\nimport { ignoreBracketsInToken } from '../modes/supports.js';\r\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\r\nimport { withUndefinedAsNull } from '../../../base/common/types.js';\r\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\r\nimport { Color } from '../../../base/common/color.js';\r\nfunction createTextBufferBuilder() {\r\n    return new PieceTreeTextBufferBuilder();\r\n}\r\nexport function createTextBufferFactory(text) {\r\n    var builder = createTextBufferBuilder();\r\n    builder.acceptChunk(text);\r\n    return builder.finish();\r\n}\r\nexport function createTextBuffer(value, defaultEOL) {\r\n    var factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\r\n    return factory.create(defaultEOL);\r\n}\r\nvar MODEL_ID = 0;\r\nvar LIMIT_FIND_COUNT = 999;\r\nexport var LONG_LINE_BOUNDARY = 10000;\r\nvar invalidFunc = function () { throw new Error(\"Invalid change accessor\"); };\r\nvar TextModel = /** @class */ (function (_super) {\r\n    __extends(TextModel, _super);\r\n    //#endregion\r\n    function TextModel(source, creationOptions, languageIdentifier, associatedResource) {\r\n        if (associatedResource === void 0) { associatedResource = null; }\r\n        var _this = _super.call(this) || this;\r\n        //#region Events\r\n        _this._onWillDispose = _this._register(new Emitter());\r\n        _this.onWillDispose = _this._onWillDispose.event;\r\n        _this._onDidChangeDecorations = _this._register(new DidChangeDecorationsEmitter());\r\n        _this.onDidChangeDecorations = _this._onDidChangeDecorations.event;\r\n        _this._onDidChangeLanguage = _this._register(new Emitter());\r\n        _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;\r\n        _this._onDidChangeLanguageConfiguration = _this._register(new Emitter());\r\n        _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;\r\n        _this._onDidChangeTokens = _this._register(new Emitter());\r\n        _this.onDidChangeTokens = _this._onDidChangeTokens.event;\r\n        _this._onDidChangeOptions = _this._register(new Emitter());\r\n        _this.onDidChangeOptions = _this._onDidChangeOptions.event;\r\n        _this._onDidChangeAttached = _this._register(new Emitter());\r\n        _this.onDidChangeAttached = _this._onDidChangeAttached.event;\r\n        _this._eventEmitter = _this._register(new DidChangeContentEmitter());\r\n        // Generate a new unique model id\r\n        MODEL_ID++;\r\n        _this.id = '$model' + MODEL_ID;\r\n        _this.isForSimpleWidget = creationOptions.isForSimpleWidget;\r\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\r\n            _this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\r\n        }\r\n        else {\r\n            _this._associatedResource = associatedResource;\r\n        }\r\n        _this._attachedEditorCount = 0;\r\n        _this._buffer = createTextBuffer(source, creationOptions.defaultEOL);\r\n        _this._options = TextModel.resolveOptions(_this._buffer, creationOptions);\r\n        var bufferLineCount = _this._buffer.getLineCount();\r\n        var bufferTextLength = _this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, _this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\r\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\r\n        // If a model is too large at construction time, it will never get tokenized,\r\n        // under no circumstances.\r\n        if (creationOptions.largeFileOptimizations) {\r\n            _this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\r\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\r\n        }\r\n        else {\r\n            _this._isTooLargeForTokenization = false;\r\n        }\r\n        _this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\r\n        _this._versionId = 1;\r\n        _this._alternativeVersionId = 1;\r\n        _this._isDisposed = false;\r\n        _this._isDisposing = false;\r\n        _this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\r\n        _this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange(function (e) {\r\n            if (e.languageIdentifier.id === _this._languageIdentifier.id) {\r\n                _this._onDidChangeLanguageConfiguration.fire({});\r\n            }\r\n        });\r\n        _this._instanceId = strings.singleLetterHash(MODEL_ID);\r\n        _this._lastDecorationId = 0;\r\n        _this._decorations = Object.create(null);\r\n        _this._decorationsTree = new DecorationsTrees();\r\n        _this._commandManager = new EditStack(_this);\r\n        _this._isUndoing = false;\r\n        _this._isRedoing = false;\r\n        _this._trimAutoWhitespaceLines = null;\r\n        _this._tokens = new TokensStore();\r\n        _this._tokens2 = new TokensStore2();\r\n        _this._tokenization = new TextModelTokenization(_this);\r\n        return _this;\r\n    }\r\n    TextModel.createFromString = function (text, options, languageIdentifier, uri) {\r\n        if (options === void 0) { options = TextModel.DEFAULT_CREATION_OPTIONS; }\r\n        if (languageIdentifier === void 0) { languageIdentifier = null; }\r\n        if (uri === void 0) { uri = null; }\r\n        return new TextModel(text, options, languageIdentifier, uri);\r\n    };\r\n    TextModel.resolveOptions = function (textBuffer, options) {\r\n        if (options.detectIndentation) {\r\n            var guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\r\n            return new model.TextModelResolvedOptions({\r\n                tabSize: guessedIndentation.tabSize,\r\n                indentSize: guessedIndentation.tabSize,\r\n                insertSpaces: guessedIndentation.insertSpaces,\r\n                trimAutoWhitespace: options.trimAutoWhitespace,\r\n                defaultEOL: options.defaultEOL\r\n            });\r\n        }\r\n        return new model.TextModelResolvedOptions({\r\n            tabSize: options.tabSize,\r\n            indentSize: options.indentSize,\r\n            insertSpaces: options.insertSpaces,\r\n            trimAutoWhitespace: options.trimAutoWhitespace,\r\n            defaultEOL: options.defaultEOL\r\n        });\r\n    };\r\n    TextModel.prototype.onDidChangeRawContentFast = function (listener) {\r\n        return this._eventEmitter.fastEvent(function (e) { return listener(e.rawContentChangedEvent); });\r\n    };\r\n    TextModel.prototype.onDidChangeRawContent = function (listener) {\r\n        return this._eventEmitter.slowEvent(function (e) { return listener(e.rawContentChangedEvent); });\r\n    };\r\n    TextModel.prototype.onDidChangeContentFast = function (listener) {\r\n        return this._eventEmitter.fastEvent(function (e) { return listener(e.contentChangedEvent); });\r\n    };\r\n    TextModel.prototype.onDidChangeContent = function (listener) {\r\n        return this._eventEmitter.slowEvent(function (e) { return listener(e.contentChangedEvent); });\r\n    };\r\n    TextModel.prototype.dispose = function () {\r\n        this._isDisposing = true;\r\n        this._onWillDispose.fire();\r\n        this._languageRegistryListener.dispose();\r\n        this._tokenization.dispose();\r\n        this._isDisposed = true;\r\n        _super.prototype.dispose.call(this);\r\n        this._isDisposing = false;\r\n    };\r\n    TextModel.prototype._assertNotDisposed = function () {\r\n        if (this._isDisposed) {\r\n            throw new Error('Model is disposed!');\r\n        }\r\n    };\r\n    TextModel.prototype._emitContentChangedEvent = function (rawChange, change) {\r\n        if (this._isDisposing) {\r\n            // Do not confuse listeners by emitting any event after disposing\r\n            return;\r\n        }\r\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\r\n    };\r\n    TextModel.prototype.setValue = function (value) {\r\n        this._assertNotDisposed();\r\n        if (value === null) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        var textBuffer = createTextBuffer(value, this._options.defaultEOL);\r\n        this.setValueFromTextBuffer(textBuffer);\r\n    };\r\n    TextModel.prototype._createContentChanged2 = function (range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\r\n        return {\r\n            changes: [{\r\n                    range: range,\r\n                    rangeOffset: rangeOffset,\r\n                    rangeLength: rangeLength,\r\n                    text: text,\r\n                }],\r\n            eol: this._buffer.getEOL(),\r\n            versionId: this.getVersionId(),\r\n            isUndoing: isUndoing,\r\n            isRedoing: isRedoing,\r\n            isFlush: isFlush\r\n        };\r\n    };\r\n    TextModel.prototype.setValueFromTextBuffer = function (textBuffer) {\r\n        this._assertNotDisposed();\r\n        if (textBuffer === null) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        var oldFullModelRange = this.getFullModelRange();\r\n        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\r\n        var endLineNumber = this.getLineCount();\r\n        var endColumn = this.getLineMaxColumn(endLineNumber);\r\n        this._buffer = textBuffer;\r\n        this._increaseVersionId();\r\n        // Flush all tokens\r\n        this._tokens.flush();\r\n        this._tokens2.flush();\r\n        // Destroy all my decorations\r\n        this._decorations = Object.create(null);\r\n        this._decorationsTree = new DecorationsTrees();\r\n        // Destroy my edit history and settings\r\n        this._commandManager = new EditStack(this);\r\n        this._trimAutoWhitespaceLines = null;\r\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\r\n            new ModelRawFlush()\r\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\r\n    };\r\n    TextModel.prototype.setEOL = function (eol) {\r\n        this._assertNotDisposed();\r\n        var newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\r\n        if (this._buffer.getEOL() === newEOL) {\r\n            // Nothing to do\r\n            return;\r\n        }\r\n        var oldFullModelRange = this.getFullModelRange();\r\n        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\r\n        var endLineNumber = this.getLineCount();\r\n        var endColumn = this.getLineMaxColumn(endLineNumber);\r\n        this._onBeforeEOLChange();\r\n        this._buffer.setEOL(newEOL);\r\n        this._increaseVersionId();\r\n        this._onAfterEOLChange();\r\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\r\n            new ModelRawEOLChanged()\r\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\r\n    };\r\n    TextModel.prototype._onBeforeEOLChange = function () {\r\n        // Ensure all decorations get their `range` set.\r\n        var versionId = this.getVersionId();\r\n        var allDecorations = this._decorationsTree.search(0, false, false, versionId);\r\n        this._ensureNodesHaveRanges(allDecorations);\r\n    };\r\n    TextModel.prototype._onAfterEOLChange = function () {\r\n        // Transform back `range` to offsets\r\n        var versionId = this.getVersionId();\r\n        var allDecorations = this._decorationsTree.collectNodesPostOrder();\r\n        for (var i = 0, len = allDecorations.length; i < len; i++) {\r\n            var node = allDecorations[i];\r\n            var delta = node.cachedAbsoluteStart - node.start;\r\n            var startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\r\n            var endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\r\n            node.cachedAbsoluteStart = startOffset;\r\n            node.cachedAbsoluteEnd = endOffset;\r\n            node.cachedVersionId = versionId;\r\n            node.start = startOffset - delta;\r\n            node.end = endOffset - delta;\r\n            recomputeMaxEnd(node);\r\n        }\r\n    };\r\n    TextModel.prototype.onBeforeAttached = function () {\r\n        this._attachedEditorCount++;\r\n        if (this._attachedEditorCount === 1) {\r\n            this._onDidChangeAttached.fire(undefined);\r\n        }\r\n    };\r\n    TextModel.prototype.onBeforeDetached = function () {\r\n        this._attachedEditorCount--;\r\n        if (this._attachedEditorCount === 0) {\r\n            this._onDidChangeAttached.fire(undefined);\r\n        }\r\n    };\r\n    TextModel.prototype.isAttachedToEditor = function () {\r\n        return this._attachedEditorCount > 0;\r\n    };\r\n    TextModel.prototype.getAttachedEditorCount = function () {\r\n        return this._attachedEditorCount;\r\n    };\r\n    TextModel.prototype.isTooLargeForSyncing = function () {\r\n        return this._isTooLargeForSyncing;\r\n    };\r\n    TextModel.prototype.isTooLargeForTokenization = function () {\r\n        return this._isTooLargeForTokenization;\r\n    };\r\n    TextModel.prototype.isDisposed = function () {\r\n        return this._isDisposed;\r\n    };\r\n    TextModel.prototype.isDominatedByLongLines = function () {\r\n        this._assertNotDisposed();\r\n        if (this.isTooLargeForTokenization()) {\r\n            // Cannot word wrap huge files anyways, so it doesn't really matter\r\n            return false;\r\n        }\r\n        var smallLineCharCount = 0;\r\n        var longLineCharCount = 0;\r\n        var lineCount = this._buffer.getLineCount();\r\n        for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\r\n            var lineLength = this._buffer.getLineLength(lineNumber);\r\n            if (lineLength >= LONG_LINE_BOUNDARY) {\r\n                longLineCharCount += lineLength;\r\n            }\r\n            else {\r\n                smallLineCharCount += lineLength;\r\n            }\r\n        }\r\n        return (longLineCharCount > smallLineCharCount);\r\n    };\r\n    Object.defineProperty(TextModel.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._associatedResource;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    //#region Options\r\n    TextModel.prototype.getOptions = function () {\r\n        this._assertNotDisposed();\r\n        return this._options;\r\n    };\r\n    TextModel.prototype.getFormattingOptions = function () {\r\n        return {\r\n            tabSize: this._options.indentSize,\r\n            insertSpaces: this._options.insertSpaces\r\n        };\r\n    };\r\n    TextModel.prototype.updateOptions = function (_newOpts) {\r\n        this._assertNotDisposed();\r\n        var tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\r\n        var indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\r\n        var insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\r\n        var trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\r\n        var newOpts = new model.TextModelResolvedOptions({\r\n            tabSize: tabSize,\r\n            indentSize: indentSize,\r\n            insertSpaces: insertSpaces,\r\n            defaultEOL: this._options.defaultEOL,\r\n            trimAutoWhitespace: trimAutoWhitespace\r\n        });\r\n        if (this._options.equals(newOpts)) {\r\n            return;\r\n        }\r\n        var e = this._options.createChangeEvent(newOpts);\r\n        this._options = newOpts;\r\n        this._onDidChangeOptions.fire(e);\r\n    };\r\n    TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {\r\n        this._assertNotDisposed();\r\n        var guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\r\n        this.updateOptions({\r\n            insertSpaces: guessedIndentation.insertSpaces,\r\n            tabSize: guessedIndentation.tabSize,\r\n            indentSize: guessedIndentation.tabSize,\r\n        });\r\n    };\r\n    TextModel._normalizeIndentationFromWhitespace = function (str, indentSize, insertSpaces) {\r\n        var spacesCnt = 0;\r\n        for (var i = 0; i < str.length; i++) {\r\n            if (str.charAt(i) === '\\t') {\r\n                spacesCnt += indentSize;\r\n            }\r\n            else {\r\n                spacesCnt++;\r\n            }\r\n        }\r\n        var result = '';\r\n        if (!insertSpaces) {\r\n            var tabsCnt = Math.floor(spacesCnt / indentSize);\r\n            spacesCnt = spacesCnt % indentSize;\r\n            for (var i = 0; i < tabsCnt; i++) {\r\n                result += '\\t';\r\n            }\r\n        }\r\n        for (var i = 0; i < spacesCnt; i++) {\r\n            result += ' ';\r\n        }\r\n        return result;\r\n    };\r\n    TextModel.normalizeIndentation = function (str, indentSize, insertSpaces) {\r\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\r\n        if (firstNonWhitespaceIndex === -1) {\r\n            firstNonWhitespaceIndex = str.length;\r\n        }\r\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\r\n    };\r\n    TextModel.prototype.normalizeIndentation = function (str) {\r\n        this._assertNotDisposed();\r\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\r\n    };\r\n    //#endregion\r\n    //#region Reading\r\n    TextModel.prototype.getVersionId = function () {\r\n        this._assertNotDisposed();\r\n        return this._versionId;\r\n    };\r\n    TextModel.prototype.mightContainRTL = function () {\r\n        return this._buffer.mightContainRTL();\r\n    };\r\n    TextModel.prototype.mightContainNonBasicASCII = function () {\r\n        return this._buffer.mightContainNonBasicASCII();\r\n    };\r\n    TextModel.prototype.getAlternativeVersionId = function () {\r\n        this._assertNotDisposed();\r\n        return this._alternativeVersionId;\r\n    };\r\n    TextModel.prototype.getOffsetAt = function (rawPosition) {\r\n        this._assertNotDisposed();\r\n        var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\r\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\r\n    };\r\n    TextModel.prototype.getPositionAt = function (rawOffset) {\r\n        this._assertNotDisposed();\r\n        var offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\r\n        return this._buffer.getPositionAt(offset);\r\n    };\r\n    TextModel.prototype._increaseVersionId = function () {\r\n        this._versionId = this._versionId + 1;\r\n        this._alternativeVersionId = this._versionId;\r\n    };\r\n    TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {\r\n        this._alternativeVersionId = newAlternativeVersionId;\r\n    };\r\n    TextModel.prototype.getValue = function (eol, preserveBOM) {\r\n        if (preserveBOM === void 0) { preserveBOM = false; }\r\n        this._assertNotDisposed();\r\n        var fullModelRange = this.getFullModelRange();\r\n        var fullModelValue = this.getValueInRange(fullModelRange, eol);\r\n        if (preserveBOM) {\r\n            return this._buffer.getBOM() + fullModelValue;\r\n        }\r\n        return fullModelValue;\r\n    };\r\n    TextModel.prototype.getValueLength = function (eol, preserveBOM) {\r\n        if (preserveBOM === void 0) { preserveBOM = false; }\r\n        this._assertNotDisposed();\r\n        var fullModelRange = this.getFullModelRange();\r\n        var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\r\n        if (preserveBOM) {\r\n            return this._buffer.getBOM().length + fullModelValue;\r\n        }\r\n        return fullModelValue;\r\n    };\r\n    TextModel.prototype.getValueInRange = function (rawRange, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        this._assertNotDisposed();\r\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\r\n    };\r\n    TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        this._assertNotDisposed();\r\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\r\n    };\r\n    TextModel.prototype.getCharacterCountInRange = function (rawRange, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        this._assertNotDisposed();\r\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\r\n    };\r\n    TextModel.prototype.getLineCount = function () {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getLineCount();\r\n    };\r\n    TextModel.prototype.getLineContent = function (lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineContent(lineNumber);\r\n    };\r\n    TextModel.prototype.getLineLength = function (lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLength(lineNumber);\r\n    };\r\n    TextModel.prototype.getLinesContent = function () {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getLinesContent();\r\n    };\r\n    TextModel.prototype.getEOL = function () {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getEOL();\r\n    };\r\n    TextModel.prototype.getLineMinColumn = function (lineNumber) {\r\n        this._assertNotDisposed();\r\n        return 1;\r\n    };\r\n    TextModel.prototype.getLineMaxColumn = function (lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLength(lineNumber) + 1;\r\n    };\r\n    TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\r\n    };\r\n    TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\r\n    };\r\n    /**\r\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\r\n     * Will try to not allocate if possible.\r\n     */\r\n    TextModel.prototype._validateRangeRelaxedNoAllocations = function (range) {\r\n        var linesCount = this._buffer.getLineCount();\r\n        var initialStartLineNumber = range.startLineNumber;\r\n        var initialStartColumn = range.startColumn;\r\n        var startLineNumber;\r\n        var startColumn;\r\n        if (initialStartLineNumber < 1) {\r\n            startLineNumber = 1;\r\n            startColumn = 1;\r\n        }\r\n        else if (initialStartLineNumber > linesCount) {\r\n            startLineNumber = linesCount;\r\n            startColumn = this.getLineMaxColumn(startLineNumber);\r\n        }\r\n        else {\r\n            startLineNumber = initialStartLineNumber | 0;\r\n            if (initialStartColumn <= 1) {\r\n                startColumn = 1;\r\n            }\r\n            else {\r\n                var maxColumn = this.getLineMaxColumn(startLineNumber);\r\n                if (initialStartColumn >= maxColumn) {\r\n                    startColumn = maxColumn;\r\n                }\r\n                else {\r\n                    startColumn = initialStartColumn | 0;\r\n                }\r\n            }\r\n        }\r\n        var initialEndLineNumber = range.endLineNumber;\r\n        var initialEndColumn = range.endColumn;\r\n        var endLineNumber;\r\n        var endColumn;\r\n        if (initialEndLineNumber < 1) {\r\n            endLineNumber = 1;\r\n            endColumn = 1;\r\n        }\r\n        else if (initialEndLineNumber > linesCount) {\r\n            endLineNumber = linesCount;\r\n            endColumn = this.getLineMaxColumn(endLineNumber);\r\n        }\r\n        else {\r\n            endLineNumber = initialEndLineNumber | 0;\r\n            if (initialEndColumn <= 1) {\r\n                endColumn = 1;\r\n            }\r\n            else {\r\n                var maxColumn = this.getLineMaxColumn(endLineNumber);\r\n                if (initialEndColumn >= maxColumn) {\r\n                    endColumn = maxColumn;\r\n                }\r\n                else {\r\n                    endColumn = initialEndColumn | 0;\r\n                }\r\n            }\r\n        }\r\n        if (initialStartLineNumber === startLineNumber\r\n            && initialStartColumn === startColumn\r\n            && initialEndLineNumber === endLineNumber\r\n            && initialEndColumn === endColumn\r\n            && range instanceof Range\r\n            && !(range instanceof Selection)) {\r\n            return range;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    };\r\n    TextModel.prototype._isValidPosition = function (lineNumber, column, validationType) {\r\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\r\n            return false;\r\n        }\r\n        if (isNaN(lineNumber) || isNaN(column)) {\r\n            return false;\r\n        }\r\n        if (lineNumber < 1 || column < 1) {\r\n            return false;\r\n        }\r\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\r\n            return false;\r\n        }\r\n        var lineCount = this._buffer.getLineCount();\r\n        if (lineNumber > lineCount) {\r\n            return false;\r\n        }\r\n        if (column === 1) {\r\n            return true;\r\n        }\r\n        var maxColumn = this.getLineMaxColumn(lineNumber);\r\n        if (column > maxColumn) {\r\n            return false;\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            // !!At this point, column > 1\r\n            var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\r\n            if (strings.isHighSurrogate(charCodeBefore)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    TextModel.prototype._validatePosition = function (_lineNumber, _column, validationType) {\r\n        var lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\r\n        var column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\r\n        var lineCount = this._buffer.getLineCount();\r\n        if (lineNumber < 1) {\r\n            return new Position(1, 1);\r\n        }\r\n        if (lineNumber > lineCount) {\r\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\r\n        }\r\n        if (column <= 1) {\r\n            return new Position(lineNumber, 1);\r\n        }\r\n        var maxColumn = this.getLineMaxColumn(lineNumber);\r\n        if (column >= maxColumn) {\r\n            return new Position(lineNumber, maxColumn);\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            // If the position would end up in the middle of a high-low surrogate pair,\r\n            // we move it to before the pair\r\n            // !!At this point, column > 1\r\n            var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\r\n            if (strings.isHighSurrogate(charCodeBefore)) {\r\n                return new Position(lineNumber, column - 1);\r\n            }\r\n        }\r\n        return new Position(lineNumber, column);\r\n    };\r\n    TextModel.prototype.validatePosition = function (position) {\r\n        var validationType = 1 /* SurrogatePairs */;\r\n        this._assertNotDisposed();\r\n        // Avoid object allocation and cover most likely case\r\n        if (position instanceof Position) {\r\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\r\n                return position;\r\n            }\r\n        }\r\n        return this._validatePosition(position.lineNumber, position.column, validationType);\r\n    };\r\n    TextModel.prototype._isValidRange = function (range, validationType) {\r\n        var startLineNumber = range.startLineNumber;\r\n        var startColumn = range.startColumn;\r\n        var endLineNumber = range.endLineNumber;\r\n        var endColumn = range.endColumn;\r\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\r\n            return false;\r\n        }\r\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\r\n            return false;\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\r\n            var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\r\n            var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\r\n            var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\r\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    TextModel.prototype.validateRange = function (_range) {\r\n        var validationType = 1 /* SurrogatePairs */;\r\n        this._assertNotDisposed();\r\n        // Avoid object allocation and cover most likely case\r\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\r\n            if (this._isValidRange(_range, validationType)) {\r\n                return _range;\r\n            }\r\n        }\r\n        var start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\r\n        var end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\r\n        var startLineNumber = start.lineNumber;\r\n        var startColumn = start.column;\r\n        var endLineNumber = end.lineNumber;\r\n        var endColumn = end.column;\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\r\n            var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\r\n            var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\r\n            var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\r\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\r\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            }\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\r\n                // do not expand a collapsed range, simply move it to a valid location\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\r\n            }\r\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\r\n                // expand range at both ends\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\r\n            }\r\n            if (startInsideSurrogatePair) {\r\n                // only expand range at the start\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\r\n            }\r\n            // only expand range at the end\r\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    };\r\n    TextModel.prototype.modifyPosition = function (rawPosition, offset) {\r\n        this._assertNotDisposed();\r\n        var candidate = this.getOffsetAt(rawPosition) + offset;\r\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\r\n    };\r\n    TextModel.prototype.getFullModelRange = function () {\r\n        this._assertNotDisposed();\r\n        var lineCount = this.getLineCount();\r\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\r\n    };\r\n    TextModel.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    };\r\n    TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount) {\r\n        if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }\r\n        this._assertNotDisposed();\r\n        var searchRange;\r\n        if (Range.isIRange(rawSearchScope)) {\r\n            searchRange = this.validateRange(rawSearchScope);\r\n        }\r\n        else {\r\n            searchRange = this.getFullModelRange();\r\n        }\r\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\r\n            // not regex, not multi line\r\n            var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\r\n            var searchData = searchParams.parseSearchRequest();\r\n            if (!searchData) {\r\n                return [];\r\n            }\r\n            return this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n        }\r\n        return TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\r\n    };\r\n    TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\r\n        this._assertNotDisposed();\r\n        var searchStart = this.validatePosition(rawSearchStart);\r\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\r\n            var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\r\n            var searchData = searchParams.parseSearchRequest();\r\n            if (!searchData) {\r\n                return null;\r\n            }\r\n            var lineCount = this.getLineCount();\r\n            var searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\r\n            var ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\r\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n            if (ret.length > 0) {\r\n                return ret[0];\r\n            }\r\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\r\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\r\n            if (ret.length > 0) {\r\n                return ret[0];\r\n            }\r\n            return null;\r\n        }\r\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n    };\r\n    TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\r\n        this._assertNotDisposed();\r\n        var searchStart = this.validatePosition(rawSearchStart);\r\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n    };\r\n    //#endregion\r\n    //#region Editing\r\n    TextModel.prototype.pushStackElement = function () {\r\n        this._commandManager.pushStackElement();\r\n    };\r\n    TextModel.prototype.pushEOL = function (eol) {\r\n        var currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\r\n        if (currentEOL === eol) {\r\n            return;\r\n        }\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            this._commandManager.pushEOL(eol);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype._pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {\r\n        var _this = this;\r\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\r\n            // Go through each saved line number and insert a trim whitespace edit\r\n            // if it is safe to do so (no conflicts with other edits).\r\n            var incomingEdits = editOperations.map(function (op) {\r\n                return {\r\n                    range: _this.validateRange(op.range),\r\n                    text: op.text\r\n                };\r\n            });\r\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\r\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\r\n            var editsAreNearCursors = true;\r\n            for (var i = 0, len = beforeCursorState.length; i < len; i++) {\r\n                var sel = beforeCursorState[i];\r\n                var foundEditNearSel = false;\r\n                for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\r\n                    var editRange = incomingEdits[j].range;\r\n                    var selIsAbove = editRange.startLineNumber > sel.endLineNumber;\r\n                    var selIsBelow = sel.startLineNumber > editRange.endLineNumber;\r\n                    if (!selIsAbove && !selIsBelow) {\r\n                        foundEditNearSel = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!foundEditNearSel) {\r\n                    editsAreNearCursors = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (editsAreNearCursors) {\r\n                for (var i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\r\n                    var trimLineNumber = this._trimAutoWhitespaceLines[i];\r\n                    var maxLineColumn = this.getLineMaxColumn(trimLineNumber);\r\n                    var allowTrimLine = true;\r\n                    for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\r\n                        var editRange = incomingEdits[j].range;\r\n                        var editText = incomingEdits[j].text;\r\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\r\n                            // `trimLine` is completely outside this edit\r\n                            continue;\r\n                        }\r\n                        // At this point:\r\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\r\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\r\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\r\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\r\n                            continue;\r\n                        }\r\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\r\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\r\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\r\n                            continue;\r\n                        }\r\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\r\n                        allowTrimLine = false;\r\n                        break;\r\n                    }\r\n                    if (allowTrimLine) {\r\n                        editOperations.push({\r\n                            range: new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),\r\n                            text: null\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            this._trimAutoWhitespaceLines = null;\r\n        }\r\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\r\n    };\r\n    TextModel.prototype.applyEdits = function (rawOperations) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            return this._applyEdits(rawOperations);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype._applyEdits = function (rawOperations) {\r\n        for (var i = 0, len = rawOperations.length; i < len; i++) {\r\n            rawOperations[i].range = this.validateRange(rawOperations[i].range);\r\n        }\r\n        var oldLineCount = this._buffer.getLineCount();\r\n        var result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);\r\n        var newLineCount = this._buffer.getLineCount();\r\n        var contentChanges = result.changes;\r\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\r\n        if (contentChanges.length !== 0) {\r\n            var rawContentChanges = [];\r\n            var lineCount = oldLineCount;\r\n            for (var i = 0, len = contentChanges.length; i < len; i++) {\r\n                var change = contentChanges[i];\r\n                var _a = countEOL(change.text), eolCount = _a[0], firstLineLength = _a[1], lastLineLength = _a[2];\r\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\r\n                this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\r\n                this._onDidChangeDecorations.fire();\r\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\r\n                var startLineNumber = change.range.startLineNumber;\r\n                var endLineNumber = change.range.endLineNumber;\r\n                var deletingLinesCnt = endLineNumber - startLineNumber;\r\n                var insertingLinesCnt = eolCount;\r\n                var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n                var changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\r\n                for (var j = editingLinesCnt; j >= 0; j--) {\r\n                    var editLineNumber = startLineNumber + j;\r\n                    var currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\r\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\r\n                }\r\n                if (editingLinesCnt < deletingLinesCnt) {\r\n                    // Must delete some lines\r\n                    var spliceStartLineNumber = startLineNumber + editingLinesCnt;\r\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\r\n                }\r\n                if (editingLinesCnt < insertingLinesCnt) {\r\n                    // Must insert some lines\r\n                    var spliceLineNumber = startLineNumber + editingLinesCnt;\r\n                    var cnt = insertingLinesCnt - editingLinesCnt;\r\n                    var fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\r\n                    var newLines = [];\r\n                    for (var i_1 = 0; i_1 < cnt; i_1++) {\r\n                        var lineNumber = fromLineNumber + i_1;\r\n                        newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\r\n                    }\r\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\r\n                }\r\n                lineCount += changeLineCountDelta;\r\n            }\r\n            this._increaseVersionId();\r\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\r\n                changes: contentChanges,\r\n                eol: this._buffer.getEOL(),\r\n                versionId: this.getVersionId(),\r\n                isUndoing: this._isUndoing,\r\n                isRedoing: this._isRedoing,\r\n                isFlush: false\r\n            });\r\n        }\r\n        return result.reverseEdits;\r\n    };\r\n    TextModel.prototype._undo = function () {\r\n        this._isUndoing = true;\r\n        var r = this._commandManager.undo();\r\n        this._isUndoing = false;\r\n        if (!r) {\r\n            return null;\r\n        }\r\n        this._overwriteAlternativeVersionId(r.recordedVersionId);\r\n        return r.selections;\r\n    };\r\n    TextModel.prototype.undo = function () {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            return this._undo();\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype.canUndo = function () {\r\n        return this._commandManager.canUndo();\r\n    };\r\n    TextModel.prototype._redo = function () {\r\n        this._isRedoing = true;\r\n        var r = this._commandManager.redo();\r\n        this._isRedoing = false;\r\n        if (!r) {\r\n            return null;\r\n        }\r\n        this._overwriteAlternativeVersionId(r.recordedVersionId);\r\n        return r.selections;\r\n    };\r\n    TextModel.prototype.redo = function () {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            return this._redo();\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype.canRedo = function () {\r\n        return this._commandManager.canRedo();\r\n    };\r\n    //#endregion\r\n    //#region Decorations\r\n    TextModel.prototype.changeDecorations = function (callback, ownerId) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        this._assertNotDisposed();\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            return this._changeDecorations(ownerId, callback);\r\n        }\r\n        finally {\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype._changeDecorations = function (ownerId, callback) {\r\n        var _this = this;\r\n        var changeAccessor = {\r\n            addDecoration: function (range, options) {\r\n                _this._onDidChangeDecorations.fire();\r\n                return _this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\r\n            },\r\n            changeDecoration: function (id, newRange) {\r\n                _this._onDidChangeDecorations.fire();\r\n                _this._changeDecorationImpl(id, newRange);\r\n            },\r\n            changeDecorationOptions: function (id, options) {\r\n                _this._onDidChangeDecorations.fire();\r\n                _this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\r\n            },\r\n            removeDecoration: function (id) {\r\n                _this._onDidChangeDecorations.fire();\r\n                _this._deltaDecorationsImpl(ownerId, [id], []);\r\n            },\r\n            deltaDecorations: function (oldDecorations, newDecorations) {\r\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\r\n                    // nothing to do\r\n                    return [];\r\n                }\r\n                _this._onDidChangeDecorations.fire();\r\n                return _this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\r\n            }\r\n        };\r\n        var result = null;\r\n        try {\r\n            result = callback(changeAccessor);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n        }\r\n        // Invalidate change accessor\r\n        changeAccessor.addDecoration = invalidFunc;\r\n        changeAccessor.changeDecoration = invalidFunc;\r\n        changeAccessor.changeDecorationOptions = invalidFunc;\r\n        changeAccessor.removeDecoration = invalidFunc;\r\n        changeAccessor.deltaDecorations = invalidFunc;\r\n        return result;\r\n    };\r\n    TextModel.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        this._assertNotDisposed();\r\n        if (!oldDecorations) {\r\n            oldDecorations = [];\r\n        }\r\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\r\n            // nothing to do\r\n            return [];\r\n        }\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._onDidChangeDecorations.fire();\r\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\r\n        }\r\n        finally {\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    };\r\n    TextModel.prototype._getTrackedRange = function (id) {\r\n        return this.getDecorationRange(id);\r\n    };\r\n    TextModel.prototype._setTrackedRange = function (id, newRange, newStickiness) {\r\n        var node = (id ? this._decorations[id] : null);\r\n        if (!node) {\r\n            if (!newRange) {\r\n                // node doesn't exist, the request is to delete => nothing to do\r\n                return null;\r\n            }\r\n            // node doesn't exist, the request is to set => add the tracked range\r\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\r\n        }\r\n        if (!newRange) {\r\n            // node exists, the request is to delete => delete node\r\n            this._decorationsTree.delete(node);\r\n            delete this._decorations[node.id];\r\n            return null;\r\n        }\r\n        // node exists, the request is to set => change the tracked range and its options\r\n        var range = this._validateRangeRelaxedNoAllocations(newRange);\r\n        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        this._decorationsTree.delete(node);\r\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\r\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\r\n        this._decorationsTree.insert(node);\r\n        return node.id;\r\n    };\r\n    TextModel.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        var nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            var node = nodes[i];\r\n            this._decorationsTree.delete(node);\r\n            delete this._decorations[node.id];\r\n        }\r\n    };\r\n    TextModel.prototype.getDecorationOptions = function (decorationId) {\r\n        var node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        return node.options;\r\n    };\r\n    TextModel.prototype.getDecorationRange = function (decorationId) {\r\n        var node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        var versionId = this.getVersionId();\r\n        if (node.cachedVersionId !== versionId) {\r\n            this._decorationsTree.resolveNode(node, versionId);\r\n        }\r\n        if (node.range === null) {\r\n            node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\r\n        }\r\n        return node.range;\r\n    };\r\n    TextModel.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            return [];\r\n        }\r\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\r\n    };\r\n    TextModel.prototype.getLinesDecorations = function (_startLineNumber, _endLineNumber, ownerId, filterOutValidation) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\r\n        var lineCount = this.getLineCount();\r\n        var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\r\n        var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\r\n        var endColumn = this.getLineMaxColumn(endLineNumber);\r\n        return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\r\n    };\r\n    TextModel.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\r\n        var validatedRange = this.validateRange(range);\r\n        return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\r\n    };\r\n    TextModel.prototype.getOverviewRulerDecorations = function (ownerId, filterOutValidation) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\r\n        var versionId = this.getVersionId();\r\n        var result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    };\r\n    TextModel.prototype.getAllDecorations = function (ownerId, filterOutValidation) {\r\n        if (ownerId === void 0) { ownerId = 0; }\r\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\r\n        var versionId = this.getVersionId();\r\n        var result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    };\r\n    TextModel.prototype._getDecorationsInRange = function (filterRange, filterOwnerId, filterOutValidation) {\r\n        var startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\r\n        var endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\r\n        var versionId = this.getVersionId();\r\n        var result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    };\r\n    TextModel.prototype._ensureNodesHaveRanges = function (nodes) {\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            var node = nodes[i];\r\n            if (node.range === null) {\r\n                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\r\n            }\r\n        }\r\n        return nodes;\r\n    };\r\n    TextModel.prototype._getRangeAt = function (start, end) {\r\n        return this._buffer.getRangeAt(start, end - start);\r\n    };\r\n    TextModel.prototype._changeDecorationImpl = function (decorationId, _range) {\r\n        var node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        var range = this._validateRangeRelaxedNoAllocations(_range);\r\n        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        this._decorationsTree.delete(node);\r\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\r\n        this._decorationsTree.insert(node);\r\n    };\r\n    TextModel.prototype._changeDecorationOptionsImpl = function (decorationId, options) {\r\n        var node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        var nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\r\n        var nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\r\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\r\n            // Delete + Insert due to an overview ruler status change\r\n            this._decorationsTree.delete(node);\r\n            node.setOptions(options);\r\n            this._decorationsTree.insert(node);\r\n        }\r\n        else {\r\n            node.setOptions(options);\r\n        }\r\n    };\r\n    TextModel.prototype._deltaDecorationsImpl = function (ownerId, oldDecorationsIds, newDecorations) {\r\n        var versionId = this.getVersionId();\r\n        var oldDecorationsLen = oldDecorationsIds.length;\r\n        var oldDecorationIndex = 0;\r\n        var newDecorationsLen = newDecorations.length;\r\n        var newDecorationIndex = 0;\r\n        var result = new Array(newDecorationsLen);\r\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\r\n            var node = null;\r\n            if (oldDecorationIndex < oldDecorationsLen) {\r\n                // (1) get ourselves an old node\r\n                do {\r\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\r\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\r\n                // (2) remove the node from the tree (if it exists)\r\n                if (node) {\r\n                    this._decorationsTree.delete(node);\r\n                }\r\n            }\r\n            if (newDecorationIndex < newDecorationsLen) {\r\n                // (3) create a new node if necessary\r\n                if (!node) {\r\n                    var internalDecorationId = (++this._lastDecorationId);\r\n                    var decorationId = this._instanceId + \";\" + internalDecorationId;\r\n                    node = new IntervalNode(decorationId, 0, 0);\r\n                    this._decorations[decorationId] = node;\r\n                }\r\n                // (4) initialize node\r\n                var newDecoration = newDecorations[newDecorationIndex];\r\n                var range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\r\n                var options = _normalizeOptions(newDecoration.options);\r\n                var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n                var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n                node.ownerId = ownerId;\r\n                node.reset(versionId, startOffset, endOffset, range);\r\n                node.setOptions(options);\r\n                this._decorationsTree.insert(node);\r\n                result[newDecorationIndex] = node.id;\r\n                newDecorationIndex++;\r\n            }\r\n            else {\r\n                if (node) {\r\n                    delete this._decorations[node.id];\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    //#endregion\r\n    //#region Tokenization\r\n    TextModel.prototype.setLineTokens = function (lineNumber, tokens) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), tokens);\r\n    };\r\n    TextModel.prototype.setTokens = function (tokens) {\r\n        if (tokens.length === 0) {\r\n            return;\r\n        }\r\n        var ranges = [];\r\n        for (var i = 0, len = tokens.length; i < len; i++) {\r\n            var element = tokens[i];\r\n            ranges.push({ fromLineNumber: element.startLineNumber, toLineNumber: element.startLineNumber + element.tokens.length - 1 });\r\n            for (var j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\r\n                this.setLineTokens(element.startLineNumber + j, element.tokens[j]);\r\n            }\r\n        }\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: false,\r\n            ranges: ranges\r\n        });\r\n    };\r\n    TextModel.prototype.setSemanticTokens = function (tokens) {\r\n        this._tokens2.set(tokens);\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: false,\r\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\r\n        });\r\n    };\r\n    TextModel.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {\r\n        startLineNumber = Math.max(1, startLineNumber);\r\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\r\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\r\n    };\r\n    TextModel.prototype.clearTokens = function () {\r\n        this._tokens.flush();\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: true,\r\n            ranges: [{\r\n                    fromLineNumber: 1,\r\n                    toLineNumber: this._buffer.getLineCount()\r\n                }]\r\n        });\r\n    };\r\n    TextModel.prototype._emitModelTokensChangedEvent = function (e) {\r\n        if (!this._isDisposing) {\r\n            this._onDidChangeTokens.fire(e);\r\n        }\r\n    };\r\n    TextModel.prototype.resetTokenization = function () {\r\n        this._tokenization.reset();\r\n    };\r\n    TextModel.prototype.forceTokenization = function (lineNumber) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        this._tokenization.forceTokenization(lineNumber);\r\n    };\r\n    TextModel.prototype.isCheapToTokenize = function (lineNumber) {\r\n        return this._tokenization.isCheapToTokenize(lineNumber);\r\n    };\r\n    TextModel.prototype.tokenizeIfCheap = function (lineNumber) {\r\n        if (this.isCheapToTokenize(lineNumber)) {\r\n            this.forceTokenization(lineNumber);\r\n        }\r\n    };\r\n    TextModel.prototype.getLineTokens = function (lineNumber) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._getLineTokens(lineNumber);\r\n    };\r\n    TextModel.prototype._getLineTokens = function (lineNumber) {\r\n        var lineText = this.getLineContent(lineNumber);\r\n        var syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\r\n        return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\r\n    };\r\n    TextModel.prototype.getLanguageIdentifier = function () {\r\n        return this._languageIdentifier;\r\n    };\r\n    TextModel.prototype.getModeId = function () {\r\n        return this._languageIdentifier.language;\r\n    };\r\n    TextModel.prototype.setMode = function (languageIdentifier) {\r\n        if (this._languageIdentifier.id === languageIdentifier.id) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        var e = {\r\n            oldLanguage: this._languageIdentifier.language,\r\n            newLanguage: languageIdentifier.language\r\n        };\r\n        this._languageIdentifier = languageIdentifier;\r\n        this._onDidChangeLanguage.fire(e);\r\n        this._onDidChangeLanguageConfiguration.fire({});\r\n    };\r\n    TextModel.prototype.getLanguageIdAtPosition = function (lineNumber, column) {\r\n        var position = this.validatePosition(new Position(lineNumber, column));\r\n        var lineTokens = this.getLineTokens(position.lineNumber);\r\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\r\n    };\r\n    // Having tokens allows implementing additional helper methods\r\n    TextModel.prototype.getWordAtPosition = function (_position) {\r\n        this._assertNotDisposed();\r\n        var position = this.validatePosition(_position);\r\n        var lineContent = this.getLineContent(position.lineNumber);\r\n        var lineTokens = this._getLineTokens(position.lineNumber);\r\n        var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n        // (1). First try checking right biased word\r\n        var _a = TextModel._findLanguageBoundaries(lineTokens, tokenIndex), rbStartOffset = _a[0], rbEndOffset = _a[1];\r\n        var rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\r\n        // Make sure the result touches the original passed in position\r\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\r\n            return rightBiasedWord;\r\n        }\r\n        // (2). Else, if we were at a language boundary, check the left biased word\r\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\r\n            // edge case, where `position` sits between two tokens belonging to two different languages\r\n            var _b = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1), lbStartOffset = _b[0], lbEndOffset = _b[1];\r\n            var leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\r\n            // Make sure the result touches the original passed in position\r\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\r\n                return leftBiasedWord;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel._findLanguageBoundaries = function (lineTokens, tokenIndex) {\r\n        var languageId = lineTokens.getLanguageId(tokenIndex);\r\n        // go left until a different language is hit\r\n        var startOffset = 0;\r\n        for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\r\n            startOffset = lineTokens.getStartOffset(i);\r\n        }\r\n        // go right until a different language is hit\r\n        var endOffset = lineTokens.getLineContent().length;\r\n        for (var i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\r\n            endOffset = lineTokens.getEndOffset(i);\r\n        }\r\n        return [startOffset, endOffset];\r\n    };\r\n    TextModel.prototype.getWordUntilPosition = function (position) {\r\n        var wordAtPosition = this.getWordAtPosition(position);\r\n        if (!wordAtPosition) {\r\n            return {\r\n                word: '',\r\n                startColumn: position.column,\r\n                endColumn: position.column\r\n            };\r\n        }\r\n        return {\r\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\r\n            startColumn: wordAtPosition.startColumn,\r\n            endColumn: position.column\r\n        };\r\n    };\r\n    TextModel.prototype.findMatchingBracketUp = function (_bracket, _position) {\r\n        var bracket = _bracket.toLowerCase();\r\n        var position = this.validatePosition(_position);\r\n        var lineTokens = this._getLineTokens(position.lineNumber);\r\n        var languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\r\n        var bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n        if (!bracketsSupport) {\r\n            return null;\r\n        }\r\n        var data = bracketsSupport.textIsBracket[bracket];\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        return this._findMatchingBracketUp(data, position);\r\n    };\r\n    TextModel.prototype.matchBracket = function (position) {\r\n        return this._matchBracket(this.validatePosition(position));\r\n    };\r\n    TextModel.prototype._matchBracket = function (position) {\r\n        var lineNumber = position.lineNumber;\r\n        var lineTokens = this._getLineTokens(lineNumber);\r\n        var tokenCount = lineTokens.getCount();\r\n        var lineText = this._buffer.getLineContent(lineNumber);\r\n        var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n        if (tokenIndex < 0) {\r\n            return null;\r\n        }\r\n        var currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\r\n        // check that the token is not to be ignored\r\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\r\n            // limit search to not go before `maxBracketLength`\r\n            var searchStartOffset = Math.max(0, position.column - 1 - currentModeBrackets.maxBracketLength);\r\n            for (var i = tokenIndex - 1; i >= 0; i--) {\r\n                var tokenEndOffset = lineTokens.getEndOffset(i);\r\n                if (tokenEndOffset <= searchStartOffset) {\r\n                    break;\r\n                }\r\n                if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\r\n                    searchStartOffset = tokenEndOffset;\r\n                }\r\n            }\r\n            // limit search to not go after `maxBracketLength`\r\n            var searchEndOffset = Math.min(lineText.length, position.column - 1 + currentModeBrackets.maxBracketLength);\r\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\r\n            // `bestResult` will contain the most right-side result\r\n            var bestResult = null;\r\n            while (true) {\r\n                var foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!foundBracket) {\r\n                    // there are no more brackets in this text\r\n                    break;\r\n                }\r\n                // check that we didn't hit a bracket too far away from position\r\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\r\n                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\r\n                    var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);\r\n                    if (r) {\r\n                        bestResult = r;\r\n                    }\r\n                }\r\n                searchStartOffset = foundBracket.endColumn - 1;\r\n            }\r\n            if (bestResult) {\r\n                return bestResult;\r\n            }\r\n        }\r\n        // If position is in between two tokens, try also looking in the previous token\r\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\r\n            var prevTokenIndex = tokenIndex - 1;\r\n            var prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex));\r\n            // check that previous token is not to be ignored\r\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\r\n                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\r\n                var searchStartOffset = Math.max(0, position.column - 1 - prevModeBrackets.maxBracketLength);\r\n                var searchEndOffset = Math.min(lineText.length, position.column - 1 + prevModeBrackets.maxBracketLength);\r\n                for (var i = prevTokenIndex + 1; i < tokenCount; i++) {\r\n                    var tokenStartOffset = lineTokens.getStartOffset(i);\r\n                    if (tokenStartOffset >= searchEndOffset) {\r\n                        break;\r\n                    }\r\n                    if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\r\n                        searchEndOffset = tokenStartOffset;\r\n                    }\r\n                }\r\n                var foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                // check that we didn't hit a bracket too far away from position\r\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\r\n                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\r\n                    var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);\r\n                    if (r) {\r\n                        return r;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        if (isOpen) {\r\n            var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());\r\n            if (matched) {\r\n                return [foundBracket, matched];\r\n            }\r\n        }\r\n        else {\r\n            var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());\r\n            if (matched) {\r\n                return [foundBracket, matched];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype._findMatchingBracketUp = function (bracket, position) {\r\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\r\n        var languageId = bracket.languageIdentifier.id;\r\n        var reversedBracketRegex = bracket.reversedRegex;\r\n        var count = -1;\r\n        var searchPrevMatchingBracketInRange = function (lineNumber, lineText, searchStartOffset, searchEndOffset) {\r\n            while (true) {\r\n                var r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                if (bracket.isOpen(hitText)) {\r\n                    count++;\r\n                }\r\n                else if (bracket.isClose(hitText)) {\r\n                    count--;\r\n                }\r\n                if (count === 0) {\r\n                    return r;\r\n                }\r\n                searchEndOffset = r.startColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\r\n            var lineTokens = this._getLineTokens(lineNumber);\r\n            var tokenCount = lineTokens.getCount();\r\n            var lineText = this._buffer.getLineContent(lineNumber);\r\n            var tokenIndex = tokenCount - 1;\r\n            var searchStartOffset = lineText.length;\r\n            var searchEndOffset = lineText.length;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n            }\r\n            var prevSearchInToken = true;\r\n            for (; tokenIndex >= 0; tokenIndex--) {\r\n                var searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchStartOffset\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                var r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype._findMatchingBracketDown = function (bracket, position) {\r\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\r\n        var languageId = bracket.languageIdentifier.id;\r\n        var bracketRegex = bracket.forwardRegex;\r\n        var count = 1;\r\n        var searchNextMatchingBracketInRange = function (lineNumber, lineText, searchStartOffset, searchEndOffset) {\r\n            while (true) {\r\n                var r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                if (bracket.isOpen(hitText)) {\r\n                    count++;\r\n                }\r\n                else if (bracket.isClose(hitText)) {\r\n                    count--;\r\n                }\r\n                if (count === 0) {\r\n                    return r;\r\n                }\r\n                searchStartOffset = r.endColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        var lineCount = this.getLineCount();\r\n        for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            var lineTokens = this._getLineTokens(lineNumber);\r\n            var tokenCount = lineTokens.getCount();\r\n            var lineText = this._buffer.getLineContent(lineNumber);\r\n            var tokenIndex = 0;\r\n            var searchStartOffset = 0;\r\n            var searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n            }\r\n            var prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                var searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                var r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype.findPrevBracket = function (_position) {\r\n        var position = this.validatePosition(_position);\r\n        var languageId = -1;\r\n        var modeBrackets = null;\r\n        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\r\n            var lineTokens = this._getLineTokens(lineNumber);\r\n            var tokenCount = lineTokens.getCount();\r\n            var lineText = this._buffer.getLineContent(lineNumber);\r\n            var tokenIndex = tokenCount - 1;\r\n            var searchStartOffset = lineText.length;\r\n            var searchEndOffset = lineText.length;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n            }\r\n            var prevSearchInToken = true;\r\n            for (; tokenIndex >= 0; tokenIndex--) {\r\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n                var searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchStartOffset\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                var r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return this._toFoundBracket(modeBrackets, r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype.findNextBracket = function (_position) {\r\n        var position = this.validatePosition(_position);\r\n        var lineCount = this.getLineCount();\r\n        var languageId = -1;\r\n        var modeBrackets = null;\r\n        for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            var lineTokens = this._getLineTokens(lineNumber);\r\n            var tokenCount = lineTokens.getCount();\r\n            var lineText = this._buffer.getLineContent(lineNumber);\r\n            var tokenIndex = 0;\r\n            var searchStartOffset = 0;\r\n            var searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n            }\r\n            var prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n                var searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return this._toFoundBracket(modeBrackets, r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype.findEnclosingBrackets = function (_position, maxDuration) {\r\n        var _this = this;\r\n        if (maxDuration === void 0) { maxDuration = 1073741824 /* MAX_SAFE_SMALL_INTEGER */; }\r\n        var position = this.validatePosition(_position);\r\n        var lineCount = this.getLineCount();\r\n        var savedCounts = new Map();\r\n        var counts = [];\r\n        var resetCounts = function (languageId, modeBrackets) {\r\n            if (!savedCounts.has(languageId)) {\r\n                var tmp = [];\r\n                for (var i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\r\n                    tmp[i] = 0;\r\n                }\r\n                savedCounts.set(languageId, tmp);\r\n            }\r\n            counts = savedCounts.get(languageId);\r\n        };\r\n        var searchInRange = function (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) {\r\n            while (true) {\r\n                var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                var bracket = modeBrackets.textIsBracket[hitText];\r\n                if (bracket) {\r\n                    if (bracket.isOpen(hitText)) {\r\n                        counts[bracket.index]++;\r\n                    }\r\n                    else if (bracket.isClose(hitText)) {\r\n                        counts[bracket.index]--;\r\n                    }\r\n                    if (counts[bracket.index] === -1) {\r\n                        return _this._matchFoundBracket(r, bracket, false);\r\n                    }\r\n                }\r\n                searchStartOffset = r.endColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        var languageId = -1;\r\n        var modeBrackets = null;\r\n        var startTime = Date.now();\r\n        for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            var elapsedTime = Date.now() - startTime;\r\n            if (elapsedTime > maxDuration) {\r\n                return null;\r\n            }\r\n            var lineTokens = this._getLineTokens(lineNumber);\r\n            var tokenCount = lineTokens.getCount();\r\n            var lineText = this._buffer.getLineContent(lineNumber);\r\n            var tokenIndex = 0;\r\n            var searchStartOffset = 0;\r\n            var searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                    resetCounts(languageId, modeBrackets);\r\n                }\r\n            }\r\n            var prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                    resetCounts(languageId, modeBrackets);\r\n                }\r\n                var searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        var r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                var r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModel.prototype._toFoundBracket = function (modeBrackets, r) {\r\n        if (!r) {\r\n            return null;\r\n        }\r\n        var text = this.getValueInRange(r);\r\n        text = text.toLowerCase();\r\n        var data = modeBrackets.textIsBracket[text];\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        return {\r\n            range: r,\r\n            open: data.open,\r\n            close: data.close,\r\n            isOpen: modeBrackets.textIsOpenBracket[text]\r\n        };\r\n    };\r\n    /**\r\n     * Returns:\r\n     *  - -1 => the line consists of whitespace\r\n     *  - otherwise => the indent level is returned value\r\n     */\r\n    TextModel.computeIndentLevel = function (line, tabSize) {\r\n        var indent = 0;\r\n        var i = 0;\r\n        var len = line.length;\r\n        while (i < len) {\r\n            var chCode = line.charCodeAt(i);\r\n            if (chCode === 32 /* Space */) {\r\n                indent++;\r\n            }\r\n            else if (chCode === 9 /* Tab */) {\r\n                indent = indent - indent % tabSize + tabSize;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        if (i === len) {\r\n            return -1; // line only consists of whitespace\r\n        }\r\n        return indent;\r\n    };\r\n    TextModel.prototype._computeIndentLevel = function (lineIndex) {\r\n        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\r\n    };\r\n    TextModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {\r\n        var _this = this;\r\n        this._assertNotDisposed();\r\n        var lineCount = this.getLineCount();\r\n        if (lineNumber < 1 || lineNumber > lineCount) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\r\n        var offSide = Boolean(foldingRules && foldingRules.offSide);\r\n        var up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        var up_aboveContentLineIndent = -1;\r\n        var up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        var up_belowContentLineIndent = -1;\r\n        var up_resolveIndents = function (lineNumber) {\r\n            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\r\n                up_aboveContentLineIndex = -1;\r\n                up_aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    var indent_1 = _this._computeIndentLevel(lineIndex);\r\n                    if (indent_1 >= 0) {\r\n                        up_aboveContentLineIndex = lineIndex;\r\n                        up_aboveContentLineIndent = indent_1;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (up_belowContentLineIndex === -2) {\r\n                up_belowContentLineIndex = -1;\r\n                up_belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    var indent_2 = _this._computeIndentLevel(lineIndex);\r\n                    if (indent_2 >= 0) {\r\n                        up_belowContentLineIndex = lineIndex;\r\n                        up_belowContentLineIndent = indent_2;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        var down_aboveContentLineIndent = -1;\r\n        var down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        var down_belowContentLineIndent = -1;\r\n        var down_resolveIndents = function (lineNumber) {\r\n            if (down_aboveContentLineIndex === -2) {\r\n                down_aboveContentLineIndex = -1;\r\n                down_aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    var indent_3 = _this._computeIndentLevel(lineIndex);\r\n                    if (indent_3 >= 0) {\r\n                        down_aboveContentLineIndex = lineIndex;\r\n                        down_aboveContentLineIndent = indent_3;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\r\n                down_belowContentLineIndex = -1;\r\n                down_belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    var indent_4 = _this._computeIndentLevel(lineIndex);\r\n                    if (indent_4 >= 0) {\r\n                        down_belowContentLineIndex = lineIndex;\r\n                        down_belowContentLineIndent = indent_4;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var startLineNumber = 0;\r\n        var goUp = true;\r\n        var endLineNumber = 0;\r\n        var goDown = true;\r\n        var indent = 0;\r\n        for (var distance = 0; goUp || goDown; distance++) {\r\n            var upLineNumber = lineNumber - distance;\r\n            var downLineNumber = lineNumber + distance;\r\n            if (distance !== 0 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\r\n                goUp = false;\r\n            }\r\n            if (distance !== 0 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\r\n                goDown = false;\r\n            }\r\n            if (distance > 50000) {\r\n                // stop processing\r\n                goUp = false;\r\n                goDown = false;\r\n            }\r\n            if (goUp) {\r\n                // compute indent level going up\r\n                var upLineIndentLevel = void 0;\r\n                var currentIndent = this._computeIndentLevel(upLineNumber - 1);\r\n                if (currentIndent >= 0) {\r\n                    // This line has content (besides whitespace)\r\n                    // Use the line's indent\r\n                    up_belowContentLineIndex = upLineNumber - 1;\r\n                    up_belowContentLineIndent = currentIndent;\r\n                    upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\r\n                }\r\n                else {\r\n                    up_resolveIndents(upLineNumber);\r\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\r\n                }\r\n                if (distance === 0) {\r\n                    // This is the initial line number\r\n                    startLineNumber = upLineNumber;\r\n                    endLineNumber = downLineNumber;\r\n                    indent = upLineIndentLevel;\r\n                    if (indent === 0) {\r\n                        // No need to continue\r\n                        return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };\r\n                    }\r\n                    continue;\r\n                }\r\n                if (upLineIndentLevel >= indent) {\r\n                    startLineNumber = upLineNumber;\r\n                }\r\n                else {\r\n                    goUp = false;\r\n                }\r\n            }\r\n            if (goDown) {\r\n                // compute indent level going down\r\n                var downLineIndentLevel = void 0;\r\n                var currentIndent = this._computeIndentLevel(downLineNumber - 1);\r\n                if (currentIndent >= 0) {\r\n                    // This line has content (besides whitespace)\r\n                    // Use the line's indent\r\n                    down_aboveContentLineIndex = downLineNumber - 1;\r\n                    down_aboveContentLineIndent = currentIndent;\r\n                    downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\r\n                }\r\n                else {\r\n                    down_resolveIndents(downLineNumber);\r\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\r\n                }\r\n                if (downLineIndentLevel >= indent) {\r\n                    endLineNumber = downLineNumber;\r\n                }\r\n                else {\r\n                    goDown = false;\r\n                }\r\n            }\r\n        }\r\n        return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };\r\n    };\r\n    TextModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {\r\n        this._assertNotDisposed();\r\n        var lineCount = this.getLineCount();\r\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\r\n            throw new Error('Illegal value for startLineNumber');\r\n        }\r\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\r\n            throw new Error('Illegal value for endLineNumber');\r\n        }\r\n        var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\r\n        var offSide = Boolean(foldingRules && foldingRules.offSide);\r\n        var result = new Array(endLineNumber - startLineNumber + 1);\r\n        var aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        var aboveContentLineIndent = -1;\r\n        var belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        var belowContentLineIndent = -1;\r\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            var resultIndex = lineNumber - startLineNumber;\r\n            var currentIndent = this._computeIndentLevel(lineNumber - 1);\r\n            if (currentIndent >= 0) {\r\n                // This line has content (besides whitespace)\r\n                // Use the line's indent\r\n                aboveContentLineIndex = lineNumber - 1;\r\n                aboveContentLineIndent = currentIndent;\r\n                result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\r\n                continue;\r\n            }\r\n            if (aboveContentLineIndex === -2) {\r\n                aboveContentLineIndex = -1;\r\n                aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    var indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        aboveContentLineIndex = lineIndex;\r\n                        aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\r\n                belowContentLineIndex = -1;\r\n                belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    var indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        belowContentLineIndex = lineIndex;\r\n                        belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\r\n        }\r\n        return result;\r\n    };\r\n    TextModel.prototype._getIndentLevelForWhitespaceLine = function (offSide, aboveContentLineIndent, belowContentLineIndent) {\r\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\r\n            // At the top or bottom of the file\r\n            return 0;\r\n        }\r\n        else if (aboveContentLineIndent < belowContentLineIndent) {\r\n            // we are inside the region above\r\n            return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\r\n        }\r\n        else if (aboveContentLineIndent === belowContentLineIndent) {\r\n            // we are in between two regions\r\n            return Math.ceil(belowContentLineIndent / this._options.indentSize);\r\n        }\r\n        else {\r\n            if (offSide) {\r\n                // same level as region below\r\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\r\n            }\r\n            else {\r\n                // we are inside the region that ends below\r\n                return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\r\n            }\r\n        }\r\n    };\r\n    TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\r\n    TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\r\n    TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\r\n    TextModel.DEFAULT_CREATION_OPTIONS = {\r\n        isForSimpleWidget: false,\r\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\r\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\r\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\r\n        detectIndentation: false,\r\n        defaultEOL: 1 /* LF */,\r\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\r\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\r\n    };\r\n    return TextModel;\r\n}(Disposable));\r\nexport { TextModel };\r\n//#region Decorations\r\nvar DecorationsTrees = /** @class */ (function () {\r\n    function DecorationsTrees() {\r\n        this._decorationsTree0 = new IntervalTree();\r\n        this._decorationsTree1 = new IntervalTree();\r\n    }\r\n    DecorationsTrees.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        var r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n        var r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n        return r0.concat(r1);\r\n    };\r\n    DecorationsTrees.prototype.search = function (filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\r\n        if (overviewRulerOnly) {\r\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n        }\r\n        else {\r\n            var r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n            var r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n            return r0.concat(r1);\r\n        }\r\n    };\r\n    DecorationsTrees.prototype.collectNodesFromOwner = function (ownerId) {\r\n        var r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\r\n        var r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\r\n        return r0.concat(r1);\r\n    };\r\n    DecorationsTrees.prototype.collectNodesPostOrder = function () {\r\n        var r0 = this._decorationsTree0.collectNodesPostOrder();\r\n        var r1 = this._decorationsTree1.collectNodesPostOrder();\r\n        return r0.concat(r1);\r\n    };\r\n    DecorationsTrees.prototype.insert = function (node) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.insert(node);\r\n        }\r\n        else {\r\n            this._decorationsTree0.insert(node);\r\n        }\r\n    };\r\n    DecorationsTrees.prototype.delete = function (node) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.delete(node);\r\n        }\r\n        else {\r\n            this._decorationsTree0.delete(node);\r\n        }\r\n    };\r\n    DecorationsTrees.prototype.resolveNode = function (node, cachedVersionId) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\r\n        }\r\n        else {\r\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\r\n        }\r\n    };\r\n    DecorationsTrees.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\r\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\r\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\r\n    };\r\n    return DecorationsTrees;\r\n}());\r\nfunction cleanClassName(className) {\r\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\r\n}\r\nvar DecorationOptions = /** @class */ (function () {\r\n    function DecorationOptions(options) {\r\n        this.color = options.color || '';\r\n        this.darkColor = options.darkColor || '';\r\n    }\r\n    return DecorationOptions;\r\n}());\r\nvar ModelDecorationOverviewRulerOptions = /** @class */ (function (_super) {\r\n    __extends(ModelDecorationOverviewRulerOptions, _super);\r\n    function ModelDecorationOverviewRulerOptions(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this._resolvedColor = null;\r\n        _this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\r\n        return _this;\r\n    }\r\n    ModelDecorationOverviewRulerOptions.prototype.getColor = function (theme) {\r\n        if (!this._resolvedColor) {\r\n            if (theme.type !== 'light' && this.darkColor) {\r\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\r\n            }\r\n            else {\r\n                this._resolvedColor = this._resolveColor(this.color, theme);\r\n            }\r\n        }\r\n        return this._resolvedColor;\r\n    };\r\n    ModelDecorationOverviewRulerOptions.prototype.invalidateCachedColor = function () {\r\n        this._resolvedColor = null;\r\n    };\r\n    ModelDecorationOverviewRulerOptions.prototype._resolveColor = function (color, theme) {\r\n        if (typeof color === 'string') {\r\n            return color;\r\n        }\r\n        var c = color ? theme.getColor(color.id) : null;\r\n        if (!c) {\r\n            return '';\r\n        }\r\n        return c.toString();\r\n    };\r\n    return ModelDecorationOverviewRulerOptions;\r\n}(DecorationOptions));\r\nexport { ModelDecorationOverviewRulerOptions };\r\nvar ModelDecorationMinimapOptions = /** @class */ (function (_super) {\r\n    __extends(ModelDecorationMinimapOptions, _super);\r\n    function ModelDecorationMinimapOptions(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this.position = options.position;\r\n        return _this;\r\n    }\r\n    ModelDecorationMinimapOptions.prototype.getColor = function (theme) {\r\n        if (!this._resolvedColor) {\r\n            if (theme.type !== 'light' && this.darkColor) {\r\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\r\n            }\r\n            else {\r\n                this._resolvedColor = this._resolveColor(this.color, theme);\r\n            }\r\n        }\r\n        return this._resolvedColor;\r\n    };\r\n    ModelDecorationMinimapOptions.prototype.invalidateCachedColor = function () {\r\n        this._resolvedColor = undefined;\r\n    };\r\n    ModelDecorationMinimapOptions.prototype._resolveColor = function (color, theme) {\r\n        if (typeof color === 'string') {\r\n            return Color.fromHex(color);\r\n        }\r\n        return theme.getColor(color.id);\r\n    };\r\n    return ModelDecorationMinimapOptions;\r\n}(DecorationOptions));\r\nexport { ModelDecorationMinimapOptions };\r\nvar ModelDecorationOptions = /** @class */ (function () {\r\n    function ModelDecorationOptions(options) {\r\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\r\n        this.zIndex = options.zIndex || 0;\r\n        this.className = options.className ? cleanClassName(options.className) : null;\r\n        this.hoverMessage = withUndefinedAsNull(options.hoverMessage);\r\n        this.glyphMarginHoverMessage = withUndefinedAsNull(options.glyphMarginHoverMessage);\r\n        this.isWholeLine = options.isWholeLine || false;\r\n        this.showIfCollapsed = options.showIfCollapsed || false;\r\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\r\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\r\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\r\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\r\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\r\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\r\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\r\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\r\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\r\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\r\n    }\r\n    ModelDecorationOptions.register = function (options) {\r\n        return new ModelDecorationOptions(options);\r\n    };\r\n    ModelDecorationOptions.createDynamic = function (options) {\r\n        return new ModelDecorationOptions(options);\r\n    };\r\n    return ModelDecorationOptions;\r\n}());\r\nexport { ModelDecorationOptions };\r\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\r\n/**\r\n * The order carefully matches the values of the enum.\r\n */\r\nvar TRACKED_RANGE_OPTIONS = [\r\n    ModelDecorationOptions.register({ stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\r\n    ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\r\n    ModelDecorationOptions.register({ stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\r\n    ModelDecorationOptions.register({ stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\r\n];\r\nfunction _normalizeOptions(options) {\r\n    if (options instanceof ModelDecorationOptions) {\r\n        return options;\r\n    }\r\n    return ModelDecorationOptions.createDynamic(options);\r\n}\r\nvar DidChangeDecorationsEmitter = /** @class */ (function (_super) {\r\n    __extends(DidChangeDecorationsEmitter, _super);\r\n    function DidChangeDecorationsEmitter() {\r\n        var _this = _super.call(this) || this;\r\n        _this._actual = _this._register(new Emitter());\r\n        _this.event = _this._actual.event;\r\n        _this._deferredCnt = 0;\r\n        _this._shouldFire = false;\r\n        return _this;\r\n    }\r\n    DidChangeDecorationsEmitter.prototype.beginDeferredEmit = function () {\r\n        this._deferredCnt++;\r\n    };\r\n    DidChangeDecorationsEmitter.prototype.endDeferredEmit = function () {\r\n        this._deferredCnt--;\r\n        if (this._deferredCnt === 0) {\r\n            if (this._shouldFire) {\r\n                this._shouldFire = false;\r\n                this._actual.fire({});\r\n            }\r\n        }\r\n    };\r\n    DidChangeDecorationsEmitter.prototype.fire = function () {\r\n        this._shouldFire = true;\r\n    };\r\n    return DidChangeDecorationsEmitter;\r\n}(Disposable));\r\nexport { DidChangeDecorationsEmitter };\r\n//#endregion\r\nvar DidChangeContentEmitter = /** @class */ (function (_super) {\r\n    __extends(DidChangeContentEmitter, _super);\r\n    function DidChangeContentEmitter() {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\r\n         */\r\n        _this._fastEmitter = _this._register(new Emitter());\r\n        _this.fastEvent = _this._fastEmitter.event;\r\n        _this._slowEmitter = _this._register(new Emitter());\r\n        _this.slowEvent = _this._slowEmitter.event;\r\n        _this._deferredCnt = 0;\r\n        _this._deferredEvent = null;\r\n        return _this;\r\n    }\r\n    DidChangeContentEmitter.prototype.beginDeferredEmit = function () {\r\n        this._deferredCnt++;\r\n    };\r\n    DidChangeContentEmitter.prototype.endDeferredEmit = function () {\r\n        this._deferredCnt--;\r\n        if (this._deferredCnt === 0) {\r\n            if (this._deferredEvent !== null) {\r\n                var e = this._deferredEvent;\r\n                this._deferredEvent = null;\r\n                this._fastEmitter.fire(e);\r\n                this._slowEmitter.fire(e);\r\n            }\r\n        }\r\n    };\r\n    DidChangeContentEmitter.prototype.fire = function (e) {\r\n        if (this._deferredCnt > 0) {\r\n            if (this._deferredEvent) {\r\n                this._deferredEvent = this._deferredEvent.merge(e);\r\n            }\r\n            else {\r\n                this._deferredEvent = e;\r\n            }\r\n            return;\r\n        }\r\n        this._fastEmitter.fire(e);\r\n        this._slowEmitter.fire(e);\r\n    };\r\n    return DidChangeContentEmitter;\r\n}(Disposable));\r\nexport { DidChangeContentEmitter };\r\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords) {\r\n    if (allowInWords === void 0) { allowInWords = ''; }\r\n    var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (var _i = 0, USUAL_WORD_SEPARATORS_1 = USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {\r\n        var sep = USUAL_WORD_SEPARATORS_1[_i];\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\r\nexport function ensureValidWordDefinition(wordDefinition) {\r\n    var result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            var flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\r\n    // find whitespace enclosed text around column and match from there\r\n    var pos = column - 1 - textOffset;\r\n    var start = text.lastIndexOf(' ', pos - 1) + 1;\r\n    wordDefinition.lastIndex = start;\r\n    var match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        var matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return {\r\n                word: match[0],\r\n                startColumn: textOffset + 1 + matchIndex,\r\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\r\n    // matches all words starting at the beginning\r\n    // of the input until it finds a match that encloses\r\n    // the desired column. slow but correct\r\n    var pos = column - 1 - textOffset;\r\n    wordDefinition.lastIndex = 0;\r\n    var match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        var matchIndex = match.index || 0;\r\n        if (matchIndex > pos) {\r\n            // |nW -> matched only after the pos\r\n            return null;\r\n        }\r\n        else if (wordDefinition.lastIndex >= pos) {\r\n            // W|W -> match encloses pos\r\n            return {\r\n                word: match[0],\r\n                startColumn: textOffset + 1 + matchIndex,\r\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\r\n    // if `words` can contain whitespace character we have to use the slow variant\r\n    // otherwise we use the fast variant of finding a word\r\n    wordDefinition.lastIndex = 0;\r\n    var match = wordDefinition.exec(text);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    // todo@joh the `match` could already be the (first) word\r\n    var ret = match[0].indexOf(' ') >= 0\r\n        // did match a word which contains a space character -> use slow word find\r\n        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\r\n        // sane word definition -> use fast word find\r\n        : getWordAtPosFast(column, wordDefinition, text, textOffset);\r\n    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\r\n    // in an undefined state and to not confuse other users of the wordDefinition\r\n    // we reset the lastIndex\r\n    wordDefinition.lastIndex = 0;\r\n    return ret;\r\n}\r\n"],"sourceRoot":""}