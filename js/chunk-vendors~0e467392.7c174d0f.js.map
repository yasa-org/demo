{"version":3,"sources":["webpack:///./node_modules/zrender/lib/Handler.js","webpack:///./node_modules/zrender/lib/Element.js"],"names":["util","vec2","Draggable","Eventful","eventTool","GestureMgr","SILENT","makeEventPacket","eveType","targetInfo","event","type","target","topTarget","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","zrByTouch","which","stop","stopEvent","this","EmptyProxy","prototype","dispose","handlerNames","Handler","storage","painter","proxy","painterRoot","call","_hovered","_lastTouchMoment","_lastX","_lastY","_gestureMgr","setHandlerProxy","isHover","displayable","x","y","rectHover","isSilent","el","clipPath","contain","silent","parent","isOutsideBoundary","handlerInstance","getWidth","getHeight","constructor","each","name","on","handler","mousemove","isOutside","lastHovered","lastHoveredTarget","__zr","findHover","hovered","hoveredTarget","setCursor","cursor","dispatchToElement","mouseout","eventControl","zrEventControl","zrIsToLocalDOM","trigger","resize","dispatch","eventName","eventArgs","setCursorStyle","cursorStyle","eventHandler","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","out","i","length","hoverCheckResult","ignore","processGesture","stage","gestureMgr","clear","gestureInfo","recognize","dom","_downEl","_downPoint","_upEl","dist","mixin","_default","module","exports","guid","Transformable","Animatable","zrUtil","Element","opts","id","isGroup","drift","dx","dy","draggable","m","transform","decomposeTransform","dirty","beforeUpdate","afterUpdate","update","updateTransform","traverse","cb","context","attrKV","key","value","hide","refresh","show","attr","isObject","hasOwnProperty","setClipPath","zr","addSelfToZr","removeClipPath","__clipTarget","removeSelfFromZr","animators","animation","addAnimator","removeAnimator"],"mappings":"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","file":"js/chunk-vendors~0e467392.7c174d0f.js","sourcesContent":["var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar eventTool = require(\"./core/event\");\n\nvar GestureMgr = require(\"./core/GestureMgr\");\n\n/**\n * [The interface between `Handler` and `HandlerProxy`]:\n *\n * The default `HandlerProxy` only support the common standard web environment\n * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).\n * But `HandlerProxy` can be replaced to support more non-standard environment\n * (e.g., mini app), or to support more feature that the default `HandlerProxy`\n * not provided (like echarts-gl did).\n * So the interface between `Handler` and `HandlerProxy` should be stable. Do not\n * make break changes util inevitable. The interface include the public methods\n * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`\n * drives `Handler`.\n */\n\n/**\n * [Drag outside]:\n *\n * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the\n * zrender area when dragging. That is important for the improvement of the user experience\n * when dragging something near the boundary without being terminated unexpectedly.\n *\n * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`\n * to resolve this issue. But some drawbacks of it is described in\n * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899\n *\n * Instead, we referenced the specifications:\n * https://www.w3.org/TR/touch-events/#the-touchmove-event\n * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove\n * where the the mousemove/touchmove can be continue to fire if the user began a drag\n * operation and the pointer has left the boundary. (for the mouse event, browsers\n * only do it on `document` and when the pointer has left the boundary of the browser.)\n *\n * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging\n * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue\n * to fire until release the pointer. That is implemented by listen to those event on\n * `document`.\n * If we implement some other `HandlerProxy` only for touch device, that would be easier.\n * The touch event support this feature by default.\n *\n * Note:\n * There might be some cases that the mouse event can not be\n * received on `document`. For example,\n * (A) `useCapture` is not supported and some user defined event listeners on the ancestor\n * of zr dom throw Error .\n * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of\n * zr dom call `stopPropagation`.\n * In these cases, the `mousemove` event might be keep triggered event\n * if the mouse is released. We try to reduce the side-effect in those cases.\n * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.\n *\n * Note:\n * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to\n * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event\n * target is not zrender dom. Becuase it is dangerous to enable users to call them in\n * `document` capture phase to prevent the propagation to any listener of the webpage.\n * But they are needed to work when the pointer inside the zrender dom.\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which,\n    stop: stopEvent\n  };\n}\n\nfunction stopEvent() {\n  eventTool.stop(this.event);\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = null;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr;\n  Draggable.call(this);\n  this.setHandlerProxy(proxy);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  setHandlerProxy: function (proxy) {\n    if (this.proxy) {\n      this.proxy.dispose();\n    }\n\n    if (proxy) {\n      util.each(handlerNames, function (name) {\n        proxy.on && proxy.on(name, this[name], this);\n      }, this); // Attach handler\n\n      proxy.handler = this;\n    }\n\n    this.proxy = proxy;\n  },\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var isOutside = isOutsideBoundary(this, x, y);\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = isOutside ? {\n      x: x,\n      y: y\n    } : this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    var eventControl = event.zrEventControl;\n    var zrIsToLocalDOM = event.zrIsToLocalDOM;\n\n    if (eventControl !== 'only_globalout') {\n      this.dispatchToElement(this._hovered, 'mouseout', event);\n    }\n\n    if (eventControl !== 'no_globalout') {\n      // FIXME: if the pointer moving from the extra doms to realy \"outside\",\n      // the `globalout` should have been triggered. But currently not.\n      !zrIsToLocalDOM && this.trigger('globalout', {\n        type: 'globalout',\n        event: event\n      });\n    }\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] === 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  },\n  processGesture: function (event, stage) {\n    if (!this._gestureMgr) {\n      this._gestureMgr = new GestureMgr();\n    }\n\n    var gestureMgr = this._gestureMgr;\n    stage === 'start' && gestureMgr.clear();\n    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);\n    stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n    if (gestureInfo) {\n      var type = gestureInfo.type;\n      event.gestureEvent = type;\n      this.dispatchToElement({\n        target: gestureInfo.target\n      }, type, gestureInfo.event);\n    }\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var isOutside = isOutsideBoundary(this, x, y);\n    var hovered;\n    var hoveredTarget;\n\n    if (name !== 'mouseup' || !isOutside) {\n      // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n      hovered = this.findHover(x, y);\n      hoveredTarget = hovered.target;\n    }\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mouseup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n/**\n * See [Drag outside].\n */\n\n\nfunction isOutsideBoundary(handlerInstance, x, y) {\n  var painter = handlerInstance.painter;\n  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;","var guid = require(\"./core/guid\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar Transformable = require(\"./mixin/Transformable\");\n\nvar Animatable = require(\"./mixin/Animatable\");\n\nvar zrUtil = require(\"./core/util\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * 画布元素ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * 元素类型\n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * 元素名字\n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n   * 该路径会继承被裁减对象的变换\n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * 是否是 Group\n   * @type {boolean}\n   */\n  isGroup: false,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // 添加动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // 移除动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;"],"sourceRoot":""}