{"version":3,"sources":["webpack:///./node_modules/echarts/lib/layout/points.js","webpack:///./node_modules/echarts/lib/layout/barGrid.js"],"names":["_util","map","createRenderPlanner","_dataStackHelper","isDimensionStacked","_default","seriesType","plan","reset","seriesModel","data","getData","coordSys","coordinateSystem","pipelineContext","isLargeRender","large","dims","dimensions","dim","mapDimension","slice","dimLen","length","stackResultDim","getCalculationInfo","progress","params","segCount","end","start","points","Float32Array","i","offset","tmpIn","tmpOut","point","x","get","isNaN","dataToPoint","y","NaN","setItemLayout","setLayout","module","exports","zrUtil","_number","parsePercent","STACK_PREFIX","LARGE_BAR_MIN_WIDTH","LargeArr","Array","getSeriesStackId","seriesIndex","getAxisKey","axis","index","getLayoutOnAxis","opt","baseAxis","axisKey","type","bandWidth","getBandWidth","count","push","defaults","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","width","prepareLayoutBarSeries","ecModel","seriesModels","eachSeriesByType","isOnCartesian","isInLargeMode","getValueAxesMinGaps","barSeries","axisValues","each","cartesian","getBaseAxis","key","cnt","value","axisMinGaps","hasOwnProperty","valuesInAxis","sort","a","b","min","j","delta","Math","makeColumnLayout","seriesInfoList","axisExtent","getExtent","minGap","extentSpan","abs","scale","scaleSpan","barWidth","barMaxWidth","barMinWidth","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","minWidth","coordSysName","barGapPercent","autoWidth","max","column","finalWidth","lastColumn","widthSum","retrieveColumnLayout","barWidthAndOffset","layout","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","barMinHeight","size","valueDim","baseDim","stacked","isValueAxisH","isHorizontal","valueAxisStart","getValueAxisStart","len","height","baseValue","sign","baseCoord","p","n","coord","this","largeLayout","coordLayout","grid","getRect","valueAxisHorizontal","valueDimIdx","dataIndex","largePoints","largeBackgroundPoints","largeDataIndices","valuePair","pointsOffset","idxOffset","next","backgroundStart","toGlobalCoord","dataToCoord"],"mappings":"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","file":"js/chunk-vendors~5f2a7c9c.08fa5536.js","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0]\n      /*, dims[1]*/\n      )) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1]\n      /*, dims[0]*/\n      )) {\n        dims[1] = stackResultDim;\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i);\n            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float32Array */\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barMinWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\n * values.\n * This works for time axes, value axes, and log axes.\n * For a single time axis, return value is in the form like\n * {'x_0': [1000000]}.\n * The value of 1000000 is in milliseconds.\n */\n\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\n   * Map from axis.index to values.\n   * For a single time axis, axisValues is in the form like\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\n   * series.\n   */\n  var axisValues = {};\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dim = data.mapDimension(baseAxis.dim);\n\n    for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n      var value = data.get(dim, i);\n\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n\n    }\n  });\n  var axisMinGaps = [];\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent( // barMinWidth by default is 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 1.\n    seriesModel.get('barMinWidth') || 1, bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {Object} barWidthAndOffset The result of makeColumnLayout\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.\n * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.\n */\n\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      result = result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n\n      if (stacked) {\n        // Only ordinal axis can be stacked.\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            // Positive stack\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n\n        if (!isNaN(width)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n        }\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        } // Ignore stack from NaN value\n\n\n        if (!isNaN(height)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n        }\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  }, this);\n} // TODO: Do not support stack in large mode yet.\n\n\nvar largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var coordLayout = cartesian.grid.getRect();\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      // jshint ignore:line\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var count = params.count;\n      var largePoints = new LargeArr(count * 2);\n      var largeBackgroundPoints = new LargeArr(count * 2);\n      var largeDataIndices = new LargeArr(count);\n      var dataIndex;\n      var coord = [];\n      var valuePair = [];\n      var pointsOffset = 0;\n      var idxOffset = 0;\n\n      while ((dataIndex = params.next()) != null) {\n        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n        coord = cartesian.dataToPoint(valuePair, null, coord); // Data index might not be in order, depends on `progressiveChunkMode`.\n\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n        largePoints[pointsOffset++] = coord[0];\n        largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n        largePoints[pointsOffset++] = coord[1];\n        largeDataIndices[idxOffset++] = dataIndex;\n      }\n\n      data.setLayout({\n        largePoints: largePoints,\n        largeDataIndices: largeDataIndices,\n        largeBackgroundPoints: largeBackgroundPoints,\n        barWidth: barWidth,\n        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n        backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n        valueAxisHorizontal: valueAxisHorizontal\n      });\n    }\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\nexports.makeColumnLayout = makeColumnLayout;\nexports.retrieveColumnLayout = retrieveColumnLayout;\nexports.layout = layout;\nexports.largeLayout = largeLayout;"],"sourceRoot":""}