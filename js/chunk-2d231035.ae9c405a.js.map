{"version":3,"sources":["webpack:///./node_modules/monaco-editor/esm/vs/language/css/_deps/vscode-css-languageservice/_deps/vscode-languageserver-textdocument/lib/esm/main.js"],"names":["TextDocument","FullTextDocument","uri","languageId","version","content","this","_uri","_languageId","_version","_content","_lineOffsets","undefined","Object","defineProperty","prototype","get","enumerable","configurable","getText","range","start","offsetAt","end","substring","update","changes","_i","changes_1","length","change","isIncremental","getWellformedRange","startOffset","endOffset","text","startLine","Math","max","line","endLine","lineOffsets","addedLineOffsets","computeLineOffsets","i","len","splice","apply","concat","slice","diff","isFull","Error","getLineOffsets","positionAt","offset","min","low","high","character","mid","floor","position","lineOffset","nextLineOffset","event","candidate","rangeLength","mergeSort","data","compare","p","left","right","leftIdx","rightIdx","ret","isAtLineStart","textOffset","result","ch","charCodeAt","push","getWellformedEdit","textEdit","newText","create","document","applyEdits","edits","sortedEdits","map","a","b","lastModifiedOffset","e"],"mappings":"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","file":"js/chunk-2d231035.ae9c405a.js","sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (changes, version) {\r\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\r\n            var change = changes_1[_i];\r\n            if (FullTextDocument.isIncremental(change)) {\r\n                // makes sure start is before end\r\n                var range = getWellformedRange(change.range);\r\n                // update content\r\n                var startOffset = this.offsetAt(range.start);\r\n                var endOffset = this.offsetAt(range.end);\r\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\r\n                // update the offsets\r\n                var startLine = Math.max(range.start.line, 0);\r\n                var endLine = Math.max(range.end.line, 0);\r\n                var lineOffsets = this._lineOffsets;\r\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\r\n                if (endLine - startLine === addedLineOffsets.length) {\r\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\r\n                    }\r\n                }\r\n                else {\r\n                    if (addedLineOffsets.length < 10000) {\r\n                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\r\n                    }\r\n                    else { // avoid too many arguments for splice\r\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\r\n                    }\r\n                }\r\n                var diff = change.text.length - (endOffset - startOffset);\r\n                if (diff !== 0) {\r\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i] = lineOffsets[i] + diff;\r\n                    }\r\n                }\r\n            }\r\n            else if (FullTextDocument.isFull(change)) {\r\n                this._content = change.text;\r\n                this._lineOffsets = undefined;\r\n            }\r\n            else {\r\n                throw new Error('Unknown change event received');\r\n            }\r\n        }\r\n        this._version = version;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === undefined) {\r\n            this._lineOffsets = computeLineOffsets(this._content, true);\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return { line: 0, character: offset };\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return { line: line, character: offset - lineOffsets[line] };\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.isIncremental = function (event) {\r\n        var candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\r\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\r\n    };\r\n    FullTextDocument.isFull = function (event) {\r\n        var candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\r\n    };\r\n    return FullTextDocument;\r\n}());\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new text document.\r\n     *\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param version The document's initial version number.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Updates a TextDocument by modifing its content.\r\n     *\r\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\r\n     * @param changes the changes to apply to the document.\r\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\r\n     *\r\n     */\r\n    function update(document, changes, version) {\r\n        if (document instanceof FullTextDocument) {\r\n            document.update(changes, version);\r\n            return document;\r\n        }\r\n        else {\r\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\r\n        }\r\n    }\r\n    TextDocument.update = update;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n})(TextDocument || (TextDocument = {}));\r\nfunction mergeSort(data, compare) {\r\n    if (data.length <= 1) {\r\n        // sorted\r\n        return data;\r\n    }\r\n    var p = (data.length / 2) | 0;\r\n    var left = data.slice(0, p);\r\n    var right = data.slice(p);\r\n    mergeSort(left, compare);\r\n    mergeSort(right, compare);\r\n    var leftIdx = 0;\r\n    var rightIdx = 0;\r\n    var i = 0;\r\n    while (leftIdx < left.length && rightIdx < right.length) {\r\n        var ret = compare(left[leftIdx], right[rightIdx]);\r\n        if (ret <= 0) {\r\n            // smaller_equal -> take left to preserve order\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        else {\r\n            // greater -> take right\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n    }\r\n    while (leftIdx < left.length) {\r\n        data[i++] = left[leftIdx++];\r\n    }\r\n    while (rightIdx < right.length) {\r\n        data[i++] = right[rightIdx++];\r\n    }\r\n    return data;\r\n}\r\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\r\n    if (textOffset === void 0) { textOffset = 0; }\r\n    var result = isAtLineStart ? [textOffset] : [];\r\n    for (var i = 0; i < text.length; i++) {\r\n        var ch = text.charCodeAt(i);\r\n        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\r\n            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                i++;\r\n            }\r\n            result.push(textOffset + i + 1);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getWellformedRange(range) {\r\n    var start = range.start;\r\n    var end = range.end;\r\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\r\n        return { start: end, end: start };\r\n    }\r\n    return range;\r\n}\r\nfunction getWellformedEdit(textEdit) {\r\n    var range = getWellformedRange(textEdit.range);\r\n    if (range !== textEdit.range) {\r\n        return { newText: textEdit.newText, range: range };\r\n    }\r\n    return textEdit;\r\n}\r\n"],"sourceRoot":""}